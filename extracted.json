[
  {
    "problem_id": "p00000",
    "problem_statement": "\nQQ\n\nWrite a program which prints multiplication tables in the following format:\n\n\n1x1=1\n1x2=2\n.\n.\n9x8=72\n9x9=81\n\nInput\n\nNo input.\n\nOutput\n\n1x1=1\n1x2=2\n.\n.\n9x8=72\n9x9=81\n\nTemplate for C\n\n#include<stdio.h>\n\nint main(){\n\n    return 0;\n}\n\nTemplate for C++\n\n#include<iostream>\nusing namespace std;\n\nint main(){\n\n    return 0;\n}\n\nTemplate for Java\n\nclass Main{\n    public static void main(String[] a){\n\n    }\n}\n",
    "buggy": "for i in range(1,10):\n    for j in range(1,10):\n        print(i,\"x\",j,\"=\",i*j)",
    "fixed": "for i in range(1,10):\n    for j in range(1,10):\n        print(i,\"x\",j,\"=\",i*j,sep=\"\")"
  },
  {
    "problem_id": "p00001",
    "problem_statement": "\nList of Top 3 Hills\n\nThere is a data which provides heights (in meter) of mountains. The data is only for ten mountains.\n\n\nWrite a program which prints heights of the top three mountains in descending order.\n\nInput\n\nHeight of mountain 1\nHeight of mountain 2\nHeight of mountain 3\n .\n .\nHeight of mountain 10\n\nConstraints\n\n0 ≤ height of mountain (integer) ≤ 10,000\n\nOutput\n\nHeight of the 1st mountain\nHeight of the 2nd mountain\nHeight of the 3rd mountain\n\nSample Input 1\n\n1819\n2003\n876\n2840\n1723\n1673\n3776\n2848\n1592\n922\n\nOutput for the Sample Input 1\n\n3776\n2848\n2840\n\nSample Input 2\n\n100\n200\n300\n400\n500\n600\n700\n800\n900\n900\n\nOutput for the Sample Input 2\n\n900\n900\n800\n\n",
    "buggy": "num = [int(input()) for i in range(10)]\nnum.sort(reverse=True)\nfor i in range[0:3]:\n    print(num[i])\n",
    "fixed": "num = [int(input()) for i in range(10)]\nnum.sort(reverse=True)\nfor i in range(3):\n    print(num[i])\n"
  },
  {
    "problem_id": "p00002",
    "problem_statement": "\nDigit Number\n\nWrite a program which computes the digit number of sum of two integers a and b.\n\nInput\n\nThere are several test cases. Each test case consists of two non-negative integers a and b which are separeted by a space in a line. The input terminates with EOF.\n\nConstraints\n\n0 ≤ a, b ≤ 1,000,000\nThe number of datasets ≤ 200\n\nOutput\n\nPrint the number of digits of a + b for each data set.\n\nSample Input\n\n5 7\n1 99\n1000 999\n\nOutput for the Sample Input\n\n2\n3\n4\n\n",
    "buggy": "import math\n\ndef main():\n    data = []\n    while 1:\n        try:\n            n = input().split()\n            a = int(n[0])\n            b = int(n[1])\n            ans = int(math.log10(a+b)+1)\n            data.append(ans)\n        except IndexError:\n            #EOF\n            break\n            \n    for i in data:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()",
    "fixed": "import math\n\ndef main():\n    data = []\n    while 1:\n        try:\n            n = input().split()\n            a = int(n[0])\n            b = int(n[1])\n            ans = int(math.log10(a+b)+1)\n            data.append(ans)\n        except EOFError:\n            break\n\n    for i in data:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "problem_id": "p00003",
    "problem_statement": "\nIs it a Right Triangle?\n\nWrite a program which judges wheather given length of three side form a right triangle. Print \"YES\" if the given sides (integers) form a right triangle, \"NO\" if not so.\n\nInput\n\nInput consists of several data sets. In the first line, the number of data set, N is given. Then, N lines follow, each line corresponds to a data set. A data set consists of three integers separated by a single space.\n\nConstraints\n\n 1 ≤ length of the side ≤ 1,000\n N ≤ 1,000\n\nOutput\n\nFor each data set, print \"YES\" or \"NO\".\n\nSample Input\n\n3\n4 3 5\n4 3 6\n8 8 8\n\nOutput for the Sample Input\n\nYES\nNO\nNO\n\n",
    "buggy": "n=int(input())\nfor i in range(n):\n    p=list(map(int,input().split()))\n    p.sort()\n    a=x[0]\n    b=x[1]\n    c=x[2]\n    if a*a+b*b==c*c:\n        print('YES')\n    else:\n        print('NO')\n",
    "fixed": "n=int(input())\nfor i in range(n):\n    p=list(map(int,input().split()))\n    p.sort()\n    a=p[0]\n    b=p[1]\n    c=p[2]\n    if a*a+b*b==c*c:\n        print('YES')\n    else:\n        print('NO')\n"
  },
  {
    "problem_id": "p00004",
    "problem_statement": "\nSimultaneous Equation\n\nWrite a program which solve a simultaneous equation:\n\n ax + by = c\n dx + ey = f\n\n\nThe program should print x and y for given a, b, c, d, e and f (-1,000 ≤ a, b, c, d, e, f ≤ 1,000). You can suppose that given equation has a unique solution.\n\nInput\n\nThe input consists of several data sets, 1 line for each data set. In a data set, there will be a, b, c, d, e, f separated by a single space. The input terminates with EOF.\n\nOutput\n\nFor each data set, print x and y separated by a single space. Print the solution to three places of decimals. Round off the solution to three decimal places.\n\nSample Input 1\n\n1 2 3 4 5 6\n2 -1 -2 -1 -1 -5\n\nOutput for the Sample Input 1\n\n-1.000 2.000\n1.000 4.000\n\nSample Input 2\n\n2 -1 -3 1 -1 -3\n2 -1 -3 -9 9 27\n\nOutput for the Sample Input 2\n\n0.000 3.000\n0.000 3.000\n\n",
    "buggy": "def equation(a,b,c,d,e,f,x):\n    buff = a*e-b*d\n    buff_a = a\n\n    a = e/buff\n    b = -b/buff\n    d = -d/buff\n    e = buff_a/buff\n\n    x.append((a*c)+(b*f))\n    x.append((d*c)+(e*f))\n\ncount = 0\na = []\nb = []\nc = []\nd = []\ne = []\nf = []\n\nwhile True:\n    try:\n        buff = input().split()\n        a.append(float(buff[0]))\n        b.append(float(buff[1]))\n        c.append(float(buff[2]))  \n        d.append(float(buff[3]))\n        e.append(float(buff[4]))\n        f.append(float(buff[5]))\n        count += 1\n    except:\n        break\n\nfor i in range(count):\n    ans = []\n\n    equation(a[i],b[i],c[i],d[i],e[i],f[i],ans)\n    print('{:.4f}'.format(ans[0]),'{:.4f}'.format(ans[1]))\n",
    "fixed": "def equation(a,b,c,d,e,f,x):\n    buff = a*e-b*d\n    buff_a = a\n\n    a = e/buff\n    b = -b/buff\n    d = -d/buff\n    e = buff_a/buff\n\n    x.append((a*c)+(b*f))\n    x.append((d*c)+(e*f))\n\ncount = 0\na = []\nb = []\nc = []\nd = []\ne = []\nf = []\n\nwhile True:\n    try:\n        buff = input().split()\n        a.append(float(buff[0]))\n        b.append(float(buff[1]))\n        c.append(float(buff[2]))  \n        d.append(float(buff[3]))\n        e.append(float(buff[4]))\n        f.append(float(buff[5]))\n        count += 1\n    except:\n        break\n\nfor i in range(count):\n    ans = []\n\n    equation(a[i],b[i],c[i],d[i],e[i],f[i],ans)\n    print('{:.3f}'.format(ans[0]),'{:.3f}'.format(ans[1]))\n"
  },
  {
    "problem_id": "p00005",
    "problem_statement": "\nGCD and LCM\n\nWrite a program which computes the greatest common divisor (GCD) and the least common multiple (LCM) of given a and b. \n\nInput\n\nInput consists of several data sets. Each data set contains a and b separated by a single space in a line. The input terminates with EOF.\n\nConstraints\n\n 0 < a, b ≤ 2,000,000,000\n LCM(a, b) ≤ 2,000,000,000\n The number of data sets ≤ 50\n\nOutput\n\nFor each data set, print GCD and LCM separated by a single space in a line.\n\nSample Input\n\n8 6\n50000000 30000000\n\nOutput for the Sample Input\n\n2 24\n10000000 150000000\n\n",
    "buggy": "import sys\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    A, B = min(a, b), max(a, b)\n\n    while True:\n        mod = B % A\n        if mod == 0:\n            gcd = B / A\n            break\n        else:\n            A, B = mod, A\n    lcm = gcd * (a / gcd) * (b / gcd)\n\n    print('%d %d' % (gcd, lcm))",
    "fixed": "import sys\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    A, B = min(a, b), max(a, b)\n\n    while True:\n        mod = B % A\n        if mod == 0:\n            gcd = A\n            break\n        else:\n            A, B = mod, A\n    lcm = gcd * (a / gcd) * (b / gcd)\n\n    print('%d %d' % (gcd, lcm))"
  },
  {
    "problem_id": "p00006",
    "problem_statement": "\nReverse Sequence\n\nWrite a program which reverses a given string str.\n\nInput\n\nstr (the size of str ≤ 20) is given in a line.\n\nOutput\n\nPrint the reversed str in a line.\n\nSample Input\n\nw32nimda\n\nOutput for the Sample Input\n\nadmin23w\n\n",
    "buggy": "# -*- coding: utf-8 -*-\n\nimport sys\n\nfor line in sys.stdin.readlines():\n    #List = map(int, line.strip().split())\n    seq = line.split()\n    print(seq[::-1])",
    "fixed": "# -*- coding: utf-8 -*-\n\nimport sys\n\nfor line in sys.stdin.readlines():\n    #List = map(int, line.strip().split())\n    \n    seq = line.strip()\n    print(seq[::-1])"
  },
  {
    "problem_id": "p00007",
    "problem_statement": "\nDebt Hell\n\nYour friend who lives in undisclosed country is involved in debt. He is borrowing 100,000-yen from a loan shark. The loan shark adds 5% interest of the debt and rounds it to the nearest 1,000 above week by week.\n\n\nWrite a program which computes the amount of the debt in n weeks. \n\nInput\n\nAn integer n (0 ≤ n ≤ 100) is given in a line.\n\nOutput\n\nPrint the amout of the debt in a line.\n\nSample Input\n\n5\n\nOutput for the Sample Input\n\n130000\n\n",
    "buggy": "import math\n\ndebt = 100\nfor i in range(int(input())):\n    ceil = math.ceil(debt*1.05)\nprint(debt*1000)",
    "fixed": "import math\n\ndebt = 100\nfor i in range(int(input())):\n    debt = math.ceil(debt*1.05)\n\nprint(debt*1000)"
  },
  {
    "problem_id": "p00008",
    "problem_statement": "\nSum of 4 Integers\n\nWrite a program which reads an integer n  and identifies the number of combinations of a, b, c and d (0 ≤ a, b, c, d ≤ 9) which meet the following equality:\n\na + b + c + d = n\n\n\nFor example, for n = 35, we have 4 different combinations of (a, b, c, d): (8, 9, 9, 9), (9, 8, 9, 9), (9, 9, 8, 9), and (9, 9, 9, 8).\n\nInput\n\nThe input consists of several datasets. Each dataset consists of n (1 ≤ n ≤ 50) in a line. The number of datasets is less than or equal to 50.\n\nOutput\n\nPrint the number of combination in a line.\n\nSample Input\n\n35\n1\n\nOutput for the Sample Input\n\n4\n4\n\n",
    "buggy": "x=[0]*37\nfor a in range(10):\n\tfor b in range(10):\n\t\tfor c in range(10):\n\t\t\tfor d in range(10):\n\t\t\t\tx[a+b+c+d]+=1\nwhile True:\n\ttry:\n\t\tprint(x[int(input())])\n\texcept:\n\t\tbreak",
    "fixed": "x=[0]*51\nfor a in range(10):\n\tfor b in range(10):\n\t\tfor c in range(10):\n\t\t\tfor d in range(10):\n\t\t\t\tx[a+b+c+d]+=1\nwhile True:\n\ttry:\n\t\tprint(x[int(input())])\n\texcept:\n\t\tbreak"
  },
  {
    "problem_id": "p00009",
    "problem_statement": "\nPrime Number\n\nWrite a program which reads an integer n and prints the number of prime numbers which are less than or equal to n. A prime number is a natural number which has exactly two distinct natural number divisors: 1 and itself. For example, the first four prime numbers are: 2, 3, 5 and 7.\n\nInput\n\nInput consists of several datasets. Each dataset has an integer n (1 ≤ n ≤ 999,999) in a line.\n\n\nThe number of datasets is less than or equal to 30.\n\nOutput\n\nFor each dataset, prints the number of prime numbers.\n\nSample Input\n\n10\n3\n11\n\nOutput for the Sample Input\n\n4\n2\n5\n\n",
    "buggy": "import sys\nn=10**5\ns=[True]*n\ns[0]=False\ns[1]=False\nfor x in range(2, int(n**0.5)+1):\n    if s[x]:\n        for i in range(x+x,n,x):\n            s[i]=False\nfor x in sys.stdin.readlines():\n    x=int(x)\n    cnt=0\n    for i in range(x):\n        if s[i]:\n            cnt=cnt+1\n    print(cnt)",
    "fixed": "import sys\nn=10**6\ns=[True]*n\ns[0]=False\ns[1]=False\nfor x in range(2, int(n**0.5)+1):\n    if s[x]:\n        for i in range(x+x,n,x):\n            s[i]=False\nfor x in sys.stdin.readlines():\n    x=int(x)+1\n    cnt=0\n    for i in range(x):\n        if s[i]:\n            cnt=cnt+1\n    print(cnt)"
  },
  {
    "problem_id": "p00010",
    "problem_statement": "\n\n\nCircumscribed Circle of A Triangle.\n\nWrite a program which prints the central coordinate $(p_x, p_y)$ and the radius $r$ of a circumscribed circle of a triangle which is constructed by three points $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$ on the plane surface. \n\nInput\n\nInput consists of several datasets. In the first line, the number of datasets $n$ is given. Each dataset consists of:\n\n$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$\n\n\nin a line. All the input are real numbers.\n\nOutput\n\nFor each dataset, print $p_x$, $p_y$ and $r$ separated by a space in a line. Print the solution to three places of decimals. Round off the solution to three decimal places.\n\nConstraints\n\n$-100 \\leq x_1, y_1, x_2, y_2, x_3, y_3 \\leq 100$\n$ n \\leq 20$\n\nSample Input\n\n1\n0.0 0.0 2.0 0.0 2.0 2.0\n\nOutput for the Sample Input\n\n1.000 1.000 1.414\n\n",
    "buggy": "#! -*- coding:utf-8 -*-\nimport math\nn = eval(input())\nfor x in range(n):\n    x1,y1,x2,y2,x3,y3 = list(map(float,input().split()))\n    a1 = 2.0*(x2-x1)\n    b1 = 2.0*(y2-y1)\n    x12 = x1**2\n    y12 = y1**2\n    c1 = x12-x2**2+y12+y2**2\n    a2 = 2.0*(x3-x1)\n    b2 = 2.0*(y3-y1)\n    c2 = x12-x3**2+y12-y3**2\n    denom=(a1*b2-a2*b1)\n    x = (b1*c2-b2*c1)/denom\n    y = (c1*a2-c2*a1)/denom\n    r = math.sqrt((x-x1)**2+(y-y1)**2)\n\n    print(\"%.3f %.3f %.3f\"%(x,y,r))",
    "fixed": "#! -*- coding:utf-8 -*-\nimport math\nn = eval(input())\nfor x in range(n):\n    x1,y1,x2,y2,x3,y3 = list(map(float,input().split()))\n    a1 = 2.0*(x2-x1)\n    b1 = 2.0*(y2-y1)\n    x12 = x1**2\n    y12 = y1**2\n    c1 = x12-x2**2+y12-y2**2\n    a2 = 2.0*(x3-x1)\n    b2 = 2.0*(y3-y1)\n    c2 = x12-x3**2+y12-y3**2\n    denom=(a1*b2-a2*b1)\n    # print \"x1^2 : \"+str(x12)\n    # print \"y1^2 : \"+str(y12)\n    # print \"a1 : \"+str(a1)\n    # print \"b1 : \"+str(b1)\n    # print \"c1 : \"+str(c1)\n    # print \"a2 : \"+str(a2)\n    # print \"b2 : \"+str(b2)\n    # print \"c2 : \"+str(c2)\n    # print \"denom : \"+str(denom)\n    x = (b1*c2-b2*c1)/denom\n    y = (c1*a2-c2*a1)/denom\n    r = math.sqrt((x-x1)**2+(y-y1)**2)\n\n    print(\"%.3f %.3f %.3f\"%(x,y,r))"
  },
  {
    "problem_id": "p00012",
    "problem_statement": "\n\n\nA Point in a Triangle\n\nThere is a triangle formed by three points $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$ on a plain.\n\n\nWrite a program which prints \"YES\" if a point $P$ $(x_p, y_p)$ is in the triangle and \"NO\" if not.\n\n\nInput\n\nInput consists of several datasets. Each dataset consists of:\n\n$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_p$ $y_p$\n\n\nAll the input are real numbers. Input ends with EOF. The number of datasets is less than or equal to 100.\n\nConstraints\n\nYou can assume that:\n\n\n$ -100 \\leq x_1, y_1, x_2, y_2, x_3, y_3, x_p, y_p \\leq 100$\n1.0 $\\leq$ Length of each side of a tringle\n0.001 $\\leq$ Distance between $P$ and each side of a triangle\n\nOutput\n\nFor each dataset, print \"YES\" or \"NO\" in a line.\n\nSample Input\n\n0.0 0.0 2.0 0.0 2.0 2.0 1.5 0.5\n0.0 0.0 1.0 4.0 5.0 3.0 -1.0 3.0\n\nOutput for the Sample Input\n\nYES\nNO\n\n",
    "buggy": "import sys\n\ndef crossMulti(p1, p2):\n    return p1[0] * p2[1] - p1[1] * p2[0]\n           \nlines = sys.stdin.readlines()\nfor line in lines:\n    Zd = []\n    x1, y1, x2, y2, x3, y3, xp, yp = map(float, line.split())\n    Ps = [(x2-x1, y2-y1),(x3-x2, y3-y2),(x1-x3, y1-y3)]\n    Px = [(xp-x1, yp-y1),(xp-x2, yp-y2),(xp-x3, yp-y3)]\n    for p in range(3):\n        Zd.append(crossMulti(Ps[p], Px[p]))\n    Zd = [x > 0 for x in Zd]\n\n    if (Zd[0] and Zd[1] and Zd[2]) or not(Zd[0] or Zd[1] or Zd[2]):\n        print('Yes')\n    else:\n        print('No')\n    ",
    "fixed": "import sys\n\ndef crossMulti(p1, p2):\n    return p1[0] * p2[1] - p1[1] * p2[0]\n           \nlines = sys.stdin.readlines()\nfor line in lines:\n    Zd = []\n    x1, y1, x2, y2, x3, y3, xp, yp = map(float, line.split())\n    Ps = [(x2-x1, y2-y1),(x3-x2, y3-y2),(x1-x3, y1-y3)]\n    Px = [(xp-x1, yp-y1),(xp-x2, yp-y2),(xp-x3, yp-y3)]\n    for p in range(3):\n        Zd.append(crossMulti(Ps[p], Px[p]))\n    Zd = [x > 0 for x in Zd]\n\n    if (Zd[0] and Zd[1] and Zd[2]) or not(Zd[0] or Zd[1] or Zd[2]):\n        print('YES')\n    else:\n        print('NO')\n    "
  },
  {
    "problem_id": "p00013",
    "problem_statement": "\nSwitching Railroad Cars\n\n\n\n\n\nThis figure shows railway tracks for reshuffling cars. The rail tracks end in the bottom and the top-left rail track is used for the entrace and the top-right rail track is used for the exit. Ten cars, which have numbers from 1 to 10 respectively, use the rail tracks.\n\n\nWe can simulate the movement (comings and goings) of the cars as follow: \n\n\nAn entry of a car is represented by its number.\nAn exit of a car is represented by 0\n\n\nFor example, a sequence\n\n\n1\n6\n0\n8\n10\n\n\ndemonstrates that car 1 and car 6 enter to the rail tracks in this order, car 6 exits from the rail tracks, and then car 8 and car 10 enter.\n\n\nWrite a program which simulates comings and goings of the cars which are represented by the sequence of car numbers. The program should read the sequence of car numbers and 0, and print numbers of cars which exit from the rail tracks in order. At the first, there are no cars on the rail tracks. You can assume that 0 will not be given when there is no car on the rail tracks.\n\nInput\n\ncar number\ncar number or 0\ncar number or 0\n  .\n  .\n  .\ncar number or 0\n\n\nThe number of input lines is less than or equal to 100.\n\nOutput\n\nFor each 0, print the car number.\n\nSample Input\n\n1\n6\n0\n8\n10\n0\n0\n0\n\nOutput for the Sample Input\n\n6\n10\n8\n1\n\n",
    "buggy": "import sys\ncars = []\nfor line in sys.stdin:\n    car = int(line)\n    if car:\n        cars.append(num)\n    else:\n        print(cars.pop())",
    "fixed": "import sys\n\ncars = []\nfor line in sys.stdin:\n    car = int(line)\n    if car:\n        cars.append(car)\n    else:\n        print(cars.pop())"
  },
  {
    "problem_id": "p00014",
    "problem_statement": "\n\n\nIntegral\n\nWrite a program which computes the area of a shape represented by the following three lines:\n\n$y = x^2$\n$y = 0$\n$x = 600$\n\n\n\n\nIt is clear that the area is $72000000$, if you use an integral you learn in high school. On the other hand, we can obtain an approximative area of the shape by adding up areas of many rectangles in the shape as shown in the following figure:\n\n\n$f(x) = x^2$\n\n\n\n\nThe approximative area $s$ where the width of the rectangles is $d$ is:\n\narea of rectangle where its width is $d$ and height is $f(d)$ $+$ \narea of rectangle where its width is $d$ and height is $f(2d)$ $+$ \narea of rectangle where its width is $d$ and height is $f(3d)$ $+$ \n...\narea of rectangle where its width is $d$ and height is $f(600 - d)$  \n\n\nThe more we decrease $d$, the higer-precision value which is close to $72000000$ we could obtain. Your program should read the integer $d$ which is a divisor of $600$, and print the area $s$.\n\nInput\n\nThe input consists of several datasets. Each dataset consists of an integer $d$ in a line. The number of datasets is less than or equal to 20.\n\nOutput\n\nFor each dataset, print the area $s$ in a line.\n\nSample Input\n\n20\n10\n\nOutput for the Sample Input\n\n68440000\n70210000\n\n",
    "buggy": "import sys\n\nfor d in map(int, sys.stdin):\n  sum = 0\n  for x in range(d, 600, d):\n    sum += (x**2)*d\n  print(s)",
    "fixed": "import sys\n\nfor d in map(int, sys.stdin):\n  sum = 0\n  for x in range(d, 600, d):\n    sum += (x**2)*d\n  print(sum)"
  },
  {
    "problem_id": "p00015",
    "problem_statement": "\nNational Budget\n\nA country has a budget of more than 81 trillion yen. We want to process such data, but conventional integer type which uses signed 32 bit can represent up to 2,147,483,647.\n\n\nYour task is to write a program which reads two integers (more than or equal to zero), and prints a sum of these integers.\n\n\nIf given integers or the sum have more than 80 digits, print \"overflow\".\n\nInput\n\nInput consists of several datasets. In the first line, the number of datasets N (1 ≤ N ≤ 50) is given. Each dataset consists of 2 lines:\n\n\nThe first integer\nThe second integer\n\n\nThe integer has at most 100 digits.\n\nOutput\n\nFor each dataset, print the sum of given integers in a line.\n\nSample Input\n\n6\n1000\n800\n9999999999999999999999999999999999999999\n1\n99999999999999999999999999999999999999999999999999999999999999999999999999999999\n1\n99999999999999999999999999999999999999999999999999999999999999999999999999999999\n0\n100000000000000000000000000000000000000000000000000000000000000000000000000000000\n1\n100000000000000000000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000000000000000000\n\nOutput for the Sample Input\n\n1800\n10000000000000000000000000000000000000000\noverflow\n99999999999999999999999999999999999999999999999999999999999999999999999999999999\noverflow\noverflow\n\n",
    "buggy": "for x in range(eval(input())):\n    a = eval(input()) + eval(input())\n    print(a if len(str(a)) < 80 else \"overflow\")",
    "fixed": "for x in range(eval(input())):\n    a = eval(input()) + eval(input())\n    print(a if len(str(a)) < 81 else \"overflow\")"
  },
  {
    "problem_id": "p00016",
    "problem_statement": "\nTreasure Hunt\n\nWhen a boy was cleaning up after his grand father passing, he found an old paper:\n\n\n\n\n\n\n\nIn addition, other side of the paper says that \"go ahead a number of steps equivalent to the first integer, and turn clockwise by degrees equivalent to the second integer\". \n\n\nHis grand mother says that Sanbonmatsu was standing at the center of town. However, now buildings are crammed side by side and people can not walk along exactly what the paper says in. Your task is to write a program which hunts for the treature on the paper.\n\n\nFor simplicity, 1 step is equivalent to 1 meter. Input consists of several pairs of two integers d (the first integer) and t (the second integer) separated by a comma. Input ends with \"0, 0\". Your program should print the coordinate (x, y) of the end point. There is the treature where x meters to the east and y meters to the north from the center of town.\n\n\nYou can assume that d ≤ 100 and -180 ≤ t ≤ 180.\n\nInput\n\nA sequence of pairs of integers d and t which end with \"0,0\".\n\nOutput\n\nPrint the integer portion of x and y in a line respectively.\n\nSample Input\n\n56,65\n97,54\n64,-4\n55,76\n42,-27\n43,80\n87,-86\n55,-6\n89,34\n95,5\n0,0\n\nOutput for the Sample Input\n\n171\n-302\n\n",
    "buggy": "import math\nnow_r=0\nnow_x=0\nnow_y=0\n\nwhile True:\n    n,r=list(map(int,input().split(\",\")))\n    if n==0 and r==0:\n        break\n    now_x+=n*math.sin((now_r/180.0)*math.pi)\n    now_y+=n*math.cos((now_r/180.0)*math.pi)\n    now_r+=r\n\nprint(math.floor(now_x))\nprint(math.floor(now_y))",
    "fixed": "import math\nnow_r=0\nnow_x=0\nnow_y=0\n\nwhile True:\n    n,r=list(map(int,input().split(\",\")))\n    if n==0 and r==0:\n        break\n    now_x+=n*math.sin((now_r/180.0)*math.pi)\n    now_y+=n*math.cos((now_r/180.0)*math.pi)\n    now_r+=r\nprint(int(now_x))\nprint(int(now_y))"
  },
  {
    "problem_id": "p00018",
    "problem_statement": "\nSorting Five Numbers\n\nWrite a program which reads five numbers and sorts them in descending order.\n\nInput\n\nInput consists of five numbers a, b, c, d and  e (-100000 ≤ a, b, c, d,e ≤ 100000). The five numbers are separeted by a space.\n\nOutput\n\nPrint the ordered numbers in a line. Adjacent numbers should be separated by a space.\n\nSample Input\n\n3 6 9 7 5\n\nOutput for the Sample Input\n\n9 7 6 5 3\n\n",
    "buggy": "n = list(map(int, input().split()))\nn.sort(revers=True)\nfor i in n:\n    print(i, end=' ')\n",
    "fixed": "n = list(map(int, input().split()))\nn.sort(reverse=True)\nfor i in n:\n    print(i, end=' ')\n"
  },
  {
    "problem_id": "p00019",
    "problem_statement": "\nFactorial\n\nWrite a program which reads an integer n and prints the factorial of n. You can assume that n ≤ 20.\n\nInput\n\nAn integer n (1 ≤ n ≤ 20) in a line.\n\nOutput\n\nPrint the factorial of n in a line.\n\nSample Input\n\n5\n\nOutput for the Sample Input\n\n120\n\n",
    "buggy": "tmp = 1\nn = int(input())\nfor i in range(1, n+1):\n    n*=i\nprint(n) \n",
    "fixed": "tmp = 1\nn = int(input())\nfor i in range(1, n+1):\n    tmp*=i\nprint(tmp)\n"
  },
  {
    "problem_id": "p00020",
    "problem_statement": "\nCapitalize\n\nWrite a program which replace all the lower-case letters of a given text with the corresponding captital letters. \n\nInput\n\nA text including lower-case letters, periods, and space is given in a line. The number of characters in the text is less than or equal to 200.\n\nOutput\n\nPrint the converted text.\n\nSample Input\n\nthis is a pen.\n\nOutput for the Sample Input\n\nTHIS IS A PEN.\n\n",
    "buggy": "#!/usr/bin/python\n\n\ndef datasets():\n    s = input().strip()\n    yield s\n    \ndef main():\n    for s in datasets():\n        print(s.lower())\n        \nif __name__ == '__main__':\n    main()",
    "fixed": "#!/usr/bin/python\n\n\ndef datasets():\n    s = input().strip()\n    yield s\n    \ndef main():\n    for s in datasets():\n        print(s.upper())\n        \nif __name__ == '__main__':\n    main()"
  },
  {
    "problem_id": "p00021",
    "problem_statement": "\n\n\nParallelism\n\nThere are four points: $A(x_1, y_1)$, $B(x_2, y_2)$, $C(x_3, y_3)$, and $D(x_4, y_4)$. Write a program which determines whether the line $AB$ and the line $CD$ are parallel. If those two lines are parallel, your program should prints \"YES\" and if not prints \"NO\". \n\nInput\n\nInput consists of several datasets. In the first line, you are given the number of datasets $n$ ($n \\leq 100$). There will be $n$ lines where each line correspondgs to each dataset. Each dataset consists of eight real numbers:\n\n$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $x_4$ $y_4$\n\n\nYou can assume that $-100 \\leq x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \\leq 100$.\nEach value is a real number with at most 5 digits after the decimal point.\n\nOutput\n\nFor each dataset, print \"YES\" or \"NO\" in a line.\n\nSample Input\n\n2\n0.0 0.0 1.0 1.0 1.0 0.0 2.0 1.0\n3.0 2.0 9.0 6.0 13.0 5.0 7.0 9.0\n\nOutput for the Sample Input\n\nYES\nNO\n\n",
    "buggy": "N = input()\n \nfor n in range(N):\n    data = map(float,input().split( ))\n    slopes = []\n    for i in range(2):\n        _x1 = data.pop(0)\n        _y1 = data.pop(0)\n        _x2 = data.pop(0)\n        _y2 = data.pop(0)\n         \n        if _x1 != _x2:\n            slopes.append((_y1 - _y2)/(_x1 - _x2))\n     \n    if len(slopes) == 0:\n        print(\"YES\")\n    elif len(slopes) == 1:\n        print(\"NO\")\n    elif abs(slopes[0] - slopes[1]) < 1e-10:\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "fixed": "N = eval(input())\n \nfor n in range(N):\n    data = list(map(float,input().split( )))\n    slopes = []\n    for i in range(2):\n        _x1 = data.pop(0)\n        _y1 = data.pop(0)\n        _x2 = data.pop(0)\n        _y2 = data.pop(0)\n         \n        if _x1 != _x2:\n            slopes.append((_y1 - _y2)/(_x1 - _x2))\n     \n    if len(slopes) == 0:\n        print(\"YES\")\n    elif len(slopes) == 1:\n        print(\"NO\")\n    elif abs(slopes[0] - slopes[1]) < 1e-10:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
  },
  {
    "problem_id": "p00022",
    "problem_statement": "\nMaximum Sum Sequence\n\nGiven a sequence of numbers a1, a2, a3, ..., an, find the maximum sum of a contiguous subsequence of those numbers. Note that, a subsequence of one element is also a contiquous subsequence.\n\nInput\n\nThe input consists of multiple datasets. Each data set consists of:\n\n\nn\na1\na2\n.\n.\nan\n\n\nYou can assume that 1 ≤ n ≤ 5000 and -100000 ≤ ai ≤ 100000.\n\n\nThe input end with a line consisting of a single 0.\n\nOutput\n\nFor each dataset, print the maximum sum in a line.\n\nSample Input\n\n7\n-5\n-1\n6\n4\n9\n-6\n-7\n13\n1\n2\n3\n2\n-2\n-1\n1\n2\n3\n2\n1\n-2\n1\n3\n1000\n-200\n201\n0\n\nOutput for the Sample Input\n\n19\n14\n1001\n\n",
    "buggy": "while True:\n    n = eval(input())\n    if n == 0:\n        exit()\n    A = [int(input()) for _ in range(n)]\n    if all(a<=0 for a in A):\n        print(max(a))\n        exit()\n    \n    r = 0\n    tmp = 0\n    ans = 0\n    while r < n:\n        tmp += A[r]\n        if tmp < 0:\n            l = r\n            tmp = 0\n        else:\n            ans = max(ans, tmp)\n        r += 1\n    print(ans)",
    "fixed": "while True:\n    n = eval(input())\n    if n == 0:\n        exit()\n    A = [int(input()) for _ in range(n)]\n    if all(a <= 0 for a in A):\n        print(max(A))\n        continue\n    \n    r = 0\n    tmp = 0\n    ans = 0\n    while r < n:\n        tmp += A[r]\n        if tmp < 0:\n            l = r\n            tmp = 0\n        else:\n            ans = max(ans, tmp)\n        r += 1\n    print(ans)"
  },
  {
    "problem_id": "p00023",
    "problem_statement": "\n\n\nCircles Intersection\n\nYou are given circle $A$ with radius $r_a$ and with central coordinate $(x_a, y_a)$ and circle $B$ with radius $r_b$ and with central coordinate $(x_b, y_b)$.\n\n\nWrite a program which prints:\n\n\n\"2\" if $B$ is in $A$,\n\"-2\" if $A$ is in $B$, \n\"1\" if circumference of $A$ and $B$ intersect, and\n\"0\" if $A$ and $B$ do not overlap.\n\n\nYou may assume that $A$ and $B$ are not identical.\n\nInput\n\nThe input consists of multiple datasets. The first line consists of an integer $N$ ($N \\leq 50$), the number of datasets. There will be $N$ lines where each line represents each dataset. Each data set consists of real numbers:\n\n$x_a$ $y_a$ $r_a$ $x_b$ $y_b$ $r_b$\n\nOutput\n\nFor each dataset, print 2, -2, 1, or 0 in a line.\n\nSample Input\n\n2\n0.0 0.0 5.0 0.0 0.0 4.0\n0.0 0.0 2.0 4.1 0.0 2.0\n\nOutput for the Sample Input\n\n2\n0\n\n",
    "buggy": "import math\nfor i in range(int(input())):\n    xa, ya, ra, xb, yb, rb = list(map(float, input().split()))\n\n    d1 = (xa - xb) ** 2 + (ya - yb) ** 2\n    d2 = ra ** 2 + rb ** 2\n    dr = (ra-rb) ** 2\n\n    if d1 <= d2:\n        if dr >= d1:\n            print(2 if ra > rb else -2)\n        else:\n            print(1)\n    else:\n        print(0)",
    "fixed": "import math\nfor i in range(int(input())):\n    xa, ya, ra, xb, yb, rb = list(map(float, input().split()))\n\n    d1 = (xa - xb) ** 2 + (ya - yb) ** 2\n    d2 = (ra + rb) ** 2\n    dr = (ra-rb) ** 2\n\n    if d1 <= d2:\n        if dr > d1:\n            print(2 if ra > rb else -2)\n        else:\n            print(1)\n    else:\n        print(0)"
  },
  {
    "problem_id": "p00024",
    "problem_statement": "\n\n\nPhysical Experiments\n\nIgnoring the air resistance, velocity of a freely falling object $v$ after $t$ seconds and its drop $y$ in $t$ seconds are represented by the following formulas:\n\n$ v = 9.8 t $\n$ y = 4.9 t^2 $\n\n\n\nA person is trying to drop down a glass ball and check whether it will crack. Your task is to write a program to help this experiment.\n\n\nYou are given the  minimum velocity to crack the ball. Your program should print the lowest possible floor of a building to crack the ball. The height of the $N$ floor of the building is defined by $5 \\times N - 5$.\n\nInput\n\nThe input consists of multiple datasets. Each dataset, a line, consists of the minimum velocity v (0 < v < 200) to crack the ball. The value is given by a decimal fraction, with at most 4 digits after the decimal point. The input ends with EOF. The number of datasets is less than or equal to 50.\n\nOutput\n\nFor each dataset, print the lowest possible floor where the ball cracks.\n\nSample Input\n\n25.4\n25.4\n\nOutput for the Sample Input\n\n8\n8\n\n",
    "buggy": "import sys,math\nfor l in sys.stdin:print(int(math.ceil(float(l)**2*0.01)+1))",
    "fixed": "import sys,math\nfor l in sys.stdin:print(int(math.ceil(float(l)**2*0.01020408163265306122448979591837)+1))"
  },
  {
    "problem_id": "p00025",
    "problem_statement": "\nHit and Blow\n\nLet's play Hit and Blow game. A imagines four numbers and B guesses the numbers. After B picks out four numbers, A answers:\n\n\n The number of numbers which have the same place with numbers A imagined (Hit) \n The number of numbers included (but different place) in the numbers A imagined (Blow)\n\n\nFor example, if A imagined numbers:\n\n\n9 1 8 2\n\n\nand B chose:\n\n\n4 1 5 9\n\n\nA should say 1 Hit and 1 Blow.\n\n\nWrite a program which reads four numbers A imagined and four numbers B chose and prints the number of Hit and Blow respectively. You may assume that the four numbers are all different and within from 0 to 9.\n\nInput\n\nThe input consists of multiple datasets. Each dataset set consists of:\n\n\na1 a2 a3 a4\nb1 b2 b3 b4\n\n\n, where ai (0 ≤ ai ≤ 9) is i-th number A  imagined and bi (0 ≤ bi ≤ 9) is i-th number B chose.\n\n\nThe input ends with EOF. The number of datasets is less than or equal to 50.\n\nOutput\n\nFor each dataset, print the number of Hit and Blow in a line. These two numbers should be separated by a space.\n\nSample Input\n\n9 1 8 2\n4 1 5 9\n4 6 8 2\n4 6 3 2\n\nOutput for the Sample Input\n\n1 1\n3 0\n\n",
    "buggy": "# -*- coding: utf-8 -*-\n\nwhile True:\n    try:\n        A, B = input().split(), input().split()\n        hit = sum([ 1 for i in range(len(A)) if A[i]==B[i] ])\n        blow = sum([ 1 for i in range(len(A)) if B[i] in A ])\n        print(str(hit) + ' ' +str(blow))\n    except:\n        break\n",
    "fixed": "# -*- coding: utf-8 -*-\n\nwhile True:\n    try:\n        A, B = input().split(), input().split()\n        hit = sum([ 1 for i in range(len(A)) if A[i]==B[i] ])\n        blow = sum([ 1 for i in range(len(A)) if B[i] in A ]) - hit\n        print(str(hit) + ' ' +str(blow))\n    except:\n        break\n"
  },
  {
    "problem_id": "p00026",
    "problem_statement": "\nDropping Ink\n\nAs shown in the following figure, there is a paper consisting of a grid structure where each cell is indicated by (x, y) coordinate system.\n\n\nWe are going to put drops of ink on the paper. A drop comes in three different sizes: Large, Medium, and Small. From the point of fall, the ink sinks into surrounding cells as shown in the figure depending on its size. In the figure, a star denotes the point of fall and a circle denotes the surrounding cells.\n\n\n\n\nOriginally, the paper is white that means for each cell the value of density is 0. The value of density is increased by 1 when the ink sinks into the corresponding cells.\n\nFor example, if we put a drop of Small ink at (1, 2) and a drop of Medium ink at (3, 2), the ink will sink as shown in the following figure (left side):\n\n\n\n\nIn the figure, density values of empty cells are 0. The ink sinking into out of the paper should be ignored as shown in the figure (top side). We can put several drops of ink at the same point.\n\n\nYour task is to write a program which reads a sequence of points of fall (x, y) with its size (Small = 1, Medium = 2, Large = 3), and prints the number of cells whose density value is 0. The program must also print the maximum value of density.\n\n\nYou may assume that the paper always consists of 10 × 10, and 0 ≤ x < 10, 0 ≤ y < 10.\n\nInput\n\nx1,y1,s1\nx2,y2,s2\n  :\n  :\n\n\n(xi, yi) represents the position of the i-th drop and si denotes its size. The number of drops is less than or equal to 50.\n\nOutput\n\nPrint the number of cells whose density value is 0 in first line.\nPrint the maximum value of density in the second line.\n\nSample Input\n\n2,5,3\n3,6,1\n3,4,2\n4,5,2\n3,6,3\n2,4,1\n\nOutput for the Sample Input\n\n77\n5\n\n",
    "buggy": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef small_inc(x, y, cells):\n    cells[x][y] += 1\n    if y > 0:\n        cells[x][y-1] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y+1] += 1\n\ndef medium_inc(x, y, cells):\n    if y > 0:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y-1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y-1] += 1\n    cells[x][y] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y+1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y+1] += 1\n\ndef large_inc(x, y, cells):\n    if y > 1:\n        cells[x][y-2] += 1\n    if y > 0:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y-1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y-1] += 1\n    cells[x][y] += 1\n    if x > 1:\n        cells[x-2][y] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if x < MAPSIZE-2:\n        cells[x+2][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y+1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y+1] += 1\n    if y < MAPSIZE-2:\n        cells[x][y+2] += 1\n\nSMALL = 1\nMEDIUM = 2\nLARGE = 3\nMAPSIZE = 10\n\ncells = [[0 for i in range(MAPSIZE)] for j in range(MAPSIZE)]\nfor line in sys.stdin:\n    x , y, size = list(map(int, line.split(',')))\n    if size == SMALL:\n        small_inc(x, y, cells)\n    elif size == MEDIUM:\n        medium_inc(x, y, cells)\n    elif size == LARGE:\n        large_inc(x, y, cells)\ncount = max_d = 0\nfor i in range(MAPSIZE):\n    for j in range(MAPSIZE):\n        if cells[i][j] == 0:\n            count += 1\n        else:\n            max_d = max(max_d, cells[i][j])\nprint(count)\nprint(max_d)",
    "fixed": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef small_inc(x, y, cells):\n    cells[x][y] += 1\n    if y > 0:\n        cells[x][y-1] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y+1] += 1\n\ndef medium_inc(x, y, cells):\n    if y > 0:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y-1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y-1] += 1\n    cells[x][y] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y+1] += 1\n        if x > 0:\n            cells[x-1][y+1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y+1] += 1\n\ndef large_inc(x, y, cells):\n    if y > 1:\n        cells[x][y-2] += 1\n    if y > 0:\n        cells[x][y-1] += 1\n        if x > 0:\n            cells[x-1][y-1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y-1] += 1\n    cells[x][y] += 1\n    if x > 1:\n        cells[x-2][y] += 1\n    if x > 0:\n        cells[x-1][y] += 1\n    if x < MAPSIZE-1:\n        cells[x+1][y] += 1\n    if x < MAPSIZE-2:\n        cells[x+2][y] += 1\n    if y < MAPSIZE-1:\n        cells[x][y+1] += 1\n        if x > 0:\n            cells[x-1][y+1] += 1\n        if x < MAPSIZE-1:\n            cells[x+1][y+1] += 1\n    if y < MAPSIZE-2:\n        cells[x][y+2] += 1\n\nSMALL = 1\nMEDIUM = 2\nLARGE = 3\nMAPSIZE = 10\n\ncells = [[0 for i in range(MAPSIZE)] for j in range(MAPSIZE)]\nfor line in sys.stdin:\n    x , y, size = list(map(int, line.split(',')))\n    if size == SMALL:\n        small_inc(x, y, cells)\n    elif size == MEDIUM:\n        medium_inc(x, y, cells)\n    elif size == LARGE:\n        large_inc(x, y, cells)\ncount = max_d = 0\nfor i in range(MAPSIZE):\n    for j in range(MAPSIZE):\n        if cells[i][j] == 0:\n            count += 1\n        else:\n            max_d = max(max_d, cells[i][j])\nprint(count)\nprint(max_d)"
  },
  {
    "problem_id": "p00027",
    "problem_statement": "\nWhat day is today?\n\nYour task is to write a program which reads a date (from 2004/1/1 to 2004/12/31) and prints the day of the date. Jan. 1, 2004, is Thursday. Note that 2004 is a leap year and we have Feb. 29.\n\nInput\n\nThe input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset consists of two integers m and d separated by a single space in a line. These integers respectively represent the month and the day. \n\n\nThe number of datasets is less than or equal to 50.\n\nOutput\n\nFor each dataset, print the day (please see the following words) in a line.\n\n\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\nSunday\n\nSample Input\n\n1 1\n2 29\n0 0\n\nOutput for the Sample Input\n\nThursday\nSunday\n\n",
    "buggy": "days=['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']\ndom=[31,29,31,30,31,60,31,31,30,31,30,31]\nwhile True:\n    try:\n        try:\n            (m,d)=list(map(int,input().split()))\n        except: break\n        if m==0 and d==0: break\n        day=4-1\n        for i in range(m-1):\n            day+=dom[i]\n        day+=d\n        print(days[day%7])\n    except EOFError: break",
    "fixed": "days=['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']\ndom=[31,29,31,30,31,30,31,31,30,31,30,31]\nwhile True:\n    try:\n        try:\n            (m,d)=list(map(int,input().split()))\n        except: break\n        if m==0 and d==0: break\n        day=4-1\n        for i in range(m-1):\n            day+=dom[i]\n        day+=d\n        print(days[day%7])\n    except EOFError: break"
  },
  {
    "problem_id": "p00028",
    "problem_statement": "\nMode Value\n\nYour task is to write a program which reads a sequence of integers and prints mode values of the sequence.\nThe mode value is the element which occurs most frequently. \n\nInput\n\nA sequence of integers ai (1 ≤ ai ≤ 100). The number of integers is less than or equals to 100.\n\n\nOutput\n\nPrint the mode values. If there are several mode values, print them in ascending order.\n\nSample Input\n\n5\n6\n3\n5\n8\n7\n5\n3\n9\n7\n3\n4\n\nOutput for the Sample Input\n\n3\n5\n\n\nFor example, 3 and 5 respectively occur three times, 7 occurs two times, and others occur only one. So, the mode values are 3 and 5.\n\n",
    "buggy": "\nhist = [0 for i in range(100)]\n\nl = []\nwhile True:\n  try:\n    hist[eval(input()) - 1] += 1\n  except:\n    break;\n\nfor k in [x for x in enumlate(hist) if max(hist) == x[1]]:\n  print(k[0] + 1)",
    "fixed": "\nhist = [0 for i in range(100)]\n\nl = []\nwhile True:\n  try:\n    hist[eval(input()) - 1] += 1\n  except:\n    break;\n\nfor k in [x for x in enumerate(hist) if max(hist) == x[1]]:\n  print(k[0] + 1)"
  },
  {
    "problem_id": "p00030",
    "problem_statement": "Sum of integers\n\nThe program to be created outputs the number of combinations of n different numbers from 0 to 9 whose sum is s. Each set of n numbers is specified in the range of 0 to 9, and the same number cannot be used in one combination. For example, if n is 3 and s is 6, there are three combinations of three numbers:\n\n1 + 2 + 3 = 6\n0 + 1 + 5 = 6\n0 + 2 + 4 = 6\n\nInput\n\nMultiple datasets are given. Each dataset consists of two integers n (1 ≤ n ≤ 9) and s (0 ≤ s ≤ 100), separated by a single space. The end of the input is indicated by a line of two zeros (0 0) that is not processed.\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the number of combinations of n integers whose sum is s.\n\nSample Input\n\n3 6\n3 1\n0 0\n\nSample Output\n\n3\n0\n",
    "buggy": "import sys\nfrom itertools import combinations as c\nfor line in sys.stdin:\n    count = 0\n    k, v = map(int, line.split())\n    if k and v:\n        for i in c(range(10), k):\n            if sum(i) == v:\n                count += 1\n    else:\n        break\n    print(count)",
    "fixed": "import sys\nfrom itertools import combinations as c\nfor line in sys.stdin:\n    count = 0\n    k, v = map(int, line.split())\n    if k or v:\n        for i in c(range(10), k):\n            if sum(i) == v:\n                count += 1\n    else:\n        break\n    print(count)"
  },
  {
    "problem_id": "p00033",
    "problem_statement": "Ball\n\n\n\n\n\nThere is a container that is divided into two branches as shown in the figure. Ten balls numbered 1 to 10 are dropped from the opening A of the container, and placed in the left tube B or the right tube C. Since the plate D can rotate left and right around the fulcrum E, you can decide whether to put it in tube B or tube C by moving plate D.\n\n\nThe order of the balls dropped from the opening A is given. Place them in tube B or tube C in order. If both tube B and tube C can arrange the balls with the smaller numbered balls on top of the larger numbered balls, output YES. If they cannot be arranged in this way, output NO. It is assumed that the order of the balls cannot be changed within the container. Also, it is assumed that the same tube can be used continuously, and that both tube B and tube C have enough space to hold all 10 balls.\n\nInput\n\nThe input consists of multiple datasets. The first line contains an integer N, the number of datasets. Each dataset contains ten numbers separated by a space, given on the following lines.\n\nOutput\n\nFor each dataset, output YES or NO in one line.\n\nSample Input\n\n2\n3 1 4 2 5 6 7 8 9 10\n10 9 8 7 6 5 4 3 2 1\n\nOutput for the Sample Input\n\nYES\nNO\n",
    "buggy": "n=int(input())\nfor i in range(n):\n    a=list(map(int,input().aplit()))\n    b,c=0,0\n    yes = True\n    for j in range(10):\n        if a[j]>b:b=a[j]\n        elif a[j]>c:c=a[j]\n        else:yes=False\n    print(\"YES\" if yes else \"NO\")\n",
    "fixed": "n=int(input())\nfor i in range(n):\n    a=list(map(int,input().split()))\n    b,c=0,0\n    yes = True\n    for j in range(10):\n        if a[j]>b:b=a[j]\n        elif a[j]>c:c=a[j]\n        else:yes=False\n    print(\"YES\" if yes else \"NO\")\n"
  },
  {
    "problem_id": "p00034",
    "problem_statement": "Railway Lines\nThere is a double-track (where up and down trains can pass each other anywhere because they have separate tracks) railway line. The line has 11 stations, including the terminal stations, and the sections between each station are called by section numbers shown in the figure.\n\n\n\n\nTrains depart simultaneously from both terminal stations and run without stopping. Write a program that reads the length of each section and the speeds of the two trains and outputs the section number where the trains pass each other for each case. If they pass each other exactly at the station, output the smaller of the two section numbers on either side. You can ignore the lengths of the trains and the stations.\nInput\nMultiple datasets are given in the following format.\n\nl1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2\n\nli (1 ≤ li ≤ 2,000) is an integer representing the length (in km) of section i. v1 is an integer (1 ≤ v1, v2 ≤ 2,000) representing the speed (in km/h) of the train departing from the terminal station on the side of section 1, and v2 is an integer representing the speed (in km/h) of the train departing from the terminal station on the side of section 10.\nThe number of datasets does not exceed 50.\nOutput\nFor each dataset, output the section number where the trains pass each other in one line.\nSample Input\n\n1,1,1,1,1,1,1,1,1,1,40,60\n1,1,1,1,1,3,3,3,3,3,50,50\n10,10,10,10,10,10,10,10,10,10,50,49\n\nOutput for the Sample Input\n\n4\n7\n6\n",
    "buggy": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,0:\n            if ans>0:\n                ans -=j\n                flag +=1\n                print(ans)\n            else:\n                print(flag)\n                break\n    except:break\n",
    "fixed": "while True:\n    try:\n        l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,v1,v2=map(int,input().split(\",\"))\n        kyo=0\n        for i in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10:\n            kyo +=i\n        v=v1+v2\n        x=kyo/v\n        ans=v1*x\n        flag=0\n        for j in l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,0:\n            if ans>0:\n                ans -=j\n                flag +=1\n            else:\n                print(flag)\n                break\n    except:break\n"
  },
  {
    "problem_id": "p00035",
    "problem_statement": "Convex?\n\nCreate a program that reads the coordinates of four distinct points $A (x_a, y_a)$, $B (x_b, y_b)$, $C (x_c, y_c)$, $D(x_d, y_d)$ on a plane, and outputs YES if the quadrilateral $ABCD$ formed by these four points is convex, and NO otherwise.\n\n\nA convex quadrilateral is defined as shown in Figure 1.\n\n\n\n\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of eight real numbers $x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$, separated by commas.\n\n\nThe coordinates $x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$, $x_d$, $y_d$ satisfy $-100 \\le x_i, y_i \\le 100$ for $i = a,b,c,d$.\n\n\nNo three points are collinear, and the input order of the points is such that connecting them in sequence forms a quadrilateral.\n\n\nThe number of datasets is at most 100.\n\nOutput\n\nFor each dataset, output YES or NO in a line.\n\nSample Input\n\n0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0\n0.0,0.0,3.0,0.0,1.0,1.0,1.0,3.0\n\nOutput for the Sample Input\n\nYES\nNO\n",
    "buggy": "def sol(a1,b1,a2,b2,a3,b3):\n    return (a3-a2)*b1-(b3-b2)*a1+a2*b3-a3*b2\nwhile True:\n    try:\n        x1,y1,x2,y2,x3,y3,x4,y4=list(map(float,input().split()))\n        if sol(x1,y1,x2,y2,x4,y4)*sol(x3,y3,x2,y2,x4,y4)<0 and sol(x4,y4,x1,y1,x3,y3)*sol(x2,y2,x1,y1,x3,y3)<0:\n            print('YES')\n        else:\n            print('NO')\n\n    except:\n        break",
    "fixed": "def sol(a1,b1,a2,b2,a3,b3):\n    return (a3-a2)*b1-(b3-b2)*a1+a2*b3-a3*b2\nwhile True:\n    try:\n        x1,y1,x2,y2,x3,y3,x4,y4=list(map(float,input().split(',')))\n        if sol(x1,y1,x2,y2,x4,y4)*sol(x3,y3,x2,y2,x4,y4)<0 and sol(x4,y4,x1,y1,x3,y3)*sol(x2,y2,x1,y1,x3,y3)<0:\n            print('YES')\n        else:\n            print('NO')\n\n    except:\n        break"
  },
  {
    "problem_id": "p00036",
    "problem_statement": "2D Shapes on a Plane\n\nThere is a plane as shown in Figure 1 with 8 vertical squares and 8 horizontal squares.\n\n\n\nFigure 1\n\n\n\nOn this plane, only one of the shapes A to G shown below is placed.\n\n\n\n\n\nFor example, in Figure 2 below, shape E is placed.\n\n\n\nFigure 2\n\n\n\nCreate a program that reads a combination of numbers expressed with 1 for a square that contains a part of the shape and with 0 for a blank space in the plane, and outputs the type of the shape contained in it (A to G).\n\nNote that there will only ever be one shape on a plane, so there is no possibility of multiple shapes being present at one time. Additionally, the program should not identify a shape other than the specified A to G patterns.\n\nInput\n\nInput consists of multiple dataset.\n\n\nFor each dataset, 8 strings are given, each with 8 numbers, where the shape occupies the squares represented by 1, and blank squares are represented by 0. For example, the arrangement of strings corresponding to Figure 2 would be as follows:\n\n\n\n\n\n\nDatasets are separated by a single empty line. There will be no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the type of the given shape on the plane (one of A to G) on a single line.\n\nSample Input\n\n00000000\n00000000\n01100000\n00110000\n00000000\n00000000\n00000000\n00000000\n\n00011110\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n\n00000000\n00000000\n00110000\n00110000\n00000000\n00000000\n00000000\n00000000\n\nOutput for the Sample Input\n\nE\nC\nA\n",
    "buggy": "#encoding=utf-8\nimport sys\n\ndef inp():\n    fe, fe1 = [], []\n    for line in sys.stdin:\n        fe += line.split()\n        \n    i,j = 0,8\n    while True:\n        fe1 = fe[i:j]\n        if a(fe1):\n            if b(fe1):\n                if c(fe1):\n                    if d(fe1):\n                        if e(fe1):\n                            if f(fe1):\n                                if g(fe1):\n                                    pass\n\n        i, j =i + 8,j + 8\n        if j > len(fe): break\n\ndef a(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j]==fe1[i+1][j+1]==\"1\":\n                        print(\"A\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef b(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j]==fe1[i+2][j]==fe1[i+3][j]==\"1\":\n                        print(\"B\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef c(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i][j+2]==fe1[i][j+3]==\"1\":\n                        print(\"C\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef d(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j-1]==fe1[i+1][j]==fe1[i+2][j-1]==\"1\":\n                        print(\"D\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef e(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j+1]==fe1[i+1][j+2]==\"1\":\n                        print(\"E\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef f(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j]==fe1[i+1][j+1]==fe1[i+2][j+1]==\"1\":\n                        print(\"F\")\n                        return False\n                except:\n                    pass\n    True\n\ndef g(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j-1]==fe1[i+1][j]==\"1\":\n                        print(\"G\")\n                        return False\n                except:\n                    pass\n    return True\n\nif __name__ == \"__main__\":\n    inp()",
    "fixed": "#encoding=utf-8\nimport sys\n\ndef inp():\n    fe, fe1 = [], []\n    for line in sys.stdin:\n        fe += line.split()\n        \n    i,j = 0,8\n    while True:\n        fe1 = fe[i:j]\n        if a(fe1):\n            if b(fe1):\n                if c(fe1):\n                    if d(fe1):\n                        if e(fe1):\n                            if f(fe1):\n                                if g(fe1):\n                                    pass\n\n        i, j =i + 8,j + 8\n        if j > len(fe): break\n\ndef a(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j]==fe1[i+1][j+1]==\"1\":\n                        print(\"A\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef b(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j]==fe1[i+2][j]==fe1[i+3][j]==\"1\":\n                        print(\"B\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef c(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i][j+2]==fe1[i][j+3]==\"1\":\n                        print(\"C\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef d(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j-1]==fe1[i+1][j]==fe1[i+2][j-1]==\"1\":\n                        print(\"D\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef e(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j+1]==fe1[i+1][j+2]==\"1\":\n                        print(\"E\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef f(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i+1][j]==fe1[i+1][j+1]==fe1[i+2][j+1]==\"1\":\n                        print(\"F\")\n                        return False\n                except:\n                    pass\n    return True\n\ndef g(fe1):\n    for i in range(8):\n        for j in range(8):\n            if fe1[i][j] == \"1\":\n                try:\n                    if fe1[i][j+1]==fe1[i+1][j-1]==fe1[i+1][j]==\"1\":\n                        print(\"G\")\n                        return False\n                except:\n                    pass\n    return True\n\nif __name__ == \"__main__\":\n    inp()"
  },
  {
    "problem_id": "p00038",
    "problem_statement": "Poker\n\nCreate a program that reads poker hand data and outputs their ranking. However, this problem follows the following rules:\n\n\nPoker is a game played with 5 cards of a deck of cards.\nThere are no more than 5 cards with the same number.\nJokers are not included.\nOnly the following poker hands will be considered (the higher the number, the higher the ranking):\n\n\nNull hand (not applicable to any of the following)\nOne pair (two cards with the same number)\nTwo pair (two sets of two cards with the same number)\nThree of a kind (three cards with the same number)\nStraight (five cards with consecutive numbers)\nHowever, in the case of a straight that includes an A, the sequence that ends with an A is also considered a straight. In other words, there are two types of straight that include an A: A 2 3 4 5 and 10 J Q K A. Sequences that cross over an A, such as J Q K A 2, are not considered straight (in this case, it is a null hand).\n\nFull house (one set of three cards with the same number and another set of two cards with the same number)\nFour of a kind (four cards with the same number)\n\nInput\n\nThe input consists of multiple data sets. Each data set is given in the following format:\n\n\ncard1,card2,card3,card4,card5\n\n\nCards are expressed by the number of the card, except for J (jack), Q (queen), K (king), and A (ace), which are represented by 11, 12, 13, and 1, respectively.\n\n\nThere are no more than 50 data sets.\n\nOutput\n\nFor each data set, output the highest-ranking hand that can be made with the cards. Follow the output example for the notation of each hand.\n\nSample Input\n\n1,2,3,4,1\n2,3,2,3,12\n12,13,11,12,12\n7,6,7,6,7\n3,3,2,3,3\n6,7,8,9,10\n11,12,10,1,13\n11,12,13,1,2\n\nOutput for the Sample Input\n\none pair\ntwo pair\nthree card\nfull house\nfour card\nstraight\nstraight\nnull\n\n\nWhen the hand is 3 3 2 3 3, it is a four card hand, not a two pair hand.\n",
    "buggy": "#encoding=utf-8\n\nimport sys\n\ndef inp():\n    word = []\n    for line in sys.stdin:\n        word = list(map(int, line.split(\",\")))\n        syori(sorted(word))\n\ndef syori(word):\n    flag = [0,0]\n    if sum(word[1:5]) == 46:\n        word.append(int(word[0]))\n        del word[0]\n\n    if word == [10,11,12,13,1]:\n        print(\"straight\")\n        \n    else:\n        for j in range(1,14):\n            if word.count(j) == 2:\n                flag[0] += 1\n            elif word.count(j) == 3:\n                flag[1] += 1\n            elif word.count(j) == 4:\n                print(\"four card\")\n                flag = [10,10]\n                break\n            elif word[0] + 2 == word[1] + 1 == word[2] == word[3] - 1 == word[4] - 2:\n                print(\"straight\")\n                flag = [10,10]\n                break\n\n        if flag[0] == flag[1] == 1:\n            print(\"full house\")\n        elif flag[0] == 1:\n            print(\"one pair\")\n        elif flag[0] == 2:\n            print(\"two pair\")\n        elif flag[1] == 1:\n            print(\"three pair\")\n        elif flag[0] < 1 or flag[1] < 1:\n            print(\"null\")\n\nif __name__ == \"__main__\":\n    inp()\n   ",
    "fixed": "import sys\n\ndef inp():\n    word = []\n    for line in sys.stdin:\n        word = list(map(int, line.split(\",\")))\n        syori(sorted(word))\n\ndef syori(word):\n    flag = [0,0]\n    if sum(word[1:5]) == 46:\n        word.append(int(word[0]))\n        del word[0]\n\n    if word == [10,11,12,13,1]:\n        print(\"straight\")\n        \n    else:\n        for j in range(1,14):\n            if word.count(j) == 2:\n                flag[0] += 1\n            elif word.count(j) == 3:\n                flag[1] += 1\n            elif word.count(j) == 4:\n                print(\"four card\")\n                flag = [10,10]\n                break\n            elif word[0] + 2 == word[1] + 1 == word[2] == word[3] - 1 == word[4] - 2:\n                print(\"straight\")\n                flag = [10,10]\n                break\n\n        if flag[0] == flag[1] == 1:\n            print(\"full house\")\n        elif flag[0] == 1:\n            print(\"one pair\")\n        elif flag[0] == 2:\n            print(\"two pair\")\n        elif flag[1] == 1:\n            print(\"three card\")\n        elif flag[0] < 1 or flag[1] < 1:\n            print(\"null\")\n\nif __name__ == \"__main__\":\n    inp()\n   "
  },
  {
    "problem_id": "p00039",
    "problem_statement": "Roman Numerals\n\nCounting numbers in ancient Rome was a difficult task. Arabic numerals 0,1,2,3,…, 9 had not yet become widespread. Instead, symbols such as the following were used.\n\n\n\n\nArabic NumeralsRoman NumeralsArabic NumeralsRoman NumeralsArabic NumeralsRoman Numerals\n\n1I11XI30XXX\n2II12XII40XL\n3III13XIII50L\n4IV14XIV60LX\n5V15XV70LXX\n6VI16XVI80LXXX\n7VII17XVII90XC\n8VIII18XVIII100C\n9IX19XIX500D\n10X20XX1000M\n\n\n\n\nI is 1, V is 5, X is 10, L is 50, C is 100, D is 500, and M is 1000. Please refer to the above table for other examples. When a smaller number follows a larger number, that is, when it is on the right side, add it. When a smaller number is in front of a larger number, that is, to the left, subtract the smaller number from the larger number. The small number in front of the large number indicating subtraction is only used once per subtraction.\n\n\nCreate a program that converts Roman numerals to Arabic numerals (ordinary numerals). However, the Roman numerals given follow only the above rules (although there are more detailed rules in actual Roman numerals, they do not need to be considered here. For example, in actual Roman numerals, I is subtracted only from V or X, X is subtracted only from L or C, and C is subtracted only from D or M, and the same Roman numerals are not added in four or more (or five or more) in a row.)\n\nInput\n\nMultiple data sets are provided. For each dataset, a Roman numeral (a continuous string of uppercase letters I, V, X, L, C, D, M) is given on one line. The length of the given Roman numeral string is no more than 100 each.\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the Arabic numeral (integer) on one line.\n\nSample Input\n\nIV\nCCCCLXXXXVIIII\nCDXCIX\n\nOutput for the Sample Input\n\n4\n499\n499\n",
    "buggy": "import sys\n\ndef dec_num(x):\n    for i in range(len(x)):\n        if x[i] == 2:\n            x[i] = 5\n        elif x[i] == 3:\n            x[i] = 10\n        elif x[i] == 4:\n            x[i] = 50\n        elif x[i] == 5:\n            x[i] = 100\n        elif x[i] == 6:\n            x[i] = 500\n        elif x[i] == 7:\n            x[i] = 1000\n\ndef to_index(x):\n    if x == 1:\n        return 1\n    elif x == 5:\n        return 2\n    elif x == 10:\n        return 3\n    elif x == 50:\n        return 4\n    elif x == 100:\n        return 5\n    elif x == 500:\n        return 6\n    elif x == 1000:\n        return 7\n\n\ndef toNum(x):\n    result = 0\n    tmp = x[0]\n    for i in range(len(x)):\n        if tmp < x[i]:\n            result += x[i]-tmp\n        elif i <= len(x) and x[i] < x[i+1]:\n            result += 0\n        else:\n            result += x[i]\n        tmp = x[i] \n\n    return result\n\nfor line in sys.stdin.readlines():\n    line = line.translate(str.maketrans('IVXLCDM', '1234567'))\n    num = list(map(int, (' '.join(line)).split()))\n    dec_num(num)\n    print(toNum(num))",
    "fixed": "import sys\n\ndef dec_num(x):\n    for i in range(len(x)):\n        if x[i] == 2:\n            x[i] = 5\n        elif x[i] == 3:\n            x[i] = 10\n        elif x[i] == 4:\n            x[i] = 50\n        elif x[i] == 5:\n            x[i] = 100\n        elif x[i] == 6:\n            x[i] = 500\n        elif x[i] == 7:\n            x[i] = 1000\n\ndef to_index(x):\n    if x == 1:\n        return 1\n    elif x == 5:\n        return 2\n    elif x == 10:\n        return 3\n    elif x == 50:\n        return 4\n    elif x == 100:\n        return 5\n    elif x == 500:\n        return 6\n    elif x == 1000:\n        return 7\n\n\ndef toNum(x):\n    result = 0\n    tmp = x[0]\n    for i in range(len(x)):\n        if tmp < x[i]:\n            result += x[i]-tmp\n        elif i < len(x)-1 and x[i] < x[i+1]:\n            result += 0\n        else:\n            result += x[i]\n        tmp = x[i] \n\n    return result\n\nfor line in sys.stdin.readlines():\n    line = line.translate(str.maketrans('IVXLCDM', '1234567'))\n    num = list(map(int, (' '.join(line)).split()))\n    dec_num(num)\n    print(toNum(num))"
  },
  {
    "problem_id": "p00042",
    "problem_statement": "Thief\nA thief broke into a museum where many treasures are stored. He was carrying a large cloth and nothing else. The thief planned to steal many things, but the crucial point is that the fabric that he’s carrying has a limit to its weight. If there's weight exceeding its capacity, the fabric will tear apart and break. Therefore, the thief needed to consider the combination of treasures with the highest value without breaking the fabric.\nA program should be written considering the equipment level and price to maximize the commodity value by this script.\nPlease write a program that reads the value and weight of each treasure of the museum and the load capacity W of the fabric from the first line.\nAn integer representing the load capacity of the fabric, W ( ≤ 1,000), is written in the first line. The second line contains an integer N (1 ≤ N ≤ 1,000), indicating the number of treasures. In each of the following N lines, the value vi of the i-th treasure (0 ≤ vi ≤ 10,000) is written. The weight wi (0 ≤ wi ≤ W) of the i-th treasure is also given on the same line.( ,  indicate that vi and wi are separated by a comma.) \nWhen W is zero, input ends. There are no more than 50 datasets. \nFor each dataset, output in the following format:\n\nX  Pull Down: \n   \n\n    The country with the highest concentration of neodeyration of showa element in the world\n\n\n\nCase Dataset: \nTotal value of the treasures\nTotal weight of the treasures contained in the fabric\n\nSample input\n\n50\n5\n60,10\n100,20\n120,30\n210,45\n10,4\n50\n5\n60,10\n100,20\n120,30\n210,45\n10,4\n0\n\nSample Output\n\nCase 1:\n220\n49\nCase 2:\n220\n49\n",
    "buggy": "while True:\n    cnt = 0\n    cnt += 1\n    maxweight = int(input())\n    if maxweight == 0:\n        break\n    length = int(input())\n    tresure = []\n    dp = [[0 for n in range(length+1)] for m in range(maxweight + 1)]\n    answeight = 0\n    ansvalue = 0\n    for l in range(length):\n        v,w = (int(n) for n in input().split(\",\"))\n        tresure.append([v,w])\n    for outer in range(length + 1):\n        if outer == 0:\n            continue\n        weight = tresure[outer-1][1]\n        value = tresure[outer-1][0]\n        dp[weight][outer] = max(dp[weight][outer],value)\n        for inner in range(maxweight + 1):\n            if dp[inner][outer - 1] != 0:\n                beforevalue = dp[inner][outer - 1]\n                beforeweight = inner\n                dp[inner][outer]  = max(beforevalue,dp[inner][outer])\n                if beforeweight + weight <= maxweight:\n                    nowvalue = dp[beforeweight + weight][outer]\n                    dp[beforeweight + weight][outer] = max(nowvalue,beforevalue+value)\n    #print(dp)\n    for a in range(maxweight+1):\n        #print(dp[a][length])\n        if ansvalue < dp[a][length]:\n            ansvalue = dp[a][length]\n            answeight = a\n    print(\"Case {0}:\".format(cnt))\n    print(ansvalue)\n    print(answeight)",
    "fixed": "cnt = 0\nwhile True:\n    cnt += 1\n    maxweight = int(input())\n    if maxweight == 0:\n        break\n    length = int(input())\n    tresure = []\n    dp = [[0 for n in range(length+1)] for m in range(maxweight + 1)]\n    answeight = 0\n    ansvalue = 0\n    for l in range(length):\n        v,w = (int(n) for n in input().split(\",\"))\n        tresure.append([v,w])\n    for outer in range(length + 1):\n        if outer == 0:\n            continue\n        weight = tresure[outer-1][1]\n        value = tresure[outer-1][0]\n        dp[weight][outer] = max(dp[weight][outer],value)\n        for inner in range(maxweight + 1):\n            if dp[inner][outer - 1] != 0:\n                beforevalue = dp[inner][outer - 1]\n                beforeweight = inner\n                dp[inner][outer]  = max(beforevalue,dp[inner][outer])\n                if beforeweight + weight <= maxweight:\n                    nowvalue = dp[beforeweight + weight][outer]\n                    dp[beforeweight + weight][outer] = max(nowvalue,beforevalue+value)\n    #print(dp)\n    for a in range(maxweight+1):\n        #print(dp[a][length])\n        if ansvalue < dp[a][length]:\n            ansvalue = dp[a][length]\n            answeight = a\n    print(\"Case {0}:\".format(cnt))\n    print(ansvalue)\n    print(answeight)"
  },
  {
    "problem_id": "p00044",
    "problem_statement": "Prime Number II\n\nA prime number is an integer greater than 1 that is only divisible by itself and 1. For example, 2 is a prime number because it can only be divided by 2 and 1, but 12 is not a prime number because it can be divided by 2, 3, 4, and 6 in addition to 12 and 1.\n\n\nWrite a program that takes an integer n as input and outputs the largest prime number smaller than n and the smallest prime number larger than n.\n\nInput\n\nMultiple datasets are given. Each dataset is given on one line as n (3 ≤ n ≤ 50,000).\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the largest prime number smaller than n and the smallest prime number larger than n on one line separated by a space.\n\nSample Input\n\n19\n3517\n\nOutput for the Sample Input\n\n17 23\n3511 3527\n",
    "buggy": "from sys import *\n\nmaxnum = 60000\nprimes = [True]*maxnum\nprimes[0] = primes[1] = False\nfor i in range(maxnum):\n    if i >= maxnum**0.5 : break\n    if not primes[i]: continue\n    for j in range(i*2,maxnum,i): primes[j] = False\n\nfor s in stdin:\n    d = int(s)\n    for i in reversed(range(2,d-1)):\n        if primes[i]: print(i, end=' '); break\n    for i in range(d+1,maxnum):\n        if primes[i]: print(i);break",
    "fixed": "from sys import *\n\nmaxnum = 60000\nprimes = [True]*maxnum\nprimes[0] = primes[1] = False\nfor i in range(maxnum):\n    if i >= maxnum**0.5 : break\n    if not primes[i]: continue\n    for j in range(i*2,maxnum,i): primes[j] = False\n\nfor s in stdin:\n    d = int(s)\n    for i in reversed(range(2,d)):\n        if primes[i]: print(i, end=' '); break\n    for i in range(d+1,maxnum):\n        if primes[i]: print(i);break"
  },
  {
    "problem_id": "p00046",
    "problem_statement": "Elevation Difference\n\nThere is data that records the elevation of mountains that have been climbed so far. Create a program that reads this data and outputs the difference in height between the highest and lowest mountains.\n\nInput\n\nThe input is given in the following format.\n\n\nheight of mountain 1\nheight of mountain 2\n...\nheight of mountain n\n\n\nThe height of the mountain is given over several lines. The values entered are all real numbers between 0 and 1,000,000. The number of mountain heights entered is 50 or less.\n\nOutput\n\nOutput the height difference between the highest and lowest mountains as a real number. The output may include an error of 0.01 or less.\n\nSample Input\n\n3776.0\n1819.0\n645.2\n2004.1\n1208.6\n\nOutput for the Sample Input\n\n3130.8\n",
    "buggy": "import sys\n\nms = []\ntry:\n    for v in sys.stdin:\n        ms.append(float(v))\nexcept:\n    print(max(ms)-min(ms))",
    "fixed": "import sys\n\nms = []\nfor v in sys.stdin:\n    ms.append(float(v))\nprint(max(ms)-min(ms))"
  },
  {
    "problem_id": "p00047",
    "problem_statement": "Cup Game\n\n\n\n\n\n\n\n\n\nThere are three cups placed face down. Let's call the places where the cups are placed A, B, and C in order. Initially, a ball is hidden in the cup placed at A. When you swap the positions of the cups, the ball inside also moves together.\n\n\nCreate a program that reads the positions of two cups to be swapped and outputs which cup the ball is hidden in after the swap.\n\nInput\n\nThe positions of two cups to be swapped are given on multiple lines in order. Each line contains two characters (A, B, or C) separated by a comma, representing the positions of the two cups to be swapped.\n\n\nThe number of swaps will not exceed 50.\n\nOutput\n\nOutput the location (A, B, or C) of the cup containing the ball on a single line.\n\nSample Input\n\nB,C\nA,C\nC,B\nA,B\nC,B\n\nOutput for the Sample Input\n\nA\n",
    "buggy": "from math import *\nPI = 3.1415926535898\nbase = \"A\"\nwhile True:\n    try:\n    \tx, y = list(map(str, input().strip().split(',')))\n    \tif x == base:\n    \t\tbase = y\n    \tif y == base:\n    \t\tbase = x\n    except EOFError:\n        break\nprint(base)",
    "fixed": "from math import *\nPI = 3.1415926535898\nbase = \"A\"\nwhile True:\n    try:\n    \tx, y = list(map(str, input().strip().split(',')))\n    \tif x == base:\n    \t\tbase = y\n    \telif y == base:\n    \t\tbase = x\n    except EOFError:\n        break\nprint(base)"
  },
  {
    "problem_id": "p00048",
    "problem_statement": "Weight Classes\n\nIn boxing, weight classes are divided by weight. Create a program that reads in weight and outputs the corresponding weight class. The relationship between weight classes and weight is as follows:\n\n\n\nWeight ClassWeight (kg)\nlight flyBelow 48.00kg\nfly48.00kg or more but less than or equal to 51.00kg\nbantam51.00kg or more but less than or equal to 54.00kg\nfeather54.00kg or more but less than or equal to 57.00kg\nlight57.00kg or more but less than or equal to 60.00kg\nlight welter60.00kg or more but less than or equal to 64.00kg\nwelter64.00kg or more but less than or equal to 69.00 kg\nlight middle69.00kg or more but less than or equal to 75.00 kg\nmiddle75.00kg or more but less than or equal to 81.00 kg\nlight heavy81.00kg or more but less than or equal to 91.00 kg\nheavyMore than 91.00kg\n\n\n\nInput\n\nThe input consists of multiple datasets. For each dataset, a single real number w representing the weight is given on one line. The number of datasets is no more than 50.\n\nOutput\n\nFor each dataset, output the corresponding weight class on one line.\n\nSample Input\n\n60.2\n70.2\n48.0\n80.2\n\nOutput for the Sample Input\n\nlight welter\nlight middle\nlight fly\nmiddle\n",
    "buggy": "import sys\nf = sys.stdin\n\n\n\nclasses = {'light fly':(00.00, 48.00),\n           'fly':(48.00, 51.00),\n           'bantam':(51.00, 54.00),\n           'feather':(54.00,57.00),\n           'light':(57.00,60.00),\n           'light welter':(60.00,64.00),\n           'welter':(64.00,69.00),\n           'light middle':(69.00,75.00),\n           'middle':(75.00,81.00),\n           'light heavy':(81.00,91.00),\n           'heavy':(91.00,1000.00)}\n\nfor line in f:\n    weight = float(line)\n    for class_name, weights in classes.items():\n        if weights[0] <= weight < weights[1]:\n            print(class_name)\n            break",
    "fixed": "import sys\nf = sys.stdin\n\n\nclasses = {'light fly':(00.00, 48.00),\n           'fly':(48.00, 51.00),\n           'bantam':(51.00, 54.00),\n           'feather':(54.00,57.00),\n           'light':(57.00,60.00),\n           'light welter':(60.00,64.00),\n           'welter':(64.00,69.00),\n           'light middle':(69.00,75.00),\n           'middle':(75.00,81.00),\n           'light heavy':(81.00,91.00),\n           'heavy':(91.00,1000.00)}\n\nfor line in f:\n    weight = float(line)\n    for class_name, weights in classes.items():\n        if weights[0] < weight <= weights[1]:\n            print(class_name)\n            break"
  },
  {
    "problem_id": "p00049",
    "problem_statement": "Blood Type\n\nCreate a program that reads data containing the attendance number and ABO blood type of students in a certain class, and outputs the number of people with each blood type. There are four types of ABO blood types: A, B, AB, and O.\n\nInput\n\nThe input consists of multiple lines each containing a comma-separated pair of attendance number and blood type. The attendance number is an integer between 1 and 50, and the blood type is one of the strings \"A\", \"B\", \"AB\", or \"O\". There are no more than 50 students in the class.\n\nOutput\n\nOutput the number of people with each blood type on separate lines, in the following order:\nThe number of people with blood type A\nThe number of people with blood type B\nThe number of people with blood type AB\nThe number of people with blood type O\n\nSample Input\n\n1,B\n2,A\n3,B\n4,AB\n5,B\n6,O\n7,A\n8,O\n9,AB\n10,A\n11,A\n12,B\n13,AB\n14,A\n\nOutput for the Sample Input\n\n5\n4\n3\n2\n",
    "buggy": "from sys import *\n\nlis = {\"A\":0,\"B\":0,\"O\":0,\"AB\":0}\nfor s in stdin:\n    n,t = list(map(str,s[:-1].split(\",\")))\n    lis[t] += 1\nprint(lis[\"A\"])\nprint(lis[\"B\"])\nprint(lis[\"O\"])\nprint(lis[\"AB\"])",
    "fixed": "from sys import *\n\nlis = {\"A\":0,\"B\":0,\"O\":0,\"AB\":0}\nfor s in stdin:\n    n,t = list(map(str,s[:-1].split(\",\")))\n    lis[t] += 1\nprint(lis[\"A\"])\nprint(lis[\"B\"])\nprint(lis[\"AB\"])\nprint(lis[\"O\"])"
  },
  {
    "problem_id": "p00051",
    "problem_statement": "Integer Difference\n\nCreate a program that takes eight digits between 0 and 9 as input and outputs the difference between the largest and smallest integers that can be formed by rearranging those eight digits. The resulting number can start with 0, such as 00135569.\n\nInput\n\nMultiple datasets are given. The first line contains the number of datasets n (≤50). Then, n lines of data are given. Each data is a sequence of eight digits (0 to 9).\n\nOutput\n\nFor each dataset, output the difference between the largest and smallest integers that can be formed by rearranging the input digits on a single line.\n\nSample Input\n\n2\n65539010\n65539010\n\nOutput for the Sample Input\n\n96417531\n96417531\n",
    "buggy": "i = int(input())\n\nwhile (i):\n\ti -= 1\n\tst = []\n\tn = input()\n\n\tfor s in n:\n\t\tst.append(s)\n\n\tst.sort()\n\ta = int(\"\".join())\n\tb = int(\"\".join(st[::-1]))\n\n\tprint(b - a)",
    "fixed": "i = int(input())\n\nwhile (i):\n\ti -= 1\n\tst = []\n\tn = input()\n\n\tfor s in n:\n\t\tst.append(s)\n\n\tst.sort()\n\ta = int(\"\".join(st))\n\tb = int(\"\".join(st[::-1]))\n\n\tprint(b - a)"
  },
  {
    "problem_id": "p00052",
    "problem_statement": "Factorial II\n\nThe factorial of n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 12! = 12 × 11 × 10 × 9 × 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 479001600, and it has two consecutive zeros at the end.\n\n\nWrite a program that reads a positive integer n (≤ 20000) and outputs the number of consecutive zeros at the end of n!.\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of a single line containing a positive integer n (≤ 20000). The end of the input is indicated by a line containing a single zero.\n\nOutput\n\nFor each dataset, output the number of consecutive zeros at the end of n!.\n\nSample Input\n\n2\n12\n10000\n0\n\nOutput for the Sample Input\n\n0\n2\n2499\n",
    "buggy": "while 1:\n    try:\n        zero=0\n        number=1\n        n=int(input())\n        for i in range(1,n+1):\n            number*=i\n            while len(str(number))>7:number=int(str(number)[1:])\n            while number%10==0:\n                zero+=1\n                number=int(number/10)\n        print(zero)\n    except:break\n",
    "fixed": "while 1:\n    zero=0\n    number=1\n    n=int(input())\n    if n==0:break\n    for i in range(1,n+1):\n        number*=i\n        while len(str(number))>7:number=int(str(number)[1:])\n        while number%10==0:\n            zero+=1\n            number=int(number/10)\n    print(zero)\n"
  },
  {
    "problem_id": "p00053",
    "problem_statement": "Sum of Prime Numbers\n\nLet p(i) be the i-th prime number in ascending order. For example, 7 is the 4th prime number, which is 2, 3, 5, 7 in ascending order, so p(4) = 7.\n\n\nGiven an integer n, create a program that outputs the sum s of p(i) for i = 1 to n, where\n\ns = p(1) + p(2) + .... + p(n).\n\nFor example, when n = 9, s = 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 = 100.\n\nInput\n\nMultiple datasets will be given. For each dataset, an integer n (n ≤ 10000) will be given. When n is 0, it is the end of the input. There will be no more than 50 datasets.\n\nOutput\n\nFor each n in each dataset, output s on one line.\n\nSample Input\n\n2\n9\n0\n\nOutput for the Sample Input\n\n5\n100\n",
    "buggy": "import sys\nfrom itertools import *\nn=104730;a=list(range(n));a[:2]=0,0\nfor i in range(2,323):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(range(n),a))\nfor e in sys.stdin:\n if'0'!=e:print(sum(p[:int(e)]))\n",
    "fixed": "import sys\nfrom itertools import *\nn=104730;a=list(range(n));a[:2]=0,0\nfor i in range(2,323):a[i*2::i]=[0]*len(a[i*2::i])\np=list(compress(range(n),a))\nfor e in sys.stdin:\n if'0\\n'!=e:print(sum(p[:int(e)]))\n"
  },
  {
    "problem_id": "p00054",
    "problem_statement": "Sum of Decimal Digits\n\nLet a, b, and n be positive integers. Let f(i) be the i-th digit (0 ≤ f(i) ≤ 9) of the decimal expansion of the fraction a / b. Define the sum s as the sum of the first n digits:\n\n\ns = f(1) + f(2) + ... + f(n)\n\n\nWrite a program that reads a, b, and n, and outputs s.\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of three integers a (1 ≤ a ≤ 1000), b (1 ≤ b ≤ 10000), and n (1 ≤ n ≤ 100), separated by a single space, on a line.\n\n\nThere are no more than 100 datasets.\n\nOutput\n\nFor each dataset, output s on a line.\n\nSample Input\n\n1 2 3\n2 3 4\n5 4 3\n4 3 2\n\nOutput for the Sample Input\n\n5\n24\n7\n6\n",
    "buggy": "while True:\n    try:\n        a, b, n = map(int, input().split())\n    except:\n        break\n\n    s = str(a/b)\n    sum = 0\n    x = s.index(\".\")+1\n    for i in s[x:2+x]:\n        sum += int(i)\n\n    print(sum)",
    "fixed": "while True:\n    try:\n        a, b, n = map(int, input().split())\n    except:\n        break\n\n    s = str(a/b)\n    sum = 0\n    x = s.index(\".\")+1\n    for i in s[x:x+n]:\n        sum += int(i)\n\n    print(sum)"
  },
  {
    "problem_id": "p00055",
    "problem_statement": "Sequence\n\nThere is a sequence defined as follows:\n\n\nAll even-indexed terms are equal to the previous term multiplied by 2.\nAll odd-indexed terms are equal to the previous term divided by 3.\n\n\nCreate a program that reads the first term a of the sequence and outputs the sum of the first 10 terms, s(10).\n\nInput\n\nThe input consists of multiple test cases. For each test case, a real number a (1.0 ≤ a ≤ 10.0) representing the first term of the sequence is given on a single line.\n\n\nThere are no more than 50 test cases.\n\nOutput\n\nFor each test case, output s(10) on a single line.\n\n\nThe output may contain an error of up to 0.000001.\n\nSample Input\n\n1.0\n2.0\n3.0\n\nOutput for the Sample Input\n\n7.81481481\n15.62962963\n23.44444444\n",
    "buggy": "import sys\nfor e in sys.stdin:\n t=[a,\n a*2,\n a*2/3,\n a*2/3*2,\n a*2/3*2/3,\n a*2/3*2/3*2,\n a*2/3*2/3*2/3,\n a*2/3*2/3*2/3*2,\n a*2/3*2/3*2/3*2/3,\n a*2/3*2/3*2/3*2/3*2]\n print(sum(t))\n",
    "fixed": "import sys\nfor e in sys.stdin:\n a=float(e)\n t=[a,\n a*2,\n a*2/3,\n a*2/3*2,\n a*2/3*2/3,\n a*2/3*2/3*2,\n a*2/3*2/3*2/3,\n a*2/3*2/3*2/3*2,\n a*2/3*2/3*2/3*2/3,\n a*2/3*2/3*2/3*2/3*2]\n print(sum(t))\n"
  },
  {
    "problem_id": "p00056",
    "problem_statement": "Goldbach's Conjecture\n\nIt is known that any even number greater than or equal to 4 can be expressed as the sum of two prime numbers. This is called Goldbach's conjecture, and it has been confirmed to be true for very large numbers by computer calculations. For example, 10 can be expressed as the sum of two prime numbers, 7 + 3 and 5 + 5.\n\n\nWrite a program that takes an integer n as input and outputs the number of ways to express n as the sum of two prime numbers. Assume that n is even and between 4 and 50,000. There may be multiple datasets, and the input ends with 0.\n\nInput\n\nMultiple datasets are given. Each dataset consists of a single line containing an integer n. When n is 0, it indicates the end of the input. The number of datasets does not exceed 10,000.\n\nOutput\n\nFor each dataset, output the number of ways to express n as the sum of two prime numbers on a single line.\n\nSample Input\n\n10\n11\n0\n\nOutput for the Sample Input\n\n2\n0\n",
    "buggy": "import sys\nf = sys.stdin\n\ndef create_prime(n):\n    prime = [1] * (n + 1)\n    prime[:2] = [0, 0]\n    for i in range(len(prime)):\n        if prime[i]:\n            for j in range(2 * i, len(prime), i):\n                prime[j] = 0\n    return prime\n\nsieve = create_prime(50000)\n\n\nprime = []\nfor i in range(25001):\n    if sieve[i]:\n        prime.append(i)\n\nwhile True:\n    n = int(f.readline())\n    if n == 0:\n        break\n    cnt = 0\n    temp = n // 2 + 1\n    for i in prime:\n        if i > temp:\n            break\n        if sieve[n - i]:\n            cnt += 1\n    print(cnt)",
    "fixed": "import sys\nf = sys.stdin\n\ndef create_prime(n):\n    prime = [1] * (n + 1)\n    prime[:2] = [0, 0]\n    for i in range(len(prime)):\n        if prime[i]:\n            for j in range(2 * i, len(prime), i):\n                prime[j] = 0\n    return prime\n\nsieve = create_prime(50000)\n\nprime = []\nfor i in range(25001):\n    if sieve[i]:\n        prime.append(i)\n\nwhile True:\n    n = int(f.readline())\n    if n == 0:\n        break\n    cnt = 0\n    temp = n // 2\n    for i in prime:\n        if i > temp:\n            break\n        if sieve[n - i]:\n            cnt += 1\n    print(cnt)"
  },
  {
    "problem_id": "p00057",
    "problem_statement": "Number of Areas\n\nWhen an infinite number of infinitely long lines are drawn on an infinitely wide plane, the plane is divided into several areas. For example, if one line is drawn, the plane is divided into two areas. Even if the same number of lines are drawn, the number of areas obtained depends on how the lines are drawn. For example, if two lines are drawn parallel to each other, three areas are obtained, and if they are drawn perpendicular to each other, four areas are obtained.\n\n\n\n\n\n\nCreate a program that outputs the maximum number of areas obtained by drawing n lines.\n\nInput\n\nMultiple datasets will be given. For each dataset, n (1 ≤ n ≤ 10,000) is given on one line. Process until the end of the input.\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the maximum number of divisions on one line.\n\nSample Input\n\n1\n3\n\nOutput for the Sample Input\n\n2\n7\n",
    "buggy": "import sys\nlc=lambda n:int((n**2+n+2)/2)\n[print(i) for i in [lc(int(j)) for j in sts.stdin]]\n",
    "fixed": "import sys\nlc=lambda n:int((n**2+n+2)/2)\n[print(i) for i in [lc(int(j)) for j in sys.stdin]]\n"
  },
  {
    "problem_id": "p00058",
    "problem_statement": "Orthogonal Judgment\nWrite a program that reads the coordinates of four different points on a plane, $A(x_A,y_A)$, $B(x_B,y_B)$, $C(x_C,y_C)$, and $D(x_D,y_D)$, and outputs YES if the line AB and CD are orthogonal, or NO if they are not orthogonal. Note that \"line\" here refers to a straight line, not a line segment. See the figure below for reference.\n\n\n\n\n\nInput\nThe input consists of multiple datasets. The format for each dataset is as follows.\n\n\n$x_A$ $y_A$ $x_B$ $y_B$ $x_C$ $y_C$ $x_D$ $y_D$\n\n\nHere, $x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$, $x_D$, and $y_D$ are real numbers ranging from -100 to 100, and each value is given as a real number with up to five decimal places.\n\n\nThere are no more than 100 datasets.\n\nOutput\n\nFor each dataset, output YES or NO on a single line.\n\nSample Input\n\n1.0 1.0 2.0 2.0 0.0 0.0 1.0 -1.0\n0.0 0.0 2.0 0.0 -1.0 2.0 2.0 2.0\n10.0 6.0 3.4 5.2 6.8 9.5 4.3 2.1\n2.5 3.5 2.5 4.5 -3.3 -2.3 6.8 -2.3\n\nOutput for the Sample Input\n\nYES\nNO\nNO\nYES\n",
    "buggy": "while True:\n    try:\n        xa, ya, xb, yb, xc, yc, xd, yd = map(float, input().split())\n    except:\n        break\n    if (ya - yb) * (yc - yd) + (xa - xb) * (xc - xd) < 1.e-10:\n        print('YES')\n    else:\n        print('NO')",
    "fixed": "while True:\n    try:\n        xa, ya, xb, yb, xc, yc, xd, yd = map(float, input().split())\n    except:\n        break\n    if abs((ya - yb) * (yc - yd) + (xa - xb) * (xc - xd)) < 1.e-10:\n        print('YES')\n    else:\n        print('NO')"
  },
  {
    "problem_id": "p00059",
    "problem_statement": "Overlap of Rectangles\n\nThere are two rectangles whose bottom edge is parallel to the x axis. Read the coordinates of the lower left (xa1, ya1) and upper right (xa2, ya2) corners of rectangle A, and the coordinates of the lower left (xb1, yb1) and upper right (xb2, yb2) corners of rectangle B. Write a program that outputs YES if rectangles A and B overlap at least partially, and NO otherwise. Assume that rectangles A and B are not the same. Also, assume that rectangles that are only touching each other are considered to be overlapping.\n\n\n\n\n\nInput\n\nMultiple datasets are provided. The format of each dataset is as follows.\n\n\nxa1 ya1 xa2 ya2 xb1 yb1 xb2 yb2\n\n\nThe input values are each within -2,000 to 2,000 and are real numbers with up to five decimal places.\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output YES or NO on one line.\n\nSample Input\n\n0.0 0.0 5.0 5.0 1.0 1.0 4.0 4.0\n0.0 0.0 4.0 5.0 1.0 1.0 5.0 5.0\n0.0 0.0 4.0 4.0 -3.0 -5.0 2.0 -1.0\n\nOutput for the Sample Input\n\nYES\nYES\nNO\n",
    "buggy": "import sys\n\nfor s in sys.stdin:\n    xa1,ya1,xa2,ya2,xb1,yb1,xb2,yb2 = list(map(float,s.split()))\n    if xb1 < xa1 or xa2 < xb1: print(\"NO\")\n    elif yb2 < ya1 or ya2 < yb1: print(\"NO\")\n    else: print(\"YES\")",
    "fixed": "import sys\n\nfor s in sys.stdin:\n    xa1,ya1,xa2,ya2,xb1,yb1,xb2,yb2 = list(map(float,s.split()))\n    if xb2 < xa1 or xa2 < xb1: print(\"NO\")\n    elif yb2 < ya1 or ya2 < yb1: print(\"NO\")\n    else: print(\"YES\")"
  },
  {
    "problem_id": "p00060",
    "problem_statement": "Card Game\n\nThere are 10 cards with numbers from 1 to 10 written on them, each with one card. The cards have numbers written on the front and nothing on the back. You and your opponent will play a game using these cards following the rules below.\n\n\n You and your opponent are each dealt two cards, one with the front facing up and one with the back facing up. You can see the number on your opponent's card with the front facing up, but not the one with the back facing up.\n\n You win if the total of the numbers on the cards dealt is less than or equal to 20 and greater than the total of your opponent's cards. For example, if your cards are \"7\" and \"8\" (total of 15) and your opponent's cards are \"9\" and \"10\" (total of 19), your opponent wins.\n\n You and your opponent can draw one more card at most. You don't have to draw it.\n\n\n\n  Here, as a guideline for deciding whether to draw one more card, let's draw a card if the probability of the total becoming 20 or less when we draw it is 50% or more. When calculating this probability, you can use information about your two cards and your opponent's face-up card. In other words, since there is only one of each card, you will not draw those cards.\n\n\nWrite a program that reads your two cards and your opponent's face-up card and outputs YES if the probability of the total becoming 20 or less when you draw one more card is 50% or more, and NO otherwise.\n\nInput\n\nThe input consists of multiple datasets. Let C1 be the number on your first card, C2 be the number on your second card, and C3 be the number on your opponent's face-up card. Each dataset is given in the following format.\n\nC1 C2 C3\n\nOutput\n\nFor each dataset, output YES or NO on one line.\n\nSample Input\n\n1 2 3\n5 6 9\n8 9 10\n\nOutput for the Sample Input\n\nYES\nYES\nNO\n",
    "buggy": "while True:\n    try:\n        a, b, c = map(int, input().split())\n    except:\n        break\n\n    l=[True] * 11\n    l[a] = l[b] = l[c] = False\n    sum = a + b\n    over = 0\n\n    for i in range(1,11):\n        if l[i]:\n            if sum + i > 20:\n                print(i)\n                over += 1\n\n    if over / 7 <= 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "fixed": "while True:\n    try:\n        a, b, c = map(int, input().split())\n    except:\n        break\n\n    l=[True] * 11\n    l[a] = l[b] = l[c] = False\n    sum = a + b\n    over = 0\n\n    for i in range(1,11):\n        if l[i]:\n            if sum + i > 20:\n                over += 1\n\n    if over / 7 < 0.5:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
  },
  {
    "problem_id": "p00062",
    "problem_statement": "What is the number on the bottom row? \n\nConsider a pattern of numbers as follows:\n4 8 2 3 1 0 8 3 7 6\n 2 0 5 4 1 8 1 0 3\n  2 5 9 5 9 9 1 3\n   7 4 4 4 8 0 4\n    1 8 8 2 8 4\n     9 6 0 0 2\n      5 6 0 2\n       1 6 2\n        7 8\n         5\n\nThis pattern follows the following rule:\nIn a sequence of numbers as follows:\nA B\n C \nC is the digit in the one's place of A + B. For example,\n\n9 5\n 4\n\nIn this case, the digit 4 is placed below 9 and 5 since 9 + 5 = 14 and the one's digit of 14 is 4. Similarly,\n\n2 3\n 5\n\nIn this case, the digit 5 is placed below 2 and 3 since 2 + 3 = 5 and the one's digit of 5 is 5.\n\nWrite a program that reads the 10 integers on the top line and outputs the single integer on the bottom row.\n\nInput:\n\nThe input consists of multiple datasets. Each dataset consists of 10 digits on the top line as a string.\n\nThe number of datasets is no more than 20.\n\nOutput:\n\nFor each dataset, output the number on the bottom line in one line.\n\nSample Input:\n\n4823108376\n1234567890\n0123456789\n\nOutput for the Sample Input:\n\n5\n6\n4",
    "buggy": "def suicide(lis):\n    if len(lis) == 1:\n        print(lis[0])\n    pokakito = []\n    for i in range(len(lis)-1):\n        check = lis[i] + lis[i+1]\n        one = int(str(check)[-1])\n        pokakito.append(one)\n    else:\n        suicide(pokakito)\n\nwhile True:\n    try:\n        lis = [int(char) for char in input()]\n        suicide(lis)\n    except EOFError:\n        break",
    "fixed": "def suicide(lis):\n    if len(lis) == 1:\n        print(lis[0])\n        return\n    pokakito = []\n    for i in range(len(lis)-1):\n        check = lis[i] + lis[i+1]\n        one = int(str(check)[-1])\n        pokakito.append(one)\n    else:\n        suicide(pokakito)\n\nwhile True:\n    try:\n        lis = [int(char) for char in input()]\n        suicide(lis)\n    except EOFError:\n        break"
  },
  {
    "problem_id": "p00063",
    "problem_statement": "Palindrome\n\nThere is data consisting of lines containing at most 100 characters each, composed of half-width alphabet characters. Some of the lines are symmetrical (read the same from left to right, or right to left). Create a program that reads this data and outputs the number of symmetrical strings in it. A line consisting of a single character is considered symmetrical.\n\nInput\n\nMultiple character strings are given on multiple lines. One string is given per line. The number of strings does not exceed 50.\n\nOutput\n\nOutput the number of symmetrical strings in one line.\n\nSample Input\n\nabcba\nsx\nabcddcba\nrttrd\n\nOutput for the Sample Input\n\n2\n",
    "buggy": "count = 0\nwhile True:\n    a = input()\n    b = a[::-1]\n    if a == b: count+=1\n    print(count)\n\n    ",
    "fixed": "count = 0\ntry:\n    while True:\n        a = input()\n        b = a[::-1]\n        if a == b: count+=1\nexcept EOFError: pass\nprint(count)"
  },
  {
    "problem_id": "p00064",
    "problem_statement": "Passcode\n\nThe new passcode is difficult to remember. I was told not to write it down, but I don't think I can remember it. So I decided to embed numbers in the text and make a memo of the passcode. Here, the sum of all the numbers will be the passcode.\n\n\nCreate a program that reads the memoized text and outputs the passcode.\n\nInput\n\nA positive integer is embedded in the text, given over multiple lines. Each line is a string including half-width alphanumeric characters, symbols, and spaces, or a blank line.\nHowever, the input is guaranteed to be within 80 characters per line, and the passcode is guaranteed to be less than or equal to 10,000.\n\nOutput\n\nOutput the passcode (the sum of positive integers in the text) on one line.\n\nSample Input\n\nThereare100yenonthetable.Iam17yearsold.\nIshouldgohomeat6pm.\n\nOutput for the Sample Input\n\n123\n",
    "buggy": "suicide = 0\nwhile True:\n    try:\n        sentence = input()\n        start = None\n        last = None\n        for index, char in enumerate(sentence):\n            if char.isdigit():\n                start = index\n            elif not start == None and not char.isdigit():\n                last = index\n                suicide += int(sentence[start:last])\n                start = None\n                last = None\n        else:\n            if not start == None:\n                suicide += int(sentence[start:])\n    except EOFError:\n        print(suicide)\n        break",
    "fixed": "suicide = 0\nwhile True:\n    try:\n        sentence = input()\n        start = None\n        last = None\n        for index, char in enumerate(sentence):\n            if char.isdigit():\n                if start == None:\n                    start = index\n            elif not start == None and not char.isdigit():\n                last = index\n                suicide += int(sentence[start:last])\n                start = None\n                last = None\n        else:\n            if not start == None:\n                suicide += int(sentence[start:])\n    except EOFError:\n        print(suicide)\n        break"
  },
  {
    "problem_id": "p00065",
    "problem_statement": "Transaction\n\nThere is data that records customer numbers and transaction dates for each month. Create a program that reads this month's data and last month's data, and outputs the customer numbers and the number of transactions for companies that have had transactions for two consecutive months since last month. However, the number of trading partners per month is less than 1,000.\n\nInput\n\nThis month's data and last month's data are separated by a blank line and given. Each data is given in the following format.\n\n\nc1,d1\nc2,d2\n...\n...\n\n\nci (1 ≤ ci ≤ 1,000) is an integer representing the customer number, and di (1 ≤ di ≤ 31) is an integer representing the transaction date.\n\nOutput\n\nOutput the customer number and the total number of transactions, separated by a space, in order of customer number for companies that have had transactions for two consecutive months. \n\nSample Input\n\n123,10\n56,12\n34,14\n\n123,3\n56,4\n123,5\n\nOutput for the Sample Input\n\n56 2\n123 3\n",
    "buggy": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c_=e.split(',');c=int(c);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n",
    "fixed": "import sys\nb=0\na=[{},{}]\nfor e in sys.stdin:\n if'\\n'==e:b=1\n else:c,_=e.split(',');c=int(c);a[b].setdefault(c,0);a[b][c]+=1\nfor k in sorted({*a[0]}&{*a[1]}):print(k,a[0][k]+a[1][k])\n"
  },
  {
    "problem_id": "p00066",
    "problem_statement": "Tic-Tac-Toe\n\nTic-tac-toe is a game in which players take turns marking a 3x3 grid with either an \"X\" or an \"O\". The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game. (Refer to Figures 1-3)\n\n\n\n\n\n\n\n\n\nFigure 1: \"O\" wins\nFigure 2: \"X\" wins\nFigure 3: Draw\n\n\n\n\n\nIn tic-tac-toe, players take turns filling the grid with their respective marks until one player has three in a row. Thus, as shown in Figure 4, it is impossible for \"O\" and \"X\" to both have three in a row. It is guaranteed that no such impossible grid will be given as input.\n\n\n\n\n\n\n\nFigure 4: Impossible grid\n\n\n\n\n\nWrite a program that reads in a tic-tac-toe grid and outputs the winner.\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of one line representing the grid.\nThe grid is represented by a string of lowercase letters \"o\" (for \"O\"), \"x\" (for \"X\"), and \"s\" (for empty spaces), in the order shown below.\n\n\n\n\n\n\nThere will be no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the lowercase letter \"o\" if \"O\" wins, \"x\" if \"X\" wins, or \"d\" if it is a draw, on a separate line.\n\nSample Input\n\nooosxssxs\nxoosxsosx\nooxxxooxo\n\nOutput for the Sample Input\n\no\nx\nd\n",
    "buggy": "import sys\nf = sys.stdin\n\nvlines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]\n\nfor line in f:\n    result = 'd'\n    for v in vlines:\n        if 's' != a and line[v[0]]== line[v[1]] == line[v[2]]:\n            result = line[v[0]]\n            break\n    print(result)",
    "fixed": "import sys\nf = sys.stdin\n\n\nvlines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]\n\nfor line in f:\n    result = 'd'\n    for v in vlines:\n        if 's' !=  line[v[0]] and line[v[0]]== line[v[1]] == line[v[2]]:\n            result = line[v[0]]\n            break\n    print(result)\n    "
  },
  {
    "problem_id": "p00067",
    "problem_statement": "Number of Islands\n\nYou are given a map of a terrain represented by a 12 x 12 grid of squares. Each square is painted black or white. White represents the sea, and black represents land. Two black squares that are adjacent vertically or horizontally are said to be contiguous. In this map, a single black square or a contiguous group of black squares is called an \"island.\" For example, there are five islands in the following figure:\n\n\n■■■■□□□□■■■■\n■■■□□□□□■■■■\n■■□□□□□□■■■■\n■□□□□□□□■■■■\n□□□■□□□■□□□□\n□□□□□□■■■□□□\n□□□□□■■■■■□□\n■□□□■■■■■■■□\n■■□□□■■■■■□□\n■■■□□□■■■□□□\n■■■■□□□■□□□□\n□□□□□□□□□□□□\n\n\nWrite a program that reads the map data and outputs the number of islands.\n\nInput\n\nThe input consists of multiple data sets. Each data set represents a single map. A single map is represented as a 12 x 12 grid of squares, each of which is represented as a 0 or a 1. 0 represents a white square, and 1 represents a black square. Each map is separated by a single blank line.\n\n\nThere are at most 20 data sets.\n\nOutput\n\nFor each data set, output the number of islands in the map on a single line.\n\nSample Input\n\n111100001111\n111000001111\n110000001111\n100000001111\n000100010000\n000000111000\n000001111100\n100011111110\n110001111100\n111000111000\n111100010000\n000000000000\n\n010001111100\n110010000010\n010010000001\n010000000001\n010000000110\n010000111000\n010000000100\n010000000010\n010000000001\n010010000001\n010010000010\n111001111100\n\n000000000000\n111111111111\n100010100001\n100010100001\n100010100001\n100010100001\n100100100101\n101000011101\n100000000001\n100000000001\n111111111111\n100000000001\n\nOutput for the Sample Input\n\n5\n13\n4\n\nHint\n\nThe following is a representation of the sample input using ■ and □.\n\n■■■■□□□□■■■■　　□■□□□■■■■■□□　　□□□□□□□□□□□□\n■■■□□□□□■■■■　　■■□□■□□□□□■□　　■■■■■■■■■■■■\n■■□□□□□□■■■■　　□■□□■□□□□□□■　　■□□□■□■□□□□■\n■□□□□□□□■■■■　　□■□□□□□□□□□■　　■□□□■□■□□□□■\n□□□■□□□■□□□□　　□■□□□□□□□■■□　　■□□□■□■□□□□■\n□□□□□□■■■□□□　　□■□□□□■■■□□□　　■□□□■□■□□□□■\n□□□□□■■■■■□□　　□■□□□□□□□■□□　　■□□■□□■□□■□■\n■□□□■■■■■■■□　　□■□□□□□□□□■□　　■□■□□□□■■■□■\n■■□□□■■■■■□□　　□■□□□□□□□□□■　　■□□□□□□□□□□■\n■■■□□□■■■□□□　　□■□□■□□□□□□■　　■□□□□□□□□□□■\n■■■■□□□■□□□□　　□■□□■□□□□□■□　　■■■■■■■■■■■■\n□□□□□□□□□□□□　　■■■□□■■■■■□□　　■□□□□□□□□□□■\n\n",
    "buggy": "def fill(x, y, board):\n    board[y][x] = 2\n    points = [[y, x + 1], [y, x - 1], [y + 1, x], [y - 1, x]]\n    # y\n    if y == 0:\n        points.remove([y-1, x])\n    elif y == 11:\n        points.remove([y+1, x])\n    # x\n    if x == 0:\n        points.remove([y, x - 1])\n    elif x == 11:\n        points.remove([y, x + 1])\n    for p in points:\n        if board[p[0]][p[1]] == 1:\n            board = fill(p[1], p[0], board)\n    return board\n\nislands = [list(map(int, list(input()))) for i in range(12)]\nans = 0\n\nfor y in range(12):\n    for x in range(12):\n        if islands[y][x] == 1:\n            islands = fill(x, y, islands)\n            ans += 1\nprint(ans)",
    "fixed": "def fill(x, y, board):\n    board[y][x] = 2\n    points = [[y, x + 1], [y, x - 1], [y + 1, x], [y - 1, x]]\n\n    if y == 0:\n        points.remove([y-1, x])\n    elif y == 11:\n        points.remove([y+1, x])\n    if x == 0:\n        points.remove([y, x - 1])\n    elif x == 11:\n        points.remove([y, x + 1])\n\n    for p in points:\n        if board[p[0]][p[1]] == 1:\n            board = fill(p[1], p[0], board)\n    return board\n\nwhile True:\n    try:\n        islands = [list(map(int, list(input()))) for i in range(12)]\n        ans = 0\n\n        for y in range(12):\n            for x in range(12):\n                if islands[y][x] == 1:\n                    islands = fill(x, y, islands)\n                    ans += 1\n        print(ans)\n        input()\n    except:\n        break"
  },
  {
    "problem_id": "p00069",
    "problem_statement": "Amidakuji II\n\nThere is an amidakuji with n vertical lines. The following conditions are satisfied by this amidakuji:\n\n\nThe horizontal lines are drawn horizontally. They are not drawn diagonally.\nThe horizontal lines always connect adjacent vertical lines. In other words, the horizontal lines do not cross any vertical lines.\nNo two horizontal lines come out of the same point on any vertical line. In other words, the horizontal lines do not cross each other.\nThere is only one winning position.\n\n\nThe example of amidakuji with n = 5 is shown in the figure below. The numbers at the top indicate the numbers of vertical lines (1, 2, 3, 4, 5 from left to right). The ☆ represents the winning position.\n\n\n\n\n\n\nWrite a program that reads the number of vertical lines n, the number m of the selected vertical line, the position of the winning position, and the presence or absence of horizontal lines at each level of the amidakuji, and determines whether the winning position can be reached. It is assumed that one horizontal line can be added at any position of the given amidakuji (but it is not necessary to add it). The amidakuji after adding one horizontal line must also satisfy the above conditions.\n\nInput\n\nMultiple data sets are given. Each data set is as follows:\n\n\nThe first line contains the number of vertical lines n (1 < n ≤ 10).\nThe second line contains the number m of the selected vertical line (1 ≤ m ≤ n).\nThe third line contains the number of the winning position (counted from the left).\nThe fourth line contains the number of levels d of the amidakuji (1 ≤ d ≤ 30).\nFrom the fifth line onwards, n - 1 numbers are listed in order from top to bottom of the amidakuji, with 1 indicating the presence of a horizontal line and 0 indicating its absence.\n\n\n\nThe input ends with a line containing a single 0.\n\nOutput\n\nFor each data set, output the following values depending on whether the winning position can be reached from the selected vertical line m:\n\n\nIf the winning position can be reached without drawing any horizontal lines, output 0.\nIf the winning position can be reached by drawing one horizontal line, output the position of the line closest to the starting side (upward in the figure). Output the number of the vertical line counting from the left and the level counting from the starting side where the line is drawn (refer to the figure) separated by a space.\nIf the winning position cannot be reached even by drawing one horizontal line, output 1.\n\nSample Input\n\n5\n2\n3\n9\n1010\n1001\n0100\n1001\n0010\n1000\n0100\n0101\n1010\n0\n\nOutput for the Sample Input\n\n6 4\n",
    "buggy": "def check(n,m,star,d,f):\n    ns=[i for i in range(n)]\n    for i in range(d):\n        for j in range(n-1):\n            if f[i][j]:\n                c=ns[j+1]\n                ns[j+1]=ns[j]\n                ns[j]=c\n    return ns[star-1]==m-1\n\n\n\nwhile True:\n    n=int(input())\n    if(n==0):break\n    m=int(input())\n    star=int(input())\n    d=int(input())\n    f=[[False for i in range(n-1)]for j in range(d)]\n    for i in range(d):\n        st=input()\n        for j in range(n-1):\n            f[i][j]=st[j]=='1'\n    if check(n,m,star,d,f):\n        print(1)\n    else:\n        ans=False\n        for i in range(d):\n            for j in range(n-1):\n                if ans:break\n                ok=not f[i][j]\n                if(j>0 and f[i][j-1]) or (j<n-2 and f[i][j+1]):ok=False\n                if ok:\n                    f[i][j]=True\n                    if check(n,m,star,d,f):\n                        print(i+1,j+1)\n                        ans=True\n                    f[i][j]=False\n        if not ans:\n            print(0)",
    "fixed": "def check(n,m,star,d,f):\n    ns=[i for i in range(n)]\n    for i in range(d):\n        for j in range(n-1):\n            if f[i][j]:\n                c=ns[j+1]\n                ns[j+1]=ns[j]\n                ns[j]=c\n    return ns[star-1]==m-1\n\n\n\nwhile True:\n    n=int(input())\n    if(n==0):break\n    m=int(input())\n    star=int(input())\n    d=int(input())\n    f=[[False for i in range(n-1)]for j in range(d)]\n    for i in range(d):\n        st=input()\n        for j in range(n-1):\n            f[i][j]=st[j]=='1'\n    if check(n,m,star,d,f):\n        print(0)\n    else:\n        ans=False\n        for i in range(d):\n            for j in range(n-1):\n                if ans:break\n                ok=not f[i][j]\n                if(j>0 and f[i][j-1]) or (j<n-2 and f[i][j+1]):ok=False\n                if ok:\n                    f[i][j]=True\n                    if check(n,m,star,d,f):\n                        print(i+1,j+1)\n                        ans=True\n                    f[i][j]=False\n        if not ans:\n            print(1)"
  },
  {
    "problem_id": "p00070",
    "problem_statement": "Combination of Number Sequences\n\nConsider an arrangement of n integers from 0 to 9, denoted by k1, k2, ..., kn. Read in positive integers n and s, and output the number of arrangements of n integers for which the sum of k1 + 2 × k2 + 3 × k3 + ... + n × kn = s. Note that each arrangement of n integers must contain unique numbers without repetition.\n\nInput\n\nThe input consists of multiple datasets. Each dataset consists of two integers separated by a single space: n (1 ≤ n ≤ 10) and s (0 ≤ s ≤ 10,000).\n\n\nThere are no more than 100 datasets.\n\nOutput\n\nFor each dataset, output the number of arrangements of n integers whose sum is s on one line.\n\nSample Input\n\n3 10\n3 1\n\nOutput for the Sample Input\n\n8\n0\n",
    "buggy": "from collections import defaultdict, Counter\nimport sys\n\n# dp[n][使った数字(bit)][合計] = count\ndp = [defaultdict(Counter) for _ in [0]*11]\ndp[0][0][0] = 0\n\nfor i in range(1, 11):\n    for used, counter in dp[i-1].items():\n        for j in filter(lambda x: used & 2**x == 0, range(10)):\n            for total, count in counter.items():\n                dp[i][used|2**j][total+j*i] += 1\n\nfor n, s in (map(int, l.rstrip().split()) for l in sys.stdin):\n    print(sum(v for counter in dp[n].values() for k, v in counter.items() if k == s))\n",
    "fixed": "from collections import defaultdict, Counter\nimport sys\n\n# dp[n][使った数字(bit)][合計] = count\ndp = [defaultdict(Counter) for _ in [0]*11]\ndp[0][0][0] = 1\n\nfor i in range(1, 11):\n    for used, counter in dp[i-1].items():\n        for j in filter(lambda x: used & 2**x == 0, range(10)):\n            for total, count in counter.items():\n                dp[i][used|2**j][total+j*i] += count\n\nfor n, s in (map(int, l.rstrip().split()) for l in sys.stdin):\n    print(sum(v for counter in dp[n].values() for k, v in counter.items() if k == s))\n\n"
  },
  {
    "problem_id": "p00071",
    "problem_statement": "**Translation**\n\nChain of Bombs\n\nThere is a grid consisting of 8 rows and 8 columns, as shown in Figure 1. On that grid, several bombs are placed. An example of this is shown in Figure 2 (● = bomb).\n\n\n\n\n\n\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n□□□□□□□□\n\n\n\n\n□□□●□□●□\n□□□□□●□□\n●□□□●□□●\n□□●□□□●□\n□●□□□□□□\n<",
    "buggy": "def solve(data,p):\n    L=[]\n    if data[p[1]-1][p[0]-1]==\"1\":\n        data[p[1]-1]=data[p[1]-1][:p[0]-1]+\"0\"+data[p[1]-1][p[0]:]\n        L+=p\n    else:\n        return []\n    bakuhu=[(p[0]-3,p[1]),(p[0]-2,p[1]),(p[0]-1,p[1]),(p[0]+1,p[1]),(p[0]+2,p[1]),(p[0]+3,p[1]),(p[0],p[1]-3),(p[0],p[1]-2),(p[0],p[1]-1),(p[0],p[1]+1),(p[0],p[1]+2),(p[0],p[1]+3)]\n    for i in range(len(bakuhu)):\n        if bakuhu[i][0]>0 and bakuhu[i][1] >0 and bakuhu[i][0] <9 and bakuhu[i][1] <9:\n            L.extend(solve(data,bakuhu[i]))\n    return L\n    \nwhile True:\n    try:\n        ndata=eval(input())\n        for i in range(ndata):\n            input()\n            data=[]\n            for j in range(8):\n                data.append(input())\n            x=eval(input())\n            y=eval(input())\n            p=(x,y)\n            L=solve(data,p)\n            while len(L)!=0:\n                x=L.pop(0)\n                y=L.pop(0)\n                data[y-1]=data[y-1][:x-1]+'0'+data[y-1][x:]\n            print(\"Data\"+str(i+1)+':')\n            for i in range(len(data)):\n                print(data[i])\n    except:\n        break",
    "fixed": "def solve(data,p):\n    L=[]\n    if data[p[1]-1][p[0]-1]==\"1\":\n        data[p[1]-1]=data[p[1]-1][:p[0]-1]+\"0\"+data[p[1]-1][p[0]:]\n        L+=p\n    else:\n        return []\n    bakuhu=[(p[0]-3,p[1]),(p[0]-2,p[1]),(p[0]-1,p[1]),(p[0]+1,p[1]),(p[0]+2,p[1]),(p[0]+3,p[1]),(p[0],p[1]-3),(p[0],p[1]-2),(p[0],p[1]-1),(p[0],p[1]+1),(p[0],p[1]+2),(p[0],p[1]+3)]\n    for i in range(len(bakuhu)):\n        if bakuhu[i][0]>0 and bakuhu[i][1] >0 and bakuhu[i][0] <9 and bakuhu[i][1] <9:\n            L.extend(solve(data,bakuhu[i]))\n    return L\n    \nwhile True:\n    try:\n        ndata=eval(input())\n        for i in range(ndata):\n            input()\n            data=[]\n            for j in range(8):\n                data.append(input())\n            x=eval(input())\n            y=eval(input())\n            p=(x,y)\n            L=solve(data,p)\n            while len(L)!=0:\n                x=L.pop(0)\n                y=L.pop(0)\n                data[y-1]=data[y-1][:x-1]+'0'+data[y-1][x:]\n            print(\"Data \"+str(i+1)+':')\n            for i in range(len(data)):\n                print(data[i])\n    except:\n        break"
  },
  {
    "problem_id": "p00072",
    "problem_statement": "Stone Lanterns\n\nAizu-Wakamatsu City is known as a \"historic town\". About 400 years ago, the framework of a castle town was created by Uesugi Shigeharu, but it later developed as the central city of the Aizu domain with 230,000 koku, led by the half-brother of the third shogun Tokugawa Iemitsu, \"Hōjō Masayuki\" . Because there are still historical sites and remnants of the old days throughout the city, many tourists visit from all over the country every year.\n\n\nThis year, due to the broadcast of the NHK Taiga Drama \"Shinsengumi!\", the number of tourists has increased significantly as a place related to the Shinsengumi (*1). Therefore, the city decided to set up lanterns at intervals of 100 meters along the streets that connect historical sites scattered throughout the city and decorate them. The condition is to install them so that you can reach all the historical sites in the city by following the street decorated with lanterns, but you do not need to be able to trace them in one stroke. However, since the budget is limited, it is necessary to minimize the number of lanterns to be installed.\n\n\n\n\n\n\n(*1) The Shinsengumi was launched in the form of an Aizu domain guardian, and participated in the Aizu-Boshin War, known for the tragedy of the White Tiger Corps. Hijikata Toshizo built the grave of Kondo Isami in Tennen-ji Temple in the city.\n\nInput\n\nMultiple datasets are given. Each dataset is given in the following format.\n\n\nn\nm\na1,b1,d1\na2,b2,d2\n:\nam,bm,dm\n\n\nThe first line of each dataset gives the number of historical sites n. Following it, the number of streets that connect historical sites m is given. m lines follow, each containing three numbers separated by commas: ai, bi, and di. ai and bi are the numbers of historical sites. Historical site numbers are assigned from 0 to n - 1. ai bi indicates that there is a street connecting them, and di represents the distance of the road between ai and bi.\n\n\nThe input ends when n is 0. The number of datasets is no more than 20.\n\nOutput\n\nFor each dataset, output the minimum number of lanterns required in one line.\n\nSample Input\n\n4\n4\n0,1,1500\n0,2,2000\n1,2,600\n1,3,500\n0\n\nOutput for the Sample Input\n\n23\n",
    "buggy": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n\"\"\"\nimport sys\nfrom enum import Enum\n\n\nclass Mst(object):\n    \"\"\" minimum spanning tree \"\"\"\n    INFINITY = 999999999\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, nodes, data):\n        self.num_of_pathes = len(data)\n\n        self.color = [Mst.Status.white] * nodes  # ????????????????¨??????¶???\n        self.M = self._make_matrix(nodes, data)\n        self.d = [Mst.INFINITY] * nodes  #\n        self.p = [-1] * nodes  # ????????????????????????????¨??????????\n\n    def _make_matrix(self, nodes, data):\n        \"\"\" ??£??\\???????????????????????\\?¶?(-1)????????????????????§(Mst.INFINITY)????????´?????? \"\"\"\n        m = [[Mst.INFINITY] * nodes for _ in range(nodes)]\n        for d in data:\n            m[d[0]][d[1]] = d[2]\n            m[d[1]][d[0]] = d[2]\n        return m\n\n    def inf_or_num(self, n):\n        if n == -1:\n            return Mst.INFINITY\n        else:\n            return n\n\n    def prim(self):\n        \"\"\" ??????????????¢?????´?????????????????¨??????????°???¨?????¨????§?????????? \"\"\"\n        self.d[0] = 0  # ??????????????§d[i]???INFINITY??\\???????????£???????????????d[0]??????????????§???d[0]??????????´¢???????§????????????¨?????????\n        self.p[0] = -1  # d[0]?????????????????§????????????????????????\n\n        while True:\n            mincost = Mst.INFINITY\n            for i in range(len(self.d)-1):  # V-T????±??????????????????????????????§????????????????°???????????????????\n                if self.color[i] != Mst.Status.black and self.d[i] < mincost:\n                    mincost = self.d[i]\n                    u = i  # ?????????????????????????????????????????\\???u??§??¢???????????????\n\n            if mincost == Mst.INFINITY:  # ??¨??????V-T??????????????????????????¨????????§while???????????????\n                break\n\n            self.color[u] = Mst.Status.black  # ?????????u???T????±?????????´?????¶?????´??°\n            for v in range(len(self.d)):  # v????????????????????????\n                if self.color[v] != Mst.Status.black and self.M[u][v] != Mst.INFINITY:  # v???V-T??´ ?????? u??¨v?????????????????????\n                    if self.M[u][v] < self.d[v]:  # ????????? u-v?????\\?¶?????????????????????????????????´???\n                        self.d[v] = self.M[u][v]  # v??????????°???????????????±?????´??°\n                        self.p[v] = u  # u???v??????????????¨????????????\n                        self.color[v] = Mst.Status.gray\n\n        # ????°???¨?????¨????????????????????????????¨????\n        results = []\n        for i in range(len(self.p)):\n            if self.p[i] != -1:\n                results.append(self.M[i][self.p[i]]/100 - 1)\n        return int(sum(results))\n\n\n\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        m = int(input())\n        pathes = []\n        for _ in range(m):\n            pathes.append([int(x) for x in input().split(',')])\n        s = Mst(n, pathes)\n        result = s.prim()\n        print(result)\n\n\n\n    # n = 4\n    # pathes = [[0, 1, 1500], [0, 2, 2000], [1, 2, 600], [1, 3, 500]]\n    # s = Mst(n, pathes)\n    # result = s.prim()\n    # print(result)\n\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])",
    "fixed": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n\"\"\"\nimport sys\nfrom enum import Enum\n\n\nclass Mst(object):\n    \"\"\" minimum spanning tree \"\"\"\n    INFINITY = 999999999\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, nodes, data):\n        self.num_of_pathes = len(data)\n        self.color = [Mst.Status.white] * nodes  # ????????????????¨??????¶???\n        self.M = self._make_matrix(nodes, data)\n        self.d = [Mst.INFINITY] * nodes  #\n        self.p = [-1] * nodes  # ????????????????????????????¨??????????\n\n    def _make_matrix(self, nodes, data):\n        \"\"\" ??£??\\???????????????????????\\?¶?(-1)????????????????????§(Mst.INFINITY)????????´?????? \"\"\"\n        m = [[Mst.INFINITY] * nodes for _ in range(nodes)]\n        for d in data:\n            m[d[0]][d[1]] = d[2]\n            m[d[1]][d[0]] = d[2]\n        return m\n\n\n    def prim(self):\n        \"\"\" ??????????????¢?????´?????????????????¨??????????°???¨?????¨????§?????????? \"\"\"\n        self.d[0] = 0  # ??????????????§d[i]???INFINITY??\\???????????£???????????????d[0]??????????????§???d[0]??????????´¢???????§????????????¨?????????\n        self.p[0] = -1  # d[0]?????????????????§????????????????????????\n\n        while True:\n            mincost = Mst.INFINITY\n            for i in range(len(self.d)):  # V-T????±??????????????????????????????§????????????????°???????????????????\n                if self.color[i] != Mst.Status.black and self.d[i] < mincost:\n                    mincost = self.d[i]\n                    u = i  # ?????????????????????????????????????????\\???u??§??¢???????????????\n\n            if mincost == Mst.INFINITY:  # ??¨??????V-T??????????????????????????¨????????§while???????????????\n                break\n\n            self.color[u] = Mst.Status.black  # ?????????u???T????±?????????´?????¶?????´??°\n            for v in range(len(self.d)):  # v????????????????????????\n                if self.color[v] != Mst.Status.black and self.M[u][v] != Mst.INFINITY:  # v???V-T??´ ?????? u??¨v?????????????????????\n                    if self.M[u][v] < self.d[v]:  # ????????? u-v?????\\?¶?????????????????????????????????´???\n                        self.d[v] = self.M[u][v]  # v??????????°???????????????±?????´??°\n                        self.p[v] = u  # u???v??????????????¨????????????\n                        self.color[v] = Mst.Status.gray\n\n        # ????°???¨?????¨????????????????????????????¨????\n        results = []\n        for i in range(len(self.p)):\n            if self.p[i] != -1:\n                results.append(self.M[i][self.p[i]]/100 - 1)\n        return int(sum(results))\n\n\n\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        m = int(input())\n        pathes = []\n        for _ in range(m):\n            pathes.append([int(x) for x in input().split(',')])\n        s = Mst(n, pathes)\n        result = s.prim()\n        print(result)\n\n\n\n    # n = 4\n    # pathes = [[0, 1, 1500], [0, 2, 2000], [1, 2, 600], [1, 3, 500]]\n    # s = Mst(n, pathes)\n    # result = s.prim()\n    # print(result)\n\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "problem_id": "p00074",
    "problem_statement": "Video Tapes\nThere is a 120-minute video tape for standard recording. Rewind the tape completely, set the counter of the video deck to 00:00:00, and record in standard recording mode until a certain counter value is reached. Create a program that inputs this counter value (hours, minutes, seconds), calculates the remaining length of the tape (recordable time), and outputs it in the format of hours:minutes:seconds.\nHowever, the input is within 2 hours (120 minutes). Calculate the remaining tape length for both standard recording mode and 3 times recording mode, and output the hours, minutes, and seconds in 2 digits each, as shown in the output example. If the tens digit is 0, such as \"05\", please add \"0\".\nInput\nMultiple data sets are given. Each dataset is as follows.\n\nT H S\n\n\nT, H, S are integers representing hours, minutes, and seconds, respectively.\n\n\nWhen T, H, and S are all -1, the end of the input is reached. The number of datasets is no more than 50.\n\nOutput\nFor each dataset, output the following:\nOn the first line, the remaining recordable time of the tape when recorded in standard recording mode, separated by a half-width colon.\nOn the second line, the remaining recordable time of the tape when recorded in 3 times recording mode, separated by a half-width colon.\n\nSample Input\n\n1 30 0\n-1 -1 -1\n\nOutput for the Sample Input\n\n00:30:00\n01:30:00\n",
    "buggy": "def zan(total, flag):\n    rest = 7200 - total if flag else 7200 - total // 3\n    t, rest = divmod(rest, 3600)\n    h, s = divmod(rest, 60)\n    print(\"{0:02d}:{1:02d}:{2:02d}\".format(t, h, s))\n\nwhile True:\n    T, H, S = map(int, input().split())\n    if T == -1:\n        break\n    total = T * 3600 + H * 60 + S\n    for i in [1, 0]:\n        zan(total, i)",
    "fixed": "def zan(total, flag):\n    rest = 7200 - total if flag else (7200 - total) * 3\n    t, rest = divmod(rest, 3600)\n    h, s = divmod(rest, 60)\n    print(\"{0:02d}:{1:02d}:{2:02d}\".format(t, h, s))\n\nwhile True:\n    T, H, S = map(int, input().split())\n    if T == -1:\n        break\n    total = T * 3600 + H * 60 + S\n    for i in [1, 0]:\n        zan(total, i)"
  },
  {
    "problem_id": "p00075",
    "problem_statement": "BMI\n\nObesity is listed as a cause of many adult illnesses. In the past, with a few exceptions, it was something that high school students were not concerned about. However, it has become unrealistic for them to become physically inactive due to excessive studying, or to develop overeating disorders due to stress. It may become a problem that high school students need to be sufficiently concerned about.\n\n\nTherefore, you have been asked to create a program that finds students suspected of being obese from student data as an assistant to the school nurse.\n\n\nThe method is to calculate a numerical value called BMI (Body Mass Index). BMI is given by the following formula.\n\n\n\n\n\n\nBMI = 22 is standard, and a BMI of 25 or higher is suspected of being obese.\n\n\nCreate a program that calculates the BMI from the weight and height information of each student and outputs the student ID of the students with a BMI of 25 or higher.\n\nInput\n\nThe input is given in the following format.\n\n\ns1,w1,h1\ns2,w2,h2\n...\n...\n\n\nsi (1 ≤ si ≤ 2,000), wi (1 ≤ wi ≤ 200), and hi (1.0 ≤ hi ≤ 2.0) represent the student ID (integer), weight (real number), and height (real number) of the i-th student, respectively.\n\n\nThe number of students is no more than 50.\n\nOutput\n\nOutput the student ID of the students with a BMI of 25 or higher, one per line, in the order of input.\n\nSample Input\n\n1001,50.0,1.60 \n1002,60.0,1.70 \n1003,70.0,1.80 \n1004,80.0,1.70 \n1005,90.0,1.60 \n\nOutput for the Sample Input\n\n1004\n1005 \n",
    "buggy": "try:\n    s, w, h = map(float, input().split(','))\n    if w / h**2 >= 25:\n        print(int(s))\nexcept:\n    pass",
    "fixed": "try:\n    while True: \n        s, w, h = map(float, input().split(','))\n        if w / h**2 >= 25:\n            print(int(s))\nexcept:\n    pass"
  },
  {
    "problem_id": "p00076",
    "problem_statement": "Treasure Hunt II\nWhile cleaning up the warehouse, you found an old document that describes the location of your ancestors' treasure. The document reads something like this:\n\n1. First, stand 1 meter east of the well on the outskirts of town and face straight towards the well.\n2. Turn 90 degrees to the right and walk 1 meter straight ahead, then face straight towards the well.\n3. Turn 90 degrees to the right and walk 1 meter straight ahead, then face straight towards the well.\n4.                   〃\n5.                   〃\n6.                   ：\n\nLines 2 and later are exactly the same. You wanted to look for the treasure, but you realized a problem. Unlike in the past, buildings now obstruct the way and you cannot see the well even if you face straight ahead, or you cannot walk straight ahead even if you want to. Furthermore, this old document is almost 1,000 lines long, and it takes a considerable amount of time and physical strength to follow the instructions in the document. Fortunately, you can use a computer.\nCreate a program that takes as input the number n of lines written in the old document and outputs the location of the treasure. However, n will be a positive integer between 2 and 1,000.\nInput\nMultiple data sets are given. As a dataset, an integer n representing the number of lines in the old document is given on one line.\nThe input ends with -1. The number of datasets does not exceed 50.\nOutput\nAssuming that the treasure is located at a position x (m) to the east and y (m) to the north of the well on the outskirts of town, output in the following format for each dataset:\n\nx\ny\n\nThe output should be a real number, and may include errors of 0.01 or less.\nSample Input\n\n3\n6\n-1\n\nOutput for the Sample Input\n\n0.29 \n1.71\n-2.31 \n0.80\n\nReference\nPositions of the treasure for n = 2, 3, 4, 5, and 6\n",
    "buggy": "import math\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    r, theta = math.sqrt(2.0), pi/4.0\n    for i in range(1,n-1):\n        r = math.sqrt(r**2 + 1.0)\n        theta += math.asin(1.0/r)\n    print(r*math.cos(theta))\n    print(r*math.sin(theta))",
    "fixed": "import math\n\nwhile True:\n    n = int(input())\n    if n == -1:\n        break\n    r, theta = 1.0, 0.0\n    for i in range(n-1):\n        r = math.sqrt(r**2 + 1.0)\n        theta += math.asin(1.0/r)\n    print(r*math.cos(theta))\n    print(r*math.sin(theta))"
  },
  {
    "problem_id": "p00079",
    "problem_statement": "Area of Convex Polygon\n\nCreate a program that reads the coordinates of the vertices of a convex polygon (a polygon whose interior angles are all less than 180 degrees, in other words, a non-concave polygon) and outputs its area. The vertices are named vertex 1, vertex 2, vertex 3, ..., vertex n in the order of the edges.\n\n\nHowever, assume that n is between 3 and 20. Also, you may use the following formula to calculate the area S from the lengths of the sides a, b, c of a triangle.\n\n\n\n\n\nInput\n\nThe input is given in the following format.\n\n\nx1,y1\nx2,y2\n:\nxn,yn\n\n\nxi and yi are real numbers representing the x and y coordinates of vertex i, respectively.\n\nOutput\n\nOutput the area S (real number) on one line.\nThe output may contain an error of 0.000001 or less.\n\nSample Input\n\n0.0,0.0\n0.0,1.0 \n1.0,1.0 \n2.0,0.0 \n1.0,-1.0 \n\nOutput for the Sample Input\n\n2.500000\n",
    "buggy": "import sys\ns=0\np=[list(map(float,e.split(',')))for e in sys.stdin]\nx,y=p[0]\nfor i in range(len(p)-2):\n a,b=p[i+1];c,d=p[i+2]\n s-=((a-x)*(d-y)-(b-y)*(c-x))/2\nprint(s)\n",
    "fixed": "import sys\ns=0\np=[list(map(float,e.split(',')))for e in sys.stdin]\nx,y=p[0]\nfor i in range(len(p)-2):\n a,b=p[i+1];c,d=p[i+2]\n s+=((a-x)*(d-y)-(b-y)*(c-x))/2\nprint(abs(s))\n"
  },
  {
    "problem_id": "p00080",
    "problem_statement": "Cubic Root\n\nThe solution to $x^3 = q$ can be approximated by calculating the recursive formula $x_{n+1} = x_n - \\frac{x_{n}^3 - q}{3x_{n}^2}$, and repeating the calculation for $x_2 = x_1 - \\frac{x_{1}^3 - q}{3x_{1}^2}$, $x_3 = x_2 - \\frac{x_{2}^3 - q}{3x_{2}^2}$, and so on.\n\nWhile doing this calculation, if the value of $|x^3 - q|$ becomes sufficiently small, stop the calculation and take the last calculated $x_n$ as an approximate solution to $x^3 = q$.\n\nFollowing this method, create a program that outputs an approximation of the cubic root of the positive integer $q$ entered. However, use the judgment \"$|x^3 - q| < 0.00001 q$\" to determine when it has become \"sufficiently small.\"\n\nInput\nMultiple datasets are given. One line contains a positive integer $q$ ($1 \\leq q < 2^{31}$) (an integer) for each dataset. The end of the input is -1.\n\n\nThe number of datasets does not exceed 50.\n\nOutput\nFor each dataset, output $x$ (real number) on one line. The output may contain errors of 0.00001 or less.\n\nSample Input\n\n15\n15\n-1\n\nOutput for the Sample Input\n\n2.466212\n2.466212\n",
    "buggy": "def third_root(q):\n    x=q/2.0\n    while abs(x**3-q)>=q*10**(-5):\n        x=x-(x**3-q)/(3*x**2)\n    return x\nwhile 1:\n    q=input()\n    if q==-1:break\n    ans=third_root(q)\n    print(ans)",
    "fixed": "def third_root(q):\n    x=q/2.0\n    while abs(x**3-q)>=q*10**(-5):\n        x=x-(x**3-q)/(3*x**2)\n    return x\nwhile True:\n    q=int(input())\n    if q==-1:break\n    ans=third_root(q)\n    print(ans)"
  },
  {
    "problem_id": "p00081",
    "problem_statement": "Symmetry\n\nWrite a program that reads the coordinates of three different points P1(x1,y1), P2(x2,y2), and Q(xq,yq) on a plane, and outputs the coordinates of the point R(x,y) which is symmetric to the point Q with respect to the straight line passing through points P1 and P2. It is guaranteed that the point Q is not on the symmetry axis.\n\n\n\n\nInput\n\nThe input consists of multiple datasets. Each dataset is given in the following format:\n\n\nx1,y1,x2,y2,xq,yq\n\n\nEach line consists of six real numbers separated by commas: x1, y1, x2, y2, xq, and yq (-100 ≤ x1, y1, x2, y2, xq, yq ≤ 100).\n\n\nThe number of datasets is not more than 50.\n\nOutput\n\nFor each dataset, output the coordinates x and y of R separated by a space in a line. The output can have an error of at most 0.0001.\n\nSample Input\n\n1.0,0.0,-1.0,0.0,1.0,1.0 \n1.0,0.0,0.0,-1.0,3.0,0.0 \n0.0,1.0,0.0,-1.0,1.0,1.0 \n\nOutput for the Sample Input\n\n1.000000 -1.000000\n1.000000 2.000000\n-1.000000 1.000000\n",
    "buggy": "import sys\nfrom math import*\nfor e in sys.stdin:\n a,b,c,d,x,y=map(float,e.split(','))\n g=-2*(atan2(x-b,y-a)-atan2(d-b,c-a));s,t=sin(g),cos(g);x-=a;y-=b\n print(f'{t*x-s*y+a:.6f} {s*x+t*y+b:.6f}')\n",
    "fixed": "import sys\nfrom math import*\nfor e in sys.stdin:\n a,b,c,d,x,y=map(float,e.split(','))\n g=-2*(atan2(y-b,x-a)-atan2(d-b,c-a));s,t=sin(g),cos(g);x-=a;y-=b\n print(f'{t*x-s*y+a:.6f} {s*x+t*y+b:.6f}')\n"
  },
  {
    "problem_id": "p00082",
    "problem_statement": "Merry-go-round\n\n\n\n\nYou may know the merry-go-round in an amusement park. It is a classic play equipment in which vehicles such as horses and carriages are fixed on a large disc, and the vehicles sway up and down as the disc rotates. At a certain amusement park, the merry-go-round is equipped with eight vehicles in the order shown in Figure 1, including two four-person carriages, two two-person cars, and four single-person horses. And the customers who come to the amusement park are waiting at one of the eight boarding places 0 to 7 shown in Figure 1.\n\n\n\n\n\nAt this amusement park, the merry-go-round always stops at a position where the vehicle fits perfectly into the boarding place. Then, each customer waiting at 0 to 7 is supposed to get on the vehicle that has stopped in front of them. It is not possible to hurry to another boarding place and ride from there. In order to efficiently satisfy customers, the stopping position of the merry-go-round must be adjusted well to minimize the number of customers who cannot ride.\n\n\nCreate a program that reads the number of customers waiting at each of the eight boarding places and outputs the position at which each vehicle should be stopped so that the number of customers who cannot ride is minimized.\n\n\nInput\n\nThe input consists of multiple datasets. Each dataset is given in the following format.\n\n\np0 p1 p2 p3 p4 p5 p6 p7\n\n\nAn integer pi (0 ≤ pi ≤ 10,000) representing the number of customers waiting at boarding place 0, 1, ..., 7 is given in a single line separated by spaces.\n\nOutput\n\nLet 4 represent a horse-drawn carriage, 2 represent a car, and 1 represent a horse. The vehicles stopped at boarding places 0, 1, ..., 7 are represented by c0, c1, ..., c7. For each dataset, output c0, c1, ..., c7 separated by spaces on one line.\n\n\nIf there are multiple ways to stop the vehicle so that the number of customers who cannot ride is minimized, assume c0c1c2c3c4c5c6c7 is an 8-digit integer V, and choose the way that minimizes V.\n\n\nThe number of datasets is no more than 100.\n\nSample Input\n\n2 3 1 4 0 1 0 1 \n4 2 3 2 2 2 1 1 \n\nOutput for the Sample Input\n\n1 4 1 4 1 2 1 2 \n4 1 4 1 2 1 2 1\n",
    "buggy": "def comp(lst1, lst2):\n  for v1, v2 in zip(lst1, lst2):\n    if v1 < v2:\n      return False\n    if v1 > v2:\n      return True\n\n  return False\n\nwhile True:\n  try:\n    plst = list(map(int, input().split()))\n    \n    horse = [4, 1, 4, 1, 2, 1, 2, 1]\n    min_num = 100000\n    min_horse = horse[:]\n    \n    for _ in range(8):\n      #乗車不能人数\n      num = sum([max(0, plst[j] - horse[j]) for j in range(8)])\n      \n      #人数が最小値と等しく、並びの数値が小さければ更新\n      if num == min_num and min_horse > horse:\n        min_hose = horse[:]\n      \n      #人数が最小値より小さければ更新\n      elif num < min_num:\n        min_num = num\n        min_horse = horse[:]\n      \n      #馬を回転\n      horse.append(horse.pop(0))\n\n    print(\" \".join(map(str, min_horse)))\n\n  except EOFError:\n    break\n",
    "fixed": "def comp(lst1, lst2):\n  for v1, v2 in zip(lst1, lst2):\n    if v1 < v2:\n      return False\n    if v1 > v2:\n      return True\n\n  return False\n\nwhile True:\n  try:\n    plst = list(map(int, input().split()))\n    \n    horse = [4, 1, 4, 1, 2, 1, 2, 1]\n    min_num = 100000\n    min_horse = horse[:]\n    \n    for _ in range(8):\n      #乗車不能人数\n      num = sum([max(0, plst[j] - horse[j]) for j in range(8)])\n      \n      #人数が最小値と等しく、並びの数値が小さければ更新\n      if num == min_num and comp(min_horse, horse):\n        min_horse = horse[:]\n      \n      #人数が最小値より小さければ更新\n      elif num < min_num:\n        min_num = num\n        min_horse = horse[:]\n      \n      #馬を回転\n      horse.append(horse.pop(0))\n\n    print(\" \".join(map(str, min_horse)))\n\n  except EOFError:\n    break\n"
  },
  {
    "problem_id": "p00083",
    "problem_statement": "AD to Japanese Era Conversion\n\nCreate a program that converts a date in AD to a date in Japanese era using the corresponding era name, and outputs the converted date. The input consists of three integers as shown in the example, in order of year, month and day. Convert it as shown in the output example. If a date before the Meiji era is entered, display \"pre-meiji\".\n\n\nThe first year of each era should be output as \"1 year\", not \"Gannen\".\n\n\n\nEraPeriod\nMeijiSeptember 8, 1868 to July 29, 1912\nTaishoJuly 30, 1912 to December 24, 1926\nShowaDecember 25, 1926 to January 7, 1989\nHeiseiJanuary 8, 1989 to present\n\n\n\nInput\n\nMultiple data sets will be given. Three integers representing the year, month, and day are given on one line separated by spaces for each data set.\n\n\nPlease process until the end of the input. The number of data sets is no more than 50.\n\nOutput\n\nOutput the era name, year, month, and day separated by spaces, or \"pre-meiji\" on one line.\n\nSample Input\n\n2005 9 3\n1868 12 2\n1868 9 7\n\nOutput for the Sample Input\n\nHeisei 17 9 3\nMeiji 1 12 2\npre-meiji\n",
    "buggy": "def solve(y,m,d):\n\tif y<1868 or (y==1868 and m<9) or (y==1868 and m==9 and d<8):\n\t\tprint(\"pre-meiji\")\n\telif 1868<y<1912 or (y==1868 and 7<m) or (y==1868 and m==9 and 8<=d) or (y==1912 and m<7) or(y==1912 and m==7 and d<=29):\n\t\tprint(\"meiji %d %d %d\"%(y-1868+1,m,d))\n\telif 1912<y<1926 or (y==1912 and 7<m) or (y==1912 and m==7 and 25<=d) or (y==1926 and m<12) or (y==1926 and m==12 and d<=24):\n\t\tprint(\"taisho %d %d %d\"%(y-1912+1,m,d))\n\telif 1926<y<1989 or (y==1926 and 12<m) or (y==1926 and m==12 and 25<=d) or (y==1989 and m<1) or (y==1989 and m==1 and d<=7):\n\t\tprint(\"showa %d %d %d\"%(y-1026+1,m,d))\t\n\telse:\n\t\tprint(\"heisei %d %d %d\"%(y-1989+1,m,d))\n\n\nwhile True:\n\ttry:\n\t\ty,m,d=map(int,input().split())\n\t\tsolve(y,m,d)\n\texcept EOFError:\n\t\tbreak",
    "fixed": "def solve(y,m,d):\n\tif y<1868 or (y==1868 and m<9) or (y==1868 and m==9 and d<8):\n\t\tprint(\"pre-meiji\")\n\telif 1868<y<1912 or (y==1868 and 9<m) or (y==1868 and m==9 and 8<=d) or (y==1912 and m<7) or(y==1912 and m==7 and d<=29):\n\t\tprint(\"meiji %d %d %d\"%(y-1868+1,m,d))\n\telif 1912<y<1926 or (y==1912 and 7<m) or (y==1912 and m==7 and 30<=d) or (y==1926 and m<12) or (y==1926 and m==12 and d<=24):\n\t\tprint(\"taisho %d %d %d\"%(y-1912+1,m,d))\n\telif 1926<y<1989 or (y==1926 and 12<m) or (y==1926 and m==12 and 25<=d) or (y==1989 and m<1) or (y==1989 and m==1 and d<=7):\n\t\tprint(\"showa %d %d %d\"%(y-1926+1,m,d))\t\n\telse:\n\t\tprint(\"heisei %d %d %d\"%(y-1989+1,m,d))\n\n\nwhile True:\n\ttry:\n\t\ty,m,d=map(int,input().split())\n\t\tsolve(y,m,d)\n\texcept EOFError:\n\t\tbreak"
  },
  {
    "problem_id": "p00085",
    "problem_statement": "Joseph's Potato\n\n\n\n\n\nOnce upon a time, there was a game called Joseph's Potato. Suppose n people are participating. The participants form a circle facing the center, and are numbered in order from 1. A hot potato is passed to participant n (the large number 30 inside the left figure). The participant who receives the potato passes it to the person on their right. The person who receives the potato for the m-th time passes it to the person on their right and leaves the circle (the left figure shows the case where m = 9). One person leaves the circle with each pass of the potato, and the last person remaining is the winner and receives the potato.\n\n\nIt would be nice to know where to stand before starting to pass the potato, once n and m are determined. The figure above shows the case where 30 participants play the game with the rule of leaving the circle every 9 people. The large numbers inside the circle are the numbers assigned to the participants, and the small numbers outside the circle indicate the order of leaving. According to this, the participants numbered 9, 18, 27, 6, 16, and 26 leave the circle in that order, and the winner is 21 (the small number is 30).\n\n\nCreate a program that inputs the number of participants n and the distance between participants leaving the circle m, and outputs the winner's number. Assume that m, n < 1000.\n\nInput\n\nMultiple datasets are provided. Each dataset is given in the following format.\n\n\nn m\n\n\nThe number of participants n (an integer) and the distance between participants leaving the circle m (an integer) are given on one line separated by a space.\n\n\nThe input ends with two 0s. The number of datasets is no more than 50.\n\nOutput\n\nFor each dataset, output the number of the winner who receives the potato on one line (an integer).\n\nSample Input\n\n41 3\n30 9\n0 0\n\nOutput for the Sample Input\n\n31\n21\n",
    "buggy": "while True:\n  n,m = input().split()\n  n = int(n)\n  m = int(m)\n  if n==m==0:\n    break\n  l = [i for i in range(n)]\n  c = 0\n  while len(l) >= 2:\n    c = (c+m)%len(l)\n    l.pop(c)\n    c -= 1\n  print(l[0])",
    "fixed": "while True:\n  n,m = input().split()\n  n = int(n)\n  m = int(m)\n  if n==m==0:\n    break\n  l = [i for i in range(n)]\n  c = -1\n  while len(l) >= 2:\n    c = (c+m)%len(l)\n    l.pop(c)\n    c -= 1\n  print(l[0]+1)"
  },
  {
    "problem_id": "p00086",
    "problem_statement": "Patrol\n\nIn 1862, during the Bunkyu era, the lord of Aizu was appointed as the Kyoto Shugo-shoku. The Kyoto Shugo-shoku had the important role of protecting Kyoto, which had seen a deterioration in public safety during the late Edo period. The lord and his retainers had to patrol the city in collaboration with the shogunate and other clans. However, when it came time to decide on the patrol route, a famous stubborn retainer made the following request:\n\n\n\n\n\n\nThis was a serious matter. Even the lord could not ignore the retainer's demands. Depending on the choice of patrol route, it could be said that \"the honor of the samurai is at stake.\"\n\n\nTherefore, please create a program that determines whether the following three conditions are met based on the input of the starting point, the goal point, and the intersection points, and present it to the lord.\n\n\nThe starting point is represented by 1, the goal point by 2, and the other intersections by integers greater than 3. A road is represented by a pair of intersection numbers that it connects. The number of intersections is assumed to be 100 or less, and it is assumed that there is at least one path from each intersection to the starting point and the goal point.\n\nInput\nMultiple datasets are given. Each dataset is in the following format.\n\na1 b1\na2 b2\n：\n：\n0 0\n\n\nTwo integers in each line indicate the existence of a road connecting intersection ai and intersection bi. When both ai and bi are 0, it indicates the end of the input of intersection information.\n\n\nThe number of datasets is no more than 50.\n\nOutput\n\nFor each dataset, output \"OK\" if the honor of the samurai is maintained (that is, if all three conditions are met), and \"NG\" otherwise (if any of the three conditions are not met).\n\nSample Input\n\n1 3\n3 4\n3 5\n3 6\n4 6\n4 7\n4 7\n5 6\n6 7\n5 8\n5 8\n6 8\n6 9\n7 9\n8 9\n9 2\n0 0\n1 3\n3 4\n3 4\n4 2\n0 0\n\nOutput for the Sample Input\n\nOK\nNG\n\n\n\n",
    "buggy": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n    isBool = True\n    for node in node_list:\n        for dic_key, dic_value in node.items():\n            if dic_key != 1 and dic_key != 2:\n                if dic_value % 2 != 0:\n                    isBool = False\n                    break\n            else :\n                if dic_value % 2 == 0:\n                    isBool = False\n                    break\n        if isBool :\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n\n    is_half_euler_graph(count_lists)\n",
    "fixed": "import sys\nfrom collections import defaultdict\ndata_list = []\n\nfor line in sys.stdin:\n    data_list.append(list(map(int, line.split())))\n\ndef is_half_euler_graph(node_list):\n    for node in node_list:\n        isBool = True\n        for dic_key, dic_value in node.items():\n            if dic_key != 1 and dic_key != 2:\n                if dic_value % 2 != 0:\n                    isBool = False\n                    break\n            else :\n                if dic_value % 2 == 0:\n                    isBool = False\n                    break\n        if isBool :\n            print(\"OK\")\n        else :\n            print(\"NG\")\n\n\n\nif __name__ == '__main__' :\n    node_data_lists = []\n    tmp_list = []\n    count_lists = []\n    tmp_dic = {}\n    tmp_dic = defaultdict(int)\n\n    for i in range(0, len(data_list)):\n        if data_list[i][0] == 0 and data_list[i][1] == 0:\n            node_data_lists.append(tmp_list[:])\n            tmp_list.clear()\n        else :\n            tmp_list.append(data_list[i])\n\n    for node_data_list in node_data_lists :\n        tmp_dic.clear()\n        for i in range(0, len(node_data_list)):\n            tmp_dic[node_data_list[i][0]] += 1\n            tmp_dic[node_data_list[i][1]] += 1\n\n        count_lists.append(tmp_dic.copy())\n\n    is_half_euler_graph(count_lists)\n"
  },
  {
    "problem_id": "p00087",
    "problem_statement": "Formula for beginners\nDoctor: Peter, I finally did it!\nPeter: What is it this time? What kind of pointless invention did you come up with now?\nDoctor: I came up with a revolutionary method for processing formulas with a computer. Take a look at this table.\n\n\nNormal notationDoctor's \"revolutionary\" notation\n1 + 21 2 +\n3 * 4 + 73 4 * 7 +\n10 / ( 2 - 12 )\t10 2 12 - /\n( 3 - 4 ) * ( 7 + 2 * 3 )3 4 - 7 2 3 * + *\n\n\n\nPeter: Huh?\nDoctor: Hahaha. I guess it's still too complicated for you, a beginner. This is where it gets interesting.\nPeter: Uh, what...?\nDoctor: You know that computers have a data structure called a stack, right? It's the one where you put in things in first and take them out last.\nPeter: Yes, I know, but...\nDoctor: This revolutionary notation uses that stack. For example, in 10 2 12 - /, the processing goes like this:\n\n\nObject10212-/\n ↓↓↓↓2-12↓10/-10\nStack\n\n.\n.\n10\n\n\n\n.\n2\n10\n\n\n\n12\n2\n10\n\n\n\n.\n-10\n10\n\n\n\n.\n.\n-1\n\n\n\n\n\n\n\nDoctor: See? You don't need to worry about parentheses or operator precedence. The word order is \"divide 10 by the result of subtracting 2 from 12.\" It sounds a bit like Japanese, doesn't it? With this revolutionary invention, our research lab is safe and sound. Hahaha.\nPeter: Uh, Doctor? This is something we learned in the basic course at Aizu University when I was in Japan. They called it \"Reverse Polish Notation,\" and everyone in the class could program it easily.\nDoctor: ...\n\nAnd so, Peter had to teach the program to the Doctor. Create a program that takes a formula written in Reverse Polish Notation as input and outputs the result of the calculation.\n\nInput\nMultiple datasets will be given. In each dataset, one line will be given, consisting of a formula written in Reverse Polish Notation (a string of up to 80 characters consisting of integers and operation symbols separated by a single space (half-width) character). No formulas that divide a value by 0 or a value close to 0 will be given.\nThe number of datasets is no more than 50.\nOutput\nFor each dataset, output the result of the calculation (a real number) on one line. The calculation result may include an error of up to 0.00001.\nSample Input\n\n10 2 12 - /\n3 4 - 7 2 3 * + *\n-1 -2 3 + +\n\nOutput for the Sample Input\n\n-1.000000\n-13.000000\n0.000000\n",
    "buggy": "#!/usr/bin/env python3\n\nimport sys\n\n\ndef calc_inverse_polish_notation_string(s):\n    tokens = [token for token in s.split(' ') if token != '']\n    stack = []\n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            val2 = stack.pop()\n            val1 = stack.pop()\n            result = eval(\"%s %s %s\" % (val1, token, val2))\n            stack.append(result)\n        else:\n            stack.append(token)\n\n    return stack[0]  # if len(stack) != 1, it should throw an exception\n\n\ndef main():\n    for line in sys.stdin.readlines():\n        print(calc_inverse_polish_notation_string(line))\n\nif __name__ == \"__main__\":\n    main()",
    "fixed": "import sys\n\n\ndef calc_inverse_polish_notation_string(s):\n    tokens = [token for token in s.split(' ') if token != '']\n    stack = []\n    for token in tokens:\n        if token in ['+', '-', '*', '/']:\n            val2 = stack.pop()\n            val1 = stack.pop()\n            result = eval(\"%s %s %s\" % (val1, token, val2))\n            stack.append(result)\n        else:\n            stack.append(token)\n\n    return stack[0]  # if len(stack) != 1, it should throw an exception\n\n\ndef main():\n    for line in sys.stdin.readlines():\n        print(calc_inverse_polish_notation_string(line.strip()))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "problem_id": "p00090",
    "problem_statement": "Overlap of seals\n\nYou stick n circular seals with radius 1 on a square origami paper of length 10. Seals can be pasted on top of each other. Create a program that reads the coordinates of where the seals are pasted and outputs the number of seals that overlap the most at the location where they overlap the most on the origami paper (even if only one seal overlaps, it is considered \"overlapping\").\n\n\nThe x, y coordinates are given with the origin at the lower left of the origami paper. The seals are pasted with the x, y coordinates as the center of the circle. The center of the circle will not go outside of the origami paper. Additionally, multiple seals will not be pasted on the same coordinate.\n\nInput\n\nMultiple data sets are given. Each dataset is given in the following format.\n\n\nn\nx1,y1\nx2,y2\n:\nxn,yn\n\n\nThe number of seals n (0 ≤ 100) is given on the first line. The center coordinates of each seal are given on the following n lines.\nxi and yi represent the x and y coordinates of the center of the i-th seal, respectively. Each value is given as a real number with up to 6 decimal places.\n\n\nThe input is terminated when n is 0. The number of data sets is no more than 50.\n\nOutput\n\nFor each data set, output the number of seals (an integer) at the location where the most seals overlap on the origami paper.\n\nSample Input\n\n15\n3.14979,8.51743 \n2.39506,3.84915 \n2.68432,5.39095 \n5.61904,9.16332 \n7.85653,4.75593 \n2.84021,5.41511 \n1.79500,8.59211 \n7.55389,8.17604 \n4.70665,4.66125 \n1.63470,4.42538 \n7.34959,4.61981 \n5.09003,8.11122 \n5.24373,1.30066 \n0.13517,1.83659 \n7.57313,1.58150 \n0\n\nOutput for the Sample Input\n\n4\n\nHint\n\nThe figure below shows the seals pasted as in the sample input. The circles represent the seals, and the numbers represent the corresponding input lines.\nAt the point (2.3, 4.6), 4 seals from the 2nd, 3rd, 6th, and 10th lines of the input overlap.\n\n\n\n\n\nWhen two circles are touching (i.e., the distance between the centers is 2), it is considered overlapping.\n",
    "buggy": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\n\nfor s in sys.stdin:\n\n    n = int(s)\n    if n == 0:\n        break\n    P = []\n\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        P.append(complex(x, y))\n\n    def get_intersections(p0, p1):\n        \"\"\"\n        :type p0: complex\n        :type p1: complex\n        :return:\n        \"\"\"\n        dist = abs(p0 - p1)\n\n        if dist > 2:\n            return []\n        elif dist == 2:\n            return [(p0 + p1) / 2]\n        else:\n            m = (p0 + p1) / 2\n            v = m - p0\n            w = complex(v.imag, -v.real)\n            n = w / abs(w)\n            d = abs(v)\n            l = math.sqrt(1 - d ** 2)\n\n            inter0 = m + l * n\n            inter1 = m - l * n\n            return [inter0, inter1]\n\n\n    intersections = []\n    for i in range(n):\n        for j in range(i+1, n):\n            intersections += get_intersections(P[i], P[j])\n\n    counts = []\n\n    # each intersection, it is in how many circles?\n    for intersection in intersections:\n        cnt = 0\n        for p in P:\n            if abs(intersection - p) <= 1:\n                cnt += 1\n        counts.append(cnt)\n\n    if counts:\n        print(max(counts))\n    else:\n        print(0)",
    "fixed": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\n\nfor s in sys.stdin:\n\n    n = int(s)\n    if n == 0:\n        break\n    P = []\n\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        P.append(complex(x, y))\n\n    def get_intersections(p0, p1):\n        \"\"\"\n        :type p0: complex\n        :type p1: complex\n        :return:\n        \"\"\"\n        dist = abs(p0 - p1)\n\n        if dist > 2:\n            return []\n        elif dist == 2:\n            return [(p0 + p1) / 2]\n        else:\n            m = (p0 + p1) / 2\n            v = m - p0\n            w = complex(v.imag, -v.real)\n            n = w / abs(w)\n            d = abs(v)\n            l = math.sqrt(1 - d ** 2)\n\n            inter0 = m + l * n\n            inter1 = m - l * n\n            return [inter0, inter1]\n\n\n    intersections = []\n    for i in range(n):\n        for j in range(i+1, n):\n            intersections += get_intersections(P[i], P[j])\n\n    counts = []\n\n    # each intersection, it is in how many circles?\n    for intersection in intersections:\n        cnt = 0\n        for p in P:\n            if abs(intersection - p) <= 1.01:\n                cnt += 1\n        counts.append(cnt)\n\n    if counts:\n        print(max(counts))\n    else:\n        print(1)"
  },
  {
    "problem_id": "p00091",
    "problem_statement": "Blur\n\nThere is a \"cloth\" of a 10x10 square as shown in Figure 1, and we will use pairs of X-coordinate and Y-coordinate values to indicate the grid. The coordinate values are integers starting from 0. For example, the coordinates of the ◎ in Figure 1 are (1, 2).\nMake a dye little by little on this \"cloth\" to make a dyeing. There are three sizes of droplets, \"large,\" \"medium,\" and \"small,\" that can be dropped with dye, and as shown in Figure 1, the surrounding area is also colored centered on the square where the dye droplet falls. In Figure 1, ☆ is the center and ○ is the range where the color diffuses.\n\n\n\n\n\n\nAt first, the \"cloth\" is \"pure white,\" that is, the value indicating the color density for each square is 0. The value increases by 1 for each droplet of dye that falls. If \"small\" falls on (1, 2) and \"medium\" falls on (3, 2), the value in each square becomes as shown on the left side of Figure 2. The way of dropping the dye so that the range that diffuses as shown on the right side of Figure 2, which protrudes the outside of the cloth, is not allowed because the dye is too precious. Multiple droplets of dye may be dropped in the same place.\n\n\n\n\n\n\nAs a result of repeating this work several times, a wonderful pattern emerged on the cloth, but unfortunately, I forgot to record the work progress carelessly. I can't remember at all, but I barely remembered the number of dye droplets dropped. You must reproduce the wonderful dyeing by reading the dyeing data and creating a program to output where and what size of dye was dropped. The number of dye droplets dropped is assumed to be 12 or less.\n\nInput\n\nThe input format is as follows:\n\n\nThe first line gives the number of dye droplets dropped, n. From the next line, the color density of each coordinate is given in a space-separated manner for 10 lines.\n\nOutput\n\nThe output consists of n lines. Indicate \"large\" for size 3 of the dye droplet, \"medium\" for size 2, and \"small\" for size 1. For each dropped dye, output the X coordinate, Y coordinate, and droplet size separated by spaces on one line.\n\n\nThe order of dropping the dye can be output in any order.\n\nSample Input 1\n\n2\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0\n0 0 1 1 1 0 0 0 0 0\n0 0 0 1 0 0 0 1 1 1\n0 0 0 0 0 0 0 1 1 1\n0 0 0 0 0 0 0 1 1 1\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\nSample Output 1\n\n3 2 1\n8 4 2\n\n\nSample Input 2\n\n6\n0 0 1 0 0 0 0 0 0 0\n0 1 1 1 0 0 0 0 0 0\n1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 0 0\n0 0 1 1 1 3 1 1 0 0\n0 0 1 1 3 1 1 1 0 0\n0 0 1 1 1 1 1 1 1 0\n0 0 1 1 1 1 1 1 1 1\n0 0 0 0 0 0 1 1 1 0\n0 0 0 0 0 0 0 1 0 0\n\nSample Output 2\n\n2 2 3\n7 7 3\n6 3 2\n3 6 2\n4 4 1\n5 5 1\n",
    "buggy": "#!/usr/bin/env python\n# coding: utf-8\n#from sys import stdin\nimport time\n#import itertools,sys\n#import time,copy\n#import math\n#from math import factorial\n#from itertools import product, permutations\n#NUM=\"0123456789\"\n#A2Z=\"abcdefghijklmnopqrstuvwxyz\"\n#import math,sys,time\n#import numpy as np\n\n#from q000 import xxxx\n\n# coding: utf-8\n\n#Q042 Coded triangle numbers\nimport math,sys,time\n\ndef read_data():\n#  f=open('in.txt')\n#  n=int(f.readline())\n  n=eval(input())\n  x=[]\n#  for line in f:\n#    x.append(map(int,line.split()))\n  for i in range(10):\n    x.append(list(map(int,input().split())))\n  return n, x\n\ndef is_area3(x,y):\n  if x>8 or y>6: return False\n  for dx in [0,1,2,1,0]:\n    A = P[y][x-dx:x+dx+1]\n    if A.count(0)>0: return False\n    y += 1\n  return True\n      \ndef is_area2(x,y):\n  if x>7 or y>7: return False\n  for dy in [0,1,2]:\n    A = P[y+dy][x:x+3]\n    if A.count(0)>0: return False\n  return True\n\ndef is_area1(x,y):\n  if x>8 or y>8: return False\n  for dx in [0, 1, 0]:\n    A = P[y][x-dx:x+dx+1]\n    if A.count(0)>0: return False\n    y += 1\n  return True\n\ndef ink(x,y,s,m):\n  global P\n  for dy,dx in [[0,0],[1,0],[-1,0],[0,1],[0,-1]]:\n    P[y+dy][x+dx]+=m\n  if s==1: return\n  for dy,dx in [[1,1],[1,-1],[-1,1],[-1,-1]]:\n    P[y+dy][x+dx]+=m\n  if s==2: return\n  for dy,dx in [[2,0],[-2,0],[0,2],[0,-2]]:\n    P[y+dy][x+dx]+=m\n  return\n\ndrops, P = read_data()\nM=[]\ni=-1\nstep =3\nwhile i<99:\n  i+=1\n  y = i / 10\n  x = i % 10\n  if P[y][x]==0: continue\n#  print\n#  print \"i=\",i\n#  print \"Pi=\",P\n#  print \"Mi=\",M\n\n  if step==3:\n#    print \"step 3\"\n    while is_area3(x,y):\n      M.append([x,y,3])\n      ink(x,y+2,3,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 2\n\n  if step==2:\n#    print \"step 2\"\n    while is_area2(x,y):\n      M.append([x,y,2])\n      ink(x+1,y+1,2,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 1\n\n  if step==1:\n#    print \"step 1\"\n    while is_area1(x,y):\n      M.append([x,y,1])\n      ink(x,y+1,1,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 0\n\n  dx=0\n  dy=1\n  if step==0 and len(M)>0:\n    x,y,tmp = M.pop()\n    if tmp==3: dy=2\n    elif tmp==2: dx=1\n    ink(x+dx,y+dy,tmp,1)\n    i = y*10+x-1\n    step = tmp-1\n  else:\n#    print \"unsolvable\"\n    break\n#  print \"changed io=\",i+1\n#  print \"Mo=\",M\n#  print \"Po=\",P\n#  print\nif len(M)<=12:\n  for x,y,s in M:\n    dx=0\n    dy=1\n    if s==3: dy=2\n    elif s==2: dx=1\n    print(x+dx,y+dy,s)\n\n#start_time = time.clock() \n\n#print time.clock() - start_time, \"seconds\"",
    "fixed": "#!/usr/bin/env python\n# coding: utf-8\n#from sys import stdin\nimport time\n#import itertools,sys\n#import time,copy\n#import math\n#from math import factorial\n#from itertools import product, permutations\n#NUM=\"0123456789\"\n#A2Z=\"abcdefghijklmnopqrstuvwxyz\"\n#import math,sys,time\n#import numpy as np\n\n#from q000 import xxxx\n\n# coding: utf-8\n\n#Q042 Coded triangle numbers\nimport math,sys,time\n\ndef read_data():\n#  f=open('in.txt')\n#  n=int(f.readline())\n  n=eval(input())\n  x=[]\n#  for line in f:\n#    x.append(map(int,line.split()))\n  for i in range(10):\n    x.append(list(map(int,input().split())))\n  return n, x\n\ndef is_area3(x,y):\n  if x>7 or y>5: return False\n  for dx in [0,1,2,1,0]:\n    A = P[y][x-dx:x+dx+1]\n    if A.count(0)>0: return False\n    y += 1\n  return True\n      \ndef is_area2(x,y):\n  if x>7 or y>7: return False\n  for dy in [0,1,2]:\n    A = P[y+dy][x:x+3]\n    if A.count(0)>0: return False\n  return True\n\ndef is_area1(x,y):\n  if x>8 or y>7: return False\n  for dx in [0, 1, 0]:\n    A = P[y][x-dx:x+dx+1]\n    if A.count(0)>0: return False\n    y += 1\n  return True\n\ndef ink(x,y,s,m):\n  global P\n  for dy,dx in [[0,0],[1,0],[-1,0],[0,1],[0,-1]]:\n    P[y+dy][x+dx]+=m\n  if s==1: return\n  for dy,dx in [[1,1],[1,-1],[-1,1],[-1,-1]]:\n    P[y+dy][x+dx]+=m\n  if s==2: return\n  for dy,dx in [[2,0],[-2,0],[0,2],[0,-2]]:\n    P[y+dy][x+dx]+=m\n  return\n\ndrops, P = read_data()\nM=[]\ni=-1\nstep =3\nwhile i<99:\n  i+=1\n  y = i / 10\n  x = i % 10\n  if P[y][x]==0: continue\n#  print\n#  print \"i=\",i\n#  print \"Pi=\",P\n#  print \"Mi=\",M\n\n  if step==3:\n#    print \"step 3\"\n    while is_area3(x,y):\n      M.append([x,y,3])\n      ink(x,y+2,3,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 2\n\n  if step==2:\n#    print \"step 2\"\n    while is_area2(x,y):\n      M.append([x,y,2])\n      ink(x+1,y+1,2,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 1\n\n  if step==1:\n#    print \"step 1\"\n    while is_area1(x,y):\n      M.append([x,y,1])\n      ink(x,y+1,1,-1)\n    if P[y][x]==0:\n      step = 3\n#      print \"Po=\",P\n#      print \"Mo=\",M\n      continue\n    else: step = 0\n\n  dx=0\n  dy=1\n  if step==0 and len(M)>0:\n    x,y,tmp = M.pop()\n    if tmp==3: dy=2\n    elif tmp==2: dx=1\n    ink(x+dx,y+dy,tmp,1)\n    i = y*10+x-1\n    step = tmp-1\n  else:\n#    print \"unsolvable\"\n    break\n#  print \"changed io=\",i+1\n#  print \"Mo=\",M\n#  print \"Po=\",P\n#  print\nif drops <=12 and len(M)==drops:\n  for x,y,s in M:\n    dx=0\n    dy=1\n    if s==3: dy=2\n    elif s==2: dx=1\n    print(x+dx,y+dy,s)\n\n#start_time = time.clock() \n\n#print time.clock() - start_time, \"seconds\""
  },
  {
    "problem_id": "p00092",
    "problem_statement": "Square search\nThere is a n × n grid with n rows and n columns. Some of the squares in the grid have marks on them. Write a program to read the status of each square and output the length of the side of the largest square made up of only unmarked squares.\nFor example, the following data sets are given for each data set:\n\n10\n...*....**\n..........\n**....**..\n........*.\n..*.......\n..........\n.*........\n..........\n....*..***\n.*....*...\n\nEach line of the input data represents one row of the grid. In the input data string, the period (.) represents an unmarked square, and the asterisk (*) represents a marked square.\nIn the above example, the maximum square is shown by 0 in the figure below.\n\n...*....**\n..........\n**....**..\n...00000*.\n..*00000..\n...00000..\n.*.00000..\n...00000..\n....*..***\n.*....*...\n\nTherefore, if you output 5, it will be correct.\nIf all squares have marks, output 0.\nInput\nMultiple data sets are given in the above format. The end of the input is indicated by 0 for n. n is at most 1000. The input data string contains no characters except periods, asterisks, and newlines. There are no more than 50 data sets.\nOutput\nFor each data set, output the length of the largest square (an integer) on one line.\nSample Input\n\n10\n...*....**\n..........\n**....**..\n........*.\n..*.......\n..........\n.*........\n..........\n....*..***\n.*....*...\n10\n****.*****\n*..*.*....\n****.*....\n*....*....\n*....*****\n..........\n****.*****\n*..*...*..\n****...*..\n*..*...*..\n0\n\nOutput for the Sample Input\n\n5\n3\n",
    "buggy": "while True:\n    n=int(input())\n    if n==0:\n        break\n    field=[input() for i in range(n)]\n    large=[[0]*(n+1) for i in range(n+1)]\n    for i in range(n):\n        for j in range(n):\n            if field[i][j]=='.':\n                large[i][j]=min(large[i][j-1],large[i-1][j],large[i-1][i-1])+1\n    print(max(list(map(max,large))))",
    "fixed": "while True:\n    n=int(input())\n    if n==0:\n        break\n    field=[input() for i in range(n)]\n    large=[[0]*(n+1) for i in range(n+1)]\n    for i in range(n):\n        for j in range(n):\n            if field[i][j]=='.':\n                large[i][j]=min(large[i][j-1],large[i-1][j],large[i-1][j-1])+1\n    print(max(list(map(max,large))))"
  },
  {
    "problem_id": "p00093",
    "problem_statement": "Leap Year\n\nCreate a program that outputs all leap years between the years a and b in the Gregorian calendar. The conditions for a leap year are as follows. However, please output \"NA\" if there are no leap years in the given period. Here, assume that 0 < a ≤ b < 3,000.\n\n\n \nThe year is divisible by 4.\n\n \nHowever, years divisible by 100 are not leap years.\n\n \nBut years divisible by 400 are leap years.\n\n\nInput\n\nMultiple datasets are given. The format of each dataset is as follows:\n\n\na b\n\n\nThe end of the input is indicated by a line with two zeros. The number of datasets does not exceed 50.\n\nOutput\n\nOutput the Gregorian calendar year or \"NA\" for each dataset.\n\n\nInsert one blank line between datasets.\n\nSample Input\n\n2001 2010\n2005 2005\n2001 2010\n0 0\n\nOutput for the Sample Input\n\n2004\n2008\n\nNA\n\n2004\n2008\n",
    "buggy": "def isLeap(y):\n    return y % 4 == 0 and (y != 100 or y == 400)\n\nflag2 = False\nwhile True:\n    a,b = map(int,input().split())\n    if a == 0: break\n    if flag2:print()\n    flag2 = True\n\n    flag = True\n    for y in range(a,b + 1):\n        if isLeap(y):\n            print(y)\n            flag = False\n    if(flag):print(\"NA\")",
    "fixed": "def isLeap(y):\n    return y % 4 == 0 and (y % 100 != 0 or y % 400 == 0)\n\nflag2 = False\nwhile True:\n    a,b = map(int,input().split())\n    if a == 0: break\n    if flag2:print()\n    flag2 = True\n\n    flag = True\n    for y in range(a,b + 1):\n        if isLeap(y):\n            print(y)\n            flag = False\n    if(flag):print(\"NA\")"
  },
  {
    "problem_id": "p00094",
    "problem_statement": "Calculation of Tsubo Area\n\nHave you ever heard of a unit of land area called \"tsubo\"? In the old days, it referred to the area of land required to produce enough rice for one samurai to eat in a day.\n\n\nCreate a program that takes the a [m] and b [m] values of a piece of land as input and outputs its tsubo area S [tsubo]. Assume that 1 tsubo = 3.305785 [m2], and that a and b are integers less than or equal to 100.\n\nInput\n\na b\n\n\nTwo integers, a and b, separated by a single space, are given on one line.\n\nOutput\n\nOutput the tsubo area S on one line. An error of no more than 0.0001 is allowed.\n\nSample Input 1\n\n15 25\n\nSample Output 1\n\n113.437508\n",
    "buggy": "a,b = map(float,raw_input().split(' '))\nprint((a * b) / 3.305785)",
    "fixed": "a,b = map(float,input().split(' '))\nprint((a * b) / 3.305785)"
  },
  {
    "problem_id": "p00095",
    "problem_statement": "Ice fishing tournament\n\nAn ice fishing tournament was held at Lake Hikaruhara. The person who caught the most icefish won the tournament.\n\n\nCreate a program that reads a list of participant numbers and the number of fish they caught, and outputs the number and the number of fish caught by the winner. If there are multiple winners, output the one with the smallest participant number. \n\nInput\n\nThe input is given in the following format.\n\n\nn\na1 v1\na2 v2\n: \nan vn\n\n\nn (1 ≤ n ≤ 20) is the number of participants, ai represents the participant number. Participant numbers are different integers between 1 and n. vi (0 ≤ vi ≤ 100) is the number of fish caught by participant ai.\n\nOutput\n\nOutput the participant number and the number of fish caught by the winner on one line separated by a space.\n\nInput Example\n\n6\n1 14\n2 25\n3 42\n4 11\n5 40\n6 37\n\nOutput Example\n\n3 42\n",
    "buggy": "n=eval(input())\na0,v0=n,0\nfor i in range(n):\n  a,v=list(map(int,input().split()))\n  if v>v0: a0,v0=a,v\n  elif v==v0: a0=min(a0,a)\nprint(a,v)",
    "fixed": "n=eval(input())\na0,v0=n,0\nfor i in range(n):\n  a,v=list(map(int,input().split()))\n  if v>v0: a0,v0=a,v\n  elif v==v0: a0=min(a0,a)\nprint(a0,v0)"
  },
  {
    "problem_id": "p00096",
    "problem_statement": "Sum of Four Integers II\nGiven a positive integer n less than or equal to 4,000, find the number of combinations of 0-1000 integers a, b, c, d such that:\n\na + b + c + d = n\n\nOutput the number of combinations for each dataset. Multiple datasets will be given, and the input will end when there is no more data.\nThere will be no more than 50 datasets.\nSample Input\n\n2\n3\n35\n\nOutput for the Sample Input\n\n10\n20\n8436\n",
    "buggy": "n=1001\na=list(range(1,n))\na+=[n]+a[::-1]\nfor n in map(int,sys.stdin):\n  x=0\n  for i in range(max(0,n-2000),min(n,2000)+1):\n    x+=a[i]*a[n-i]\n  print(x)",
    "fixed": "import sys\nn=1001\na=list(range(1,n))\na+=[n]+a[::-1]\nfor n in map(int,sys.stdin):\n  x=0\n  for i in range(max(0,n-2000),min(n,2000)+1):\n    x+=a[i]*a[n-i]\n  print(x)"
  },
  {
    "problem_id": "p00097",
    "problem_statement": "Sum of Integers II\n\nWrite a program that takes n distinct integers between 0 and 100 and outputs the number of combinations that add up to s. Each of the n integers can be between 0 and 100, and the same number cannot be used in one combination. For example, when n is 3 and s is 6, the number of combinations of three numbers that add up to 6 are:\n\n\n1 + 2 + 3 = 6\n0 + 1 + 5 = 6\n0 + 2 + 4 = 6\n\n\nwhich is 3 combinations in total.\n\nInput\n\nMultiple data sets are given. For each data set, n and s are given on one line separated by a single space. (n is an integer between 1 and 9, and s is an integer between 0 and 1000.) When both n and s are 0, the input is terminated.\n\n\nThe number of data sets is no more than 50.\n\nOutput\n\nFor each data set, output the number of combinations of n integers that add up to s on one line.\n\n\nInputs that result in combinations greater than 1010 will not be given.\n\nSample Input\n\n3 6\n3 1\n0 0\n\nOutput for the Sample Input\n\n3\n0\n",
    "buggy": "m=1001\nA=list(range(9))\nd=[[0]*m for i in A]\nfor i in range(101):\n  for j in A[:-1][::-1]:\n    for k in range(m-i): d[j][k+i]+=d[j-1][k]\n  d[0][i]=1\nwhile True:\n  n,s=list(map(int,input().split()))\n  if n==s==0: break\n  print(d[n-1][s])",
    "fixed": "m=1001\nA=list(range(9))\nd=[[0]*m for i in A]\nfor i in range(101):\n  for j in A[1:][::-1]:\n    for k in range(m-i): d[j][k+i]+=d[j-1][k]\n  d[0][i]=1\nwhile True:\n  n,s=list(map(int,input().split()))\n  if n==s==0: break\n  print(d[n-1][s])"
  },
  {
    "problem_id": "p00098",
    "problem_statement": "Maximum Sum Sequence II\n\nGiven a matrix of integers\n\n\na1,1 a1,2 ... a1,n\na2,1 a2,2 ... a2,n\n:\nan,1 an,2 ... an, n\n\n\nCreate a program that outputs the maximum value of the sum of consecutive terms (submatrix) in the vertical and horizontal directions.\n\nInput\n\nThe input data is given in the following format.\n\n\nn\na1,1 a1,2 ... a1,n\na2,1 a2,2 ... a2,n\n:\nan,1 an,2 ... an, n\n\n\nn is between 1 and 100, and ai,j is between -10000 and 10000.\n\n\nOutput\n\nOutput the maximum value on one line.\n\nSample Input 1\n\n3\n1 -2 3\n-4 5 6\n7 8 -9\n\nOutput for the Sample Input 1\n\n16\n\n\nIn this input, the sum of the terms in the following submatrix is maximum.\n\n\n-4 5\n7 8\n\n\nSample Input 2\n\n4\n1 3 -9 2\n2 7 -1 5\n-8 3 2 -1\n5 0 -3 1\n\nOutput for the Sample Input 2\n\n15\n\n\nIn this input, the sum of the terms in the following submatrix is maximum.\n\n\n7 -1 5\n3 2 -1\n",
    "buggy": "def maximum(A,l,m,n):\n    maxint=A[l][m]\n    for i in range(m,n):\n        s=sum(A[l][m:i+1])\n        if i!=m and s<0:break\n        if s<0:continue\n        for j in range(l,n-1):\n            t=sum(A[j+1][m:i+1])\n            if s+t<=0:break\n            s+=t\n            maxint=max(maxint,s)\n    return maxint\n\nn=eval(input())\nA=[list(map(int,input().split())) for i in range(n)]\nmaxint=A[0][0]\nfor i in range(n):\n    for j in range(n):\n        maxint=max(maximum(A,i,j,n),maxint)\nprint(maxint)",
    "fixed": "def maximum(A,l,m,n):\n    maxint=A[l][m]\n    for i in range(m,n):\n        s=sum(A[l][m:i+1])\n        if s<0:continue\n        for j in range(l,n-1):\n            t=sum(A[j+1][m:i+1])\n            if s+t<=0:break\n            s+=t\n            maxint=max(maxint,s)\n    return maxint\n\nn=eval(input())\nA=[list(map(int,input().split())) for i in range(n)]\nmaxint=A[0][0]\nfor i in range(n):\n    for j in range(n):\n        maxint=max(maximum(A,i,j,n),maxint)\nprint(maxint)"
  },
  {
    "problem_id": "p00099",
    "problem_statement": "Ice Fishing Contest 2\n\nAn ice fishing contest was held at Hikarigahara Lake. This time, catch and release is recommended.\n\n\nCreate a program that reads the participant number and the number of fish caught or released for each event in order, and outputs the participant number and the number of fish caught by the participant who has the most fish at hand immediately after each event. If there are multiple participants who have caught the most fish (or if all participants have caught 0 fish), output the one with the smallest participant number.\n\nInput\n\nThe input is given in the following format.\n\n\nn q\na1 v1\na2 v2\n: \naq vq\n\n\nn (1 ≤ n ≤ 1,000,000) represents the number of participants and q (1 ≤ q ≤ 100,000) represents the number of events. ai (1 ≤ ai ≤ n) and vi (-100 ≤ vi ≤ 100) indicate that participant ai caught or released vi fish in the i-th event. A positive value of vi indicates a catch, a negative value indicates a release, and 0 is not given.\n\nOutput\n\nFor each event, output the participant number and the number of fish caught by the participant who has the most fish at hand as one line separated by a space.\n\nInput Example 1\n\n3 5\n1 4 \n2 5 \n1 3\n3 6\n2 7\n\nOutput Example 1\n\n1 4\n2 5\n1 7\n1 7\n2 12\n\nInput Example 2\n\n3 5\n1 4 \n2 5 \n2 -3\n3 4\n1 -1\n\nOutput Example 2\n\n1 4\n2 5\n1 4\n1 4\n3 4\n",
    "buggy": "n, q = [int(el) for el in input().split(' ')]\ndata = [0] * n\nresult, index = 0, 1\nfor _ in range(q):\n    a, v = [int(el) for el in input().split(' ')]\n    data[a-1] += v\n    if v > 0:\n        if result < data[a-1]:\n            result, index = data[a-1], a\n        elif result == data[a-1]:\n            index = min(index, a-1)\n    else:\n        if index == a:\n            result = max(data)\n            index = data.index(result) + 1\n    print(index, result)",
    "fixed": "n, q = [int(el) for el in input().split(' ')]\ndata = [0] * n\nresult, index = 0, 1\nfor _ in range(q):\n    a, v = [int(el) for el in input().split(' ')]\n    data[a-1] += v\n    if v > 0:\n        if result < data[a-1]:\n            result, index = data[a-1], a\n        elif result == data[a-1]:\n            index = min(index, a)\n    else:\n        if index == a:\n            result = max(data)\n            index = data.index(result) + 1\n    print(index, result)"
  },
  {
    "problem_id": "p00101",
    "problem_statement": "\nAizu PR\n\nAn English booklet has been created for publicizing Aizu to the world.\nWhen you read it carefully, you found a misnomer (an error in writing) on the last name of Masayuki Hoshina, the lord of the Aizu domain. The booklet says \"Hoshino\" not \"Hoshina\".\n\n\nYour task is to write a program which replace all the words \"Hoshino\" with \"Hoshina\". You can assume that the number of characters in a text is less than or equal to 1000.\n\nInput\n\nThe input consists of several datasets. There will be the number of datasets n in the first line. There will be n lines. A line consisting of english texts will be given for each dataset.\n\nOutput\n\nFor each dataset, print the converted texts in a line.\n\nSample Input\n\n3\nHoshino\nHashino\nMasayuki Hoshino was the grandson of Ieyasu Tokugawa.\n\nOutput for the Sample Input\n\nHoshina\nHashino\nMasayuki Hoshina was the grandson of Ieyasu Tokugawa.\n\n",
    "buggy": "n=int(input())\nfor i in range(n):\n    print(input().replace(\"Hoshino\",\"hoshina\"))",
    "fixed": "n=int(input())\nfor i in range(n):\n    print(input().replace(\"Hoshino\",\"Hoshina\"))"
  },
  {
    "problem_id": "p00102",
    "problem_statement": "\nMatrix-like Computation\n\nYour task is to develop a tiny little part of spreadsheet software.\n\n\nWrite a program which adds up columns and rows of given table as shown in the following figure:\n\n\n\n\n\n\n\nInput\n\nThe input consists of several datasets. Each dataset consists of:\n\n\nn (the size of row and column of the given table)\n1st row of the table\n2nd row of the table\n :\n :\nnth row of the table\n\n\nThe input ends with a line consisting of a single 0.\n\nOutput\n\nFor each dataset, print the table with sums of rows and columns. Each item of the table should be aligned to the right with a margin for five digits. Please see the sample output for details.\n\nSample Input\n\n4\n52 96 15 20\n86 22 35 45\n45 78 54 36\n16 86 74 55\n4\n52 96 15 20\n86 22 35 45\n45 78 54 36\n16 86 74 55\n0\n\nOutput for the Sample Input\n\n   52   96   15   20  183\n   86   22   35   45  188\n   45   78   54   36  213\n   16   86   74   55  231\n  199  282  178  156  815\n   52   96   15   20  183\n   86   22   35   45  188\n   45   78   54   36  213\n   16   86   74   55  231\n  199  282  178  156  815\n\n",
    "buggy": "data=[]\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    for i in range(n):\n        spam=list(map(int,input().split()))\n        spam.append(sum(spam))\n        data.append(spam)\n    spam=[]\n    for i in range(n+1):\n        spam.append(sum(x[i] for x in data))\n    data.append(spam)\n    for i in range(n+1):\n        for j in range(n+1):\n            print('{:5}'.format(data[i][j]),end='')\n        print('')",
    "fixed": "while True:\n    data=[]\n    n = int(input())\n    if n==0:\n        break\n    for i in range(n):\n        spam=list(map(int,input().split()))\n        spam.append(sum(spam))\n        data.append(spam)\n    spam=[]\n    for i in range(n+1):\n        spam.append(sum(x[i] for x in data))\n    data.append(spam)\n    for i in range(n+1):\n        for j in range(n+1):\n            print('{:5}'.format(data[i][j]),end='')\n        print('')"
  },
  {
    "problem_id": "p00103",
    "problem_statement": "\nBaseball Simulation\n\nIchiro likes baseball and has decided to write a program which simulates baseball.\n\nThe program reads events in an inning and prints score in that inning. There are only three events as follows:\n\nSingle hit\n\nput a runner on the first base.\nthe runner in the first base advances to the second base and the runner in the second base advances to the third base.\nthe runner in the third base advances to the home base (and go out of base) and a point is added to the score.\n\nHome run\n\nall the runners on base advance to the home base.\npoints are added to the score by an amount equal to the number of the runners plus one.\n\nOut\n\nThe number of outs is increased by 1.\nThe runners and the score remain stationary.\nThe inning ends with three-out.\n\n\nIchiro decided to represent these events using \"HIT\", \"HOMERUN\" and \"OUT\", respectively.\n\nWrite a program which reads events in an inning and prints score in that inning. You can assume that the number of events is less than or equal to 100.\n\nInput\n\nThe input consists of several datasets. In the first line, the number of datasets n is given. Each dataset consists of a list of events (strings) in an inning.\n\nOutput\n\nFor each dataset, prints the score in the corresponding inning.\n\nSample Input\n\n2\nHIT\nOUT\nHOMERUN\nHIT\nHIT\nHOMERUN\nHIT\nOUT\nHIT\nHIT\nHIT\nHIT\nOUT\nHIT\nHIT\nOUT\nHIT\nOUT\nOUT\n\nOutput for the Sample Input\n\n7\n0\n\n",
    "buggy": "import sys\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    n = int(sys.stdin.readline())*3\n    s = 0\n    p = 0\n    while n>0:\n        log = sys.stdin.readline()\n        if \"HIT\" in log:\n            if p >= 3:\n                s += 1 \n            p += 1\n        elif \"OUT\" in log:\n            n -= 1\n            if n % 3 == 0:\n                print(s)\n                s = 0\n                p = 0\n                if n == 0:\n                    break\n        else:\n            s += p + 1\n            p = 0  \nsolve()",
    "fixed": "import sys\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    n = int(sys.stdin.readline())*3\n    s = 0\n    p = 0\n    while n>0:\n        log = sys.stdin.readline()\n        if \"HIT\" in log:\n            if p >= 3:\n                s += 1 \n            else:\n                p += 1\n        elif \"OUT\" in log:\n            n -= 1\n            if n % 3 == 0:\n                print(s)\n                s = 0\n                p = 0\n                if n == 0:\n                    break\n        else:\n            s += p + 1\n            p = 0  \nsolve()\n        "
  },
  {
    "problem_id": "p00104",
    "problem_statement": "\nMagic Tile\n\nThere is a magic room in a homestead. The room is paved with H × W tiles. There are five different tiles:\n\n\nTile with a east-pointing arrow\nTile with a west-pointing arrow\nTile with a south-pointing arrow\nTile with a north-pointing arrow\nTile with nothing\n\n\nOnce a person steps onto a tile which has an arrow, the mystic force makes the person go to the next tile pointed by the arrow. If the next tile has an arrow, the person moves to the next, ans so on. The person moves on until he/she steps onto a tile which does not have the arrow (the tile with nothing). The entrance of the room is at the northwest corner.\n\n\nYour task is to write a program which simulates the movement of the person in the room. The program should read strings which represent the room and print the last position of the person.\n\n\nThe input represents the room as seen from directly above, and up, down, left and right side of the input correspond to north, south, west and east side of the room respectively. The horizontal axis represents x-axis (from 0 to W-1, inclusive) and the vertical axis represents y-axis (from 0 to H-1, inclusive). The upper left tile corresponds to (0, 0).\n\n\nThe following figure shows an example of the input:\n\n\n10 10\n>>>v..>>>v\n...v..^..v\n...>>>^..v\n.........v\n.v<<<<...v\n.v...^...v\n.v...^<<<<\n.v........\n.v...^....\n.>>>>^....\n\n\nCharacters represent tiles as follows:\n\n\n'>': Tile with a east-pointing arrow\n'<': Tile with a west-pointing arrow \n'^': Tile with a north-pointing arrow \n'v': Tile with a south-pointing arrow \n'.': Tile with nothing\n\n\nIf the person goes in cycles forever, your program should print \"LOOP\". You may assume that the person never goes outside of the room.\n\nInput\n\nThe input consists of multiple datasets. The input ends with a line which contains two 0. Each dataset consists of:\n\n\nH W\nH lines where each line contains W characters\n\n\nYou can assume that 0 < W, H < 101.\n\nOutput\n\nFor each dataset, print the coordinate (X, Y) of the person or \"LOOP\" in a line. X and Y should be separated by a space.\n\nSample Input\n\n10 10\n>>>v..>>>v\n...v..^..v\n>>>>>>^..v\n.........v\n.v<<<<...v\n.v.v.^...v\n.v.v.^<<<<\n.v.v.....v\n.v...^...v\n.>>>>^....\n6 10\n>>>>>>>>>v\n.........v\n.........v\n>>>>v....v\n^...v....v\n^<<<<<<<<<\n0 0\n\nOutput for the Sample Input\n\n5 7\nLOOP\n\n",
    "buggy": "import sys\nimport math\n\ndef decide_move(x,y,tile,check):\n\tif tile == '<':\n\t\tx -= 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telif tile == '>':\n\t\tx += 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telif tile == '^':\n\t\ty -= 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telse:\n\t\ty += 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\n\nwhile True:\n\th,w = map(int,input().split())\n\tif h == 0:\n\t\tbreak\n\ttile_map = []\n\tfor i in range(h):\n\t\ttile_map.append(input())\n\tcheck =[[0 for i in range(w)]for j in range(h)]\n\tcheck[0][0] = 1\n\tx = 0\n\ty = 0\n\tstatus = 0\n\n\twhile True:\n\t\tif tile_map[x][y] == '.':\n\t\t\tstatus = 1\n\t\t\tprint(y,x)\n\t\t\tbreak\n\t\tx,y,check = decide_move(x,y,tile_map[x][y],check)\n\t\tif check[x][y] > 1:\n\t\t\tstatus = 1\n\t\t\tprint('LOOP')\n\t\t\tbreak",
    "fixed": "import sys\nimport math\n\ndef decide_move(x,y,tile,check):\n\tif tile == '<':\n\t\ty -= 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telif tile == '>':\n\t\ty += 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telif tile == '^':\n\t\tx -= 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\telse:\n\t\tx += 1\n\t\tcheck[x][y] += 1\n\t\treturn x,y,check\n\n\nwhile True:\n\th,w = map(int,input().split())\n\tif h == 0:\n\t\tbreak\n\ttile_map = []\n\tfor i in range(h):\n\t\ttile_map.append(input())\n\tcheck =[[0 for i in range(w)]for j in range(h)]\n\tcheck[0][0] = 1\n\tx = 0\n\ty = 0\n\tstatus = 0\n\n\twhile True:\n\t\tif tile_map[x][y] == '.':\n\t\t\tstatus = 1\n\t\t\tprint(y,x)\n\t\t\tbreak\n\t\tx,y,check = decide_move(x,y,tile_map[x][y],check)\n\t\tif check[x][y] > 1:\n\t\t\tstatus = 1\n\t\t\tprint('LOOP')\n\t\t\tbreak"
  },
  {
    "problem_id": "p00107",
    "problem_statement": "\nCarry a Cheese\n\nJerry is a little mouse. He is trying to survive from the cat Tom. Jerry is carrying a parallelepiped-like piece of cheese of size A × B × C. It is necessary to trail this cheese to the Jerry's house. There are several entrances in the Jerry's house. Each entrance is a rounded hole having its own radius R. Could you help Jerry to find suitable holes to be survive?\n\n\n\nYour task is to create a program which estimates whether Jerry can trail the cheese via each hole.\nThe program should print \"OK\" if Jerry can trail the cheese via the corresponding hole (without touching it). Otherwise the program should print \"NA\".\n\n\nYou may assume that the number of holes is less than 10000.\n\nInput\n\nThe input is a sequence of datasets. The end of input is indicated by a line containing three zeros. Each dataset is formatted as follows:\n\n\nA B C\nn\nR1\nR2\n\n .\n .\nRn\n\n\nn indicates the number of holes (entrances) and Ri indicates the radius of i-th hole.\n\nOutput\n\nFor each datasets, the output should have n lines. Each line points the result of estimation of the corresponding hole. \n\nSample Input\n\n10 6 8\n5\n4\n8\n6\n2\n5\n0 0 0\n\nOutput for the Sample Input\n\nNA\nOK\nOK\nNA\nNA\n\n",
    "buggy": "while True:\n    solid = sorted(map(int, input().split()))\n    print(solid)\n    if solid.count(0) == 3: break\n    n = eval(input())\n    s = (solid[0]**2+solid[1]**2)/4\n    for i in range(n):\n        r = eval(input())\n        if r*r > s:\n            print('OK')\n        else:\n            print('NA')\n            ",
    "fixed": "while True:\n    solid = sorted(map(int, input().split()))\n    if solid.count(0) == 3: break\n    n = eval(input())\n    s = (solid[0]**2+solid[1]**2)/4\n    for i in range(n):\n        r = eval(input())\n        if r*r > s:\n            print('OK')\n        else:\n            print('NA')"
  },
  {
    "problem_id": "p00108",
    "problem_statement": "Frequency of appearance operation\nThere is a transformation operation for a finite sequence called a frequency of appearance operation. The result of transforming the sequence S = {s1, s2, ..., sn} is a sequence of the same length. If we define the result as C = {c1, c2, ..., cn}, then ci represents the number of times si appears in the sequence S.\nFor example, if S = {3, 4, 1, 5, 9, 2, 6, 5, 3}, then C = {2, 1, 1, 2, 1, 1, 1, 2, 2}. Performing a frequency of appearance operation on this sequence C gives us P = {4, 5, 5, 4, 5, 5, 5, 4, 4}. This sequence does not change with frequency of appearance operations. Such a sequence P is called a fixed point of the sequence S. It is known that for any sequence, the fixed point can be obtained by repeating the frequency of appearance operation.\nThe example below shows the procedure for the frequency of appearance operation. The first line represents the sequence S, the second line represents the sequence C, and the last line represents the sequence P. We count the number of occurrences and find ci by listing the number of times the first element (s1=2) in the sequence S appears in the same way as the second element (s2=7) with two elements.\n\n\n\n\nWrite a program that takes the length of the sequence n and the sequence S as input and outputs the fixed-point sequence P and the minimum number of frequency of appearance operations required to obtain P.\nInput\nMultiple datasets are given. Each dataset is given in the following format.\n\nn\ns1 s2 ... sn\n\nThe first line contains an integer n (n ≤ 12) representing the length of the sequence. The second line contains integers si (1 ≤ si ≤ 100) representing the elements of the sequence S separated by spaces.\nThe input ends with a line containing a single 0. There are no more than 200 datasets.\nOutput\nFor each dataset, output the minimum number of times the frequency of appearance operation is performed (an integer) on the first line and the elements p1, p2, ..., pn of the corresponding fixed-point sequence P on the second line, separated by spaces.\nSample Input\n\n10\n4 5 1 1 4 5 12 3 5 4\n0\n\nOutput for the Sample Input\n\n3\n6 6 4 4 6 6 4 4 6 6\n",
    "buggy": "while True:\n\tn = int(input())\n\tif n == 0:\n\t    break\n\ts = []\n    s = list(input().split())\n\twhile True:\n\t\tt = []\n        u = 0\n    \tv = 0\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tif s[i] == s[j]:\n\t\t\t\t\tu += 1\n\t\t\tt.append(u)\n\t\t\tt_str = list(map(str, t))\n\t\t\tu = 0\n\t\tif s == t:\n\t\t\tprint(str(v))\n\t\t\tprint(\" \".join(t_str))\n\t\t\tbreak\n\t\telse:\n\t\t\ts = t\n\t\t\tv += 1",
    "fixed": "while True:\n\tn = int(input())\n\tif n == 0:\n\t    break\n\ts = []\n\tu = 0\n\tv = 0\n\ts = list(map(int, input().split()))\n\twhile True:\n\t\tt = []\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tif s[i] == s[j]:\n\t\t\t\t\tu += 1\n\t\t\tt.append(u)\n\t\t\tt_str = list(map(str, t))\n\t\t\tu = 0\n\t\tif s == t:\n\t\t\tprint(str(v))\n\t\t\tprint(\" \".join(t_str))\n\t\t\tbreak\n\t\telse:\n\t\t\ts = t\n\t\t\tv += 1"
  },
  {
    "problem_id": "p00109",
    "problem_statement": "\nSmart Calculator\n\nYour task is to write a program which reads an expression and evaluates it.\n\n\nThe expression consists of numerical values, operators and parentheses, and the ends with '='.\nThe operators includes +, - , *, / where respectively represents, addition, subtraction, multiplication and division.\n Precedence of the operators is based on usual laws. That is one should perform all multiplication and division first, then addition and subtraction. When two operators have the same precedence, they are applied from left to right.\n\nYou may assume that there is no division by zero.\nAll calculation is performed as integers, and after the decimal point should be truncated\nLength of the expression will not exceed 100.\n-1 × 109 ≤ intermediate results of computation ≤ 109\n\nInput\n\nThe input is a sequence of datasets. The first line contains an integer n which represents the number of datasets. There will be n lines where each line contains an expression.\n\nOutput\n\nFor each datasets, prints the result of calculation.\n\nSample Input\n\n2\n4-2*3=\n4*(8+4+3)=\n\nOutput for the Sample Input\n\n-2\n60\n\n",
    "buggy": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\nn = int(input())\n\nfor _ in range(n):\n    s = input()\n    print(Calculate_RPN(Generate_RPN(String2List(s))))",
    "fixed": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\n\nn = int(input())\n\nfor _ in range(n):\n    s = input()\n    print(Calculate_RPN(Generate_RPN(String2List(s[:-1]))))"
  },
  {
    "problem_id": "p00111",
    "problem_statement": "Dr. Cipher\n\nDr. : ?D-C'KOPUA\n\n\nPeter: What's wrong, Dr. David? I'm used to you shouting incomprehensible things, but today it's not even forming sentences.\n\n\nDr. : Look at this.\n\n\n\n\n\n\nPeter: What's this?... Oh, there was something like this in the preliminary round's problems. By using the table, the number of characters can be reduced by replacing the characters. They wouldn't use the same problem in both the preliminary and the main round to take it easy, right?\n\n\nDr. : The opposite.\n\n\nPeter: The opposite? I see, so it's a problem of restoring the shortened string from this time. So I need to replace the characters in \"?D-C'KOPUA\" with the \"code\" using this table... Done.\n\n\n11111 00011 11101 00010 11110 01010 01110 01111 10100 00000\n\n\n\nDr. : Yes. Next is this.\n\n\n\n\n\n\nPeter: Yes, there was a table like this. So I just need to replace \"code\" with \"character\" by using it in reverse. But at first, \"11111\" is not on the table, is it?\n\n\nDr. : In such cases, try to make it shorter or connect it to the end.\n\n\nPeter: Then I'll make it shorter... Oh, \"111\" is there. So the first one is \"P\", right? Then the remaining one is \"11\", but there is no exact match for it, so I need to borrow 1 character from \"00011\" and make it \"110\".\n\n\nDr. : That's right. That means it's \"E\".\n\n\nPeter: So the remaining one is \"0011\", so I'll borrow from the next one and make it \"00111\" and it's \"T\"... Done. Can I just throw away the last \"0000\"?\n\n\n\n\n\n\nDr. : That's right. Next is this.\n\n\n?D-C'?-C'-LMGZN?FNJKN- WEYN?P'QMRWLPZLKKTPOVRGDI\n\n\nDr. : And this.\n\n\n?P'QNPY?IXX?IXXK.BI -G?R'RPP'RPOVWDMW?SWUVG'-LCMGQ\n\n\nDr. : Finally, it's like this.\n\n\n?P'QMDUEQ GADKOQ ?SWUVG'-LCMG?X?IGX,PUL.?UL.VNQQI\n\n\nPeter: But it's a hassle. Dr., make your own program next time.\n\n\nThat being said, please create a program to replace the above sentence for Dr.\n\nInput\n\nMultiple datasets are given. For each dataset, one string (up to 200 characters composed of characters included in the table) is given in one line. Process until the end of the input. The number of datasets does not exceed 200.\n\nOutput\n\nFor each dataset, output the converted string on one line.\n\nSample Input\n\n?D-C'KOPUA\n\nOutput for the Sample Input\n\nPETER POTTER\n\n",
    "buggy": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\ndict = {\"A\":\"00000\",\\\n        \"B\":\"00001\",\\\n        \"C\":\"00010\",\\\n        \"D\":\"00011\",\\\n        \"E\":\"00100\",\\\n        \"F\":\"00101\",\\\n        \"G\":\"00110\", \\\n        \"H\":\"00111\", \\\n        \"I\":\"01000\", \\\n        \"J\":\"01001\", \\\n        \"K\":\"01010\", \\\n        \"L\":\"01011\", \\\n        \"M\":\"01100\", \\\n        \"N\":\"01101\", \\\n        \"O\":\"01110\", \\\n        \"P\":\"01111\", \\\n        \"Q\":\"10000\", \\\n        \"R\":\"10001\", \\\n        \"S\":\"10010\", \\\n        \"T\":\"10011\", \\\n        \"U\":\"10100\", \\\n        \"V\":\"10101\", \\\n        \"W\":\"10110\", \\\n        \"X\":\"10111\", \\\n        \"Y\":\"11000\", \\\n        \"Z\":\"11001\", \\\n        \" \":\"11010\", \\\n        \".\":\"11011\", \\\n        \",\":\"11100\", \\\n        \"-\":\"11101\", \\\n        \"'\":\"11110\", \\\n        \"?\":\"11111\"}\n\ndict2 = {\"101\":\" \",\\\n         \"000000\":\"'\",\\\n         \"000011\":\",\", \\\n         \"10010001\":\"-\", \\\n         \"010001\":\".\",\\\n         \"000001\":\"?\",\\\n         \"100101\":\"A\",\\\n         \"10011010\":\"B\",\\\n         \"0101\":\"C\",\\\n         \"0001\":\"D\",\\\n         \"110\":\"E\",\\\n         \"01001\":\"F\",\\\n         \"10011011\":\"G\",\\\n         \"010000\":\"H\",\\\n         \"0111\":\"I\",\\\n         \"10011000\":\"J\",\\\n         \"0110\":\"K\",\\\n         \"00100\":\"L\",\\\n         \"10011001\":\"M\",\\\n         \"10011110\":\"N\",\\\n         \"00101\":\"O\",\\\n         \"111\":\"P\",\\\n         \"10011111\":\"Q\",\\\n         \"1000\":\"R\",\\\n         \"00110\":\"S\",\\\n         \"00111\":\"T\",\\\n         \"10011100\":\"U\",\\\n         \"10011101\":\"V\",\\\n         \"000010\":\"W\",\\\n         \"10010010\":\"X\",\\\n         \"10010011\":\"Y\",\\\n         \"10010000\":\"Z\"}\n\nN = list(get_input())\n\nfor l in range(len(N)):\n    S1 = N[l]\n    S2 = \"\"\n\n    for i in range(len(S1)):\n        S2 = S2 + dict[S1[i]]\n\n    S3 = \"\"\n    while S2 != \"\":\n        flag = False\n        for i in range(3, len(S2)):\n            s = S2[0:i]\n            if s in dict2:\n                S3 = S3 + dict2[s]\n                S2 = S2[i:]\n                flag = True\n                break\n        if flag == False:\n            break\n\n    print(S3)\n\n",
    "fixed": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\ndict = {\"A\":\"00000\",\\\n        \"B\":\"00001\",\\\n        \"C\":\"00010\",\\\n        \"D\":\"00011\",\\\n        \"E\":\"00100\",\\\n        \"F\":\"00101\",\\\n        \"G\":\"00110\", \\\n        \"H\":\"00111\", \\\n        \"I\":\"01000\", \\\n        \"J\":\"01001\", \\\n        \"K\":\"01010\", \\\n        \"L\":\"01011\", \\\n        \"M\":\"01100\", \\\n        \"N\":\"01101\", \\\n        \"O\":\"01110\", \\\n        \"P\":\"01111\", \\\n        \"Q\":\"10000\", \\\n        \"R\":\"10001\", \\\n        \"S\":\"10010\", \\\n        \"T\":\"10011\", \\\n        \"U\":\"10100\", \\\n        \"V\":\"10101\", \\\n        \"W\":\"10110\", \\\n        \"X\":\"10111\", \\\n        \"Y\":\"11000\", \\\n        \"Z\":\"11001\", \\\n        \" \":\"11010\", \\\n        \".\":\"11011\", \\\n        \",\":\"11100\", \\\n        \"-\":\"11101\", \\\n        \"'\":\"11110\", \\\n        \"?\":\"11111\"}\n\ndict2 = {\"101\":\" \",\\\n         \"000000\":\"'\",\\\n         \"000011\":\",\", \\\n         \"10010001\":\"-\", \\\n         \"010001\":\".\",\\\n         \"000001\":\"?\",\\\n         \"100101\":\"A\",\\\n         \"10011010\":\"B\",\\\n         \"0101\":\"C\",\\\n         \"0001\":\"D\",\\\n         \"110\":\"E\",\\\n         \"01001\":\"F\",\\\n         \"10011011\":\"G\",\\\n         \"010000\":\"H\",\\\n         \"0111\":\"I\",\\\n         \"10011000\":\"J\",\\\n         \"0110\":\"K\",\\\n         \"00100\":\"L\",\\\n         \"10011001\":\"M\",\\\n         \"10011110\":\"N\",\\\n         \"00101\":\"O\",\\\n         \"111\":\"P\",\\\n         \"10011111\":\"Q\",\\\n         \"1000\":\"R\",\\\n         \"00110\":\"S\",\\\n         \"00111\":\"T\",\\\n         \"10011100\":\"U\",\\\n         \"10011101\":\"V\",\\\n         \"000010\":\"W\",\\\n         \"10010010\":\"X\",\\\n         \"10010011\":\"Y\",\\\n         \"10010000\":\"Z\"}\n\nN = list(get_input())\n\nfor l in range(len(N)):\n    S1 = N[l]\n    S2 = \"\"\n\n    for i in range(len(S1)):\n        S2 = S2 + dict[S1[i]]\n\n    S3 = \"\"\n    while S2 != \"\":\n        flag = False\n        for i in range(3, len(S2)+1):\n            s = S2[0:i]\n            if s in dict2:\n                S3 = S3 + dict2[s]\n                S2 = S2[i:]\n                flag = True\n                break\n        if flag == False:\n            break\n\n    print(S3)\n\n"
  },
  {
    "problem_id": "p00112",
    "problem_statement": "Milk Shop\n\nSuzuki has opened a mobile shop for freshly squeezed milk in the Aizu region. All the customers who come to buy it that day are already lined up with bottles to take home, and no more customers will come. Each customer orders only once. There is only one faucet on the tank, so they must be sold one by one in order. Therefore, Suzuki wants to minimize the waiting time of the customers who are waiting in line as much as possible.\n\n\nThe number of customers and the time required for each customer to pour the milk are given as input. Create a program that finds the order of orders that minimizes the \"total waiting time\" of the customers (hereinafter referred to as \"total waiting time\") on behalf of Suzuki, and outputs the \"total waiting time\" at that time and ends. However, there are up to 10,000 customers, and the time required per person is less than 60 minutes.\n\n\nFor example, if there are 5 customers and each customer requires 2, 6, 4, 3, and 9 minutes in order, the \"total waiting time\" will be 37 minutes if they are in the same order. In the following example, the order of the first column is swapped with the second and third customers. In this case, the \"total waiting time\" is 35 minutes. With the optimal order, it can be done in 31 minutes.\n\n\nWait time\n1st person 2 min   0 min\n2nd person 6 min   2 min\n3rd person 4 min   8 min\n4th person 3 min  12 min\n5th person 9 min  15 min\n            37 min ← \"total waiting time\"\n\n\n\nExample of swapping the 2nd and 3rd persons\n\n\nWait time\n1st person 2 min   0 min\n2nd person 4 min   2 min\n3rd person 6 min   6 min\n4th person 3 min  12 min\n5th person 9 min  15 min\n   35 min ← \"total waiting time\"\n\n\nInput\n\nMultiple datasets are given. Each dataset is given in the following format.\n\n\nn\nt1\nt2\n:\ntn\n\n\nThe number of customers n (n ≤ 10,000) is given on the first line. The following n lines give an integer ti (0 ≤ ti ≤ 60) representing the time required for the i-th customer to order.\n\n\nThe input ends with a line containing only 0. The number of datasets does not exceed 50.\n\nOutput\n\nFor each dataset, output the \"total waiting time\" (an integer) on one line.\n\nSample Input\n\n5\n2\n6\n4\n3\n9\n0\n\nOutput for the Sample Input\n\n31\n",
    "buggy": "while True:\n    n = int(input())\n    if n==0:break\n    wt = [int(input()) for _ in range(n)]\n    total = wt[0]\n    s = []\n    for v in sorted(wt[1:]):\n        s.append(total)\n        total += v\n    print(sum(s))",
    "fixed": "while True:\n    n = int(input())\n    if n==0:break\n    wt = sorted([int(input()) for _ in range(n)])\n    total = wt[0]\n    s = []\n    for v in wt[1:]:\n        s.append(total)\n        total += v\n    print(sum(s))"
  },
  {
    "problem_id": "p00113",
    "problem_statement": "Repeating Decimals\n\nConsider representing the division of two positive integers p and q as a decimal number. (We assume that 0 < p < q < 106.)\n\n\nThe result can be either:\n\n\n represented accurately with a finite number of digits.\n a repeating decimal that repeats a range of digits.\n\n\nBy performing division in the same way as long division, the decimal digits can be found one by one, and:\n\n\n If the remainder becomes 0 (divides evenly), we have found all the digits and can represent the result exactly.\n If a remainder repeats, the decimal repeats as well.\n\n\nWrite a program that takes two integers p and q as input and outputs the decimal part of p/q. Note that:\n\n\n If the result can be represented accurately with a finite number of digits, output only the digits.\n If the result is a repeating decimal, output two lines as follows:\n      \n The first line should contain the non-repeating part of the decimal.\n The second line should contain spaces under the non-repeating part and \"^\" characters under the repeating part.\n\n\n The length of the digit string will not exceed 80 characters.\n\nInput\n\nThe input consists of multiple data sets. Each data set consists of two integers p and q, separated by a single space, given in a single line. The number of data sets is no more than 250.\n\nOutput\n\nFor each data set, output the decimal part of the division. If the decimal representation is non-repeating, output only the digits. If the decimal representation is repeating, output a two-line result with the non-repeating part on the top and \"^\" characters under the repeating part.\n\nSample Input\n\n1 12\n10000 32768\n1 11100\n1 459550\n\nOutput for the Sample Input\n\n083\n  ^\n30517578125\n00009\n  ^^^\n00000217604178\n  ^^^^^^^^^^^^\n",
    "buggy": "while(True):\n    try: p,q = map(int,input().split())\n    except: break\n    ansstr = \"\"\n    checked = [p%q]\n    while(True):\n        p *= 10\n        ans,p = p//q, p%q\n        if p == 0:\n            print(ansstr)\n            break\n        ansstr += str(ans)\n        if p in checked:\n            ansind = checked.index(p)\n            print(ansstr)\n            print(\" \"*(ansind)+\"^\"*(len(checked)-ansind))\n            break\n        else: checked.append(p)\n\n",
    "fixed": "while(True):\n    try: p,q = map(int,input().split())\n    except: break\n    ansstr = \"\"\n    checked = [p%q]\n    while(True):\n        ans,p = divmod(p*10,q)\n        ansstr += str(ans)\n        if p == 0:\n            print(ansstr)\n            break\n        if p in checked:\n            ansind = checked.index(p)\n            print(ansstr)\n            print(\" \"*(ansind)+\"^\"*(len(checked)-ansind))\n            break\n        else: checked.append(p)\n\n"
  },
  {
    "problem_id": "p00115",
    "problem_statement": "Spaceship UAZ Advance\n\nStellar calendar 2005.11.5. You are the captain of the UAZ Advance spacecraft and are about to engage in combat with an enemy spacecraft. Fortunately, the enemy spacecraft is still stationary and has not yet noticed us. Also, the coordinates of the enemy's spaceship are already known, and the \"Feather Cannon,\" which emits a powerful straight-line beam, is ready to fire. All that remains is to give the order to fire.\n\n\nHowever, there is a problem. An energy barrier installed by the enemy exists in space. The barrier is in the shape of a triangle and reflects the \"Feather Cannon\" beam. Also, if the beam hits the barrier, the enemy will notice us and escape. If we cannot determine that the beam will hit its target in advance, we cannot issue the firing order.\n\n\nTherefore, please create a program that inputs the coordinates of the UAZ Advance spacecraft, the enemy, and the barrier in space coordinates (3D coordinates x, y, and z) and outputs \"HIT\" if the beam hits the enemy while avoiding the barrier, and \"MISS\" if the beam hits the barrier. If the enemy is inside the barrier, output \"MISS.\"\n\n\nNote that only those barriers that appear as triangles from the UAZ Advance spacecraft are targeted, and those that appear as flattened lines are not included. Also, the barrier is effective even on the boundary that includes the vertices of the triangle and reflects the beam.\n\nInput\n\nThe format of the input data is as follows:\n\nThe first line contains the coordinates of the UAZ Advance spacecraft (x, y, z) (integers, separated by a single space).\nThe second line contains the coordinates of the enemy (x, y, z) (integers, separated by a single space).\nThe third line contains the coordinates of vertex 1 of the barrier (x, y, z) (integers, separated by a single space).\nThe fourth line contains the coordinates of vertex 2 of the barrier (x, y, z) (integers, separated by a single space).\nThe fifth line contains the coordinates of vertex 3 of the barrier (x, y, z) (integers, separated by a single space).\n\nOutput\n\nOutput either \"HIT\" or \"MISS\" on a single line.\n\nConstraints\n\n-100 ≤ x, y, z ≤ 100\nThe UAZ Advance spacecraft and the enemy will never be in the same position.\n\nSample Input 1\n\n-10 0 0\n10 0 0\n0 10 0\n0 10 10\n0 0 10\n\nOutput for the Sample Input 1\n\nHIT\n\n\nSample Input 2\n\n-10 6 6\n10 6 6\n0 10 0\n0 10 10\n0 0 10\n\nOutput for the Sample Input 2\n\nMISS\n\n",
    "buggy": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport random\n\n# refs\n# https://shikousakugo.wordpress.com/2012/06/27/ray-intersection-2/\n\ndef det(a, b, c):\n    return + a[0] * b[1] * c[2] \\\n           + a[2] * b[0] * c[1] \\\n           + a[1] * b[2] * c[0] \\\n           - a[2] * b[1] * c[0] \\\n           - a[1] * b[0] * c[2] \\\n           - a[0] * b[2] * c[1]\n\ndef sub(v0, v1):\n    # v0 - v1\n    return (v0[0] - v1[0], v0[1] - v1[1], v0[2] - v1[2])\n\n# me\np0 = list(map(int, input().split()))\n\n# enemy\np1 = list(map(int, input().split()))\n\n# barrier\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\ndef solve(p0, p1, A, B, C):\n    a = sub(p1, p0)\n    b = sub(A, B)\n    c = sub(A, C)\n    d = sub(A, p0)\n\n    EPS = 0.0000001\n    lower = -EPS\n    upper = 1 + EPS\n\n    denom = det(a, b, c)\n\n    if denom > 0:\n        t = det(d, b, c) / denom\n        u = det(a, d, c) / denom\n        v = det(a, b, d) / denom\n\n        if t < lower:\n            return 'HIT'\n\n        # hit barrier\n        elif lower < t < upper and lower <= u <= upper and lower <= v <= upper and lower <= u + v <= upper:\n            return 'MISS'\n\n        else:\n            return 'HIT'\n    else:\n        if denom < lower:\n            return 'MISS'\n        else:\n            return 'HIT'\n\ndef correct_solve(p0, p1, A, B, C):\n    from fractions import Fraction\n    def gauss(a):\n        if not a or len(a) == 0: return None\n        n = len(a)\n        for i in range(n):\n            if a[i][i] == 0:\n                for j in range(i + 1, n):\n                    if a[j][i] != 0:\n                        for k in range(i, n + 1): a[i][k] += a[j][k]\n                        break\n                else:\n                    return None\n            for j in range(n):\n                if i != j:\n                    r = Fraction(a[j][i], a[i][i])\n                    for k in range(i, n + 1): a[j][k] = a[j][k] - a[i][k] * r\n        for i in range(n):\n            x = Fraction(a[i][i], 1)\n            for j in range(len(a[i])):\n                a[i][j] /= x\n        return a\n\n\n    uaz = p0\n    enemy = [0] + [-x + y for x, y in zip(p1, uaz)]\n    b0 = [1] + [x - y for x, y in zip(A, uaz)]\n    b1 = [1] + [x - y for x, y in zip(B, uaz)]\n    b2 = [1] + [x - y for x, y in zip(C, uaz)]\n    sol = gauss(list(map(list, zip(b0, b1, b2, enemy, [1, 0, 0, 0]))))\n    if sol and all(0 <= e[-1] <= 1 for e in sol):\n        return 'MISS'\n    else:\n        return 'HIT'\n\ndef rand_v():\n    return (random.randrange(-100, 100), random.randrange(-100, 100), random.randrange(-100, 100))\n\nif __name__ == '__main__':\n    res = solve(p0, p1, A, B, C)\n    print(res)\n\n\n    # while True:\n    #     p0 = rand_v()\n    #     p1 = rand_v()\n    #     A = rand_v()\n    #     B = rand_v()\n    #     C = rand_v()\n    #     result0 = solve(p0, p1, A, B, C)\n    #     result1 = correct_solve(p0, p1, A, B, C)\n    #\n    #     if result0 != result1:\n    #         print(p0, p1, A, B, C)\n    #     else:\n    #         print('same')",
    "fixed": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport random\n\n# refs\n# https://shikousakugo.wordpress.com/2012/06/27/ray-intersection-2/\n\ndef det(a, b, c):\n    return + a[0] * b[1] * c[2] \\\n           + a[2] * b[0] * c[1] \\\n           + a[1] * b[2] * c[0] \\\n           - a[2] * b[1] * c[0] \\\n           - a[1] * b[0] * c[2] \\\n           - a[0] * b[2] * c[1]\n\ndef sub(v0, v1):\n    # v0 - v1\n    return (v0[0] - v1[0], v0[1] - v1[1], v0[2] - v1[2])\n\n# me\np0 = list(map(int, input().split()))\n\n# enemy\np1 = list(map(int, input().split()))\n\n# barrier\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\ndef solve(p0, p1, A, B, C):\n    a = sub(p1, p0)\n    b = sub(A, B)\n    c = sub(A, C)\n    d = sub(A, p0)\n\n    EPS = 0.0000001\n    lower = -EPS\n    upper = 1 + EPS\n\n    denom = det(a, b, c)\n\n    if denom != 0:\n        t = det(d, b, c) / denom\n        u = det(a, d, c) / denom\n        v = det(a, b, d) / denom\n\n        if t < lower:\n            return 'HIT'\n\n        # hit barrier\n        elif lower < t < upper and lower <= u <= upper and lower <= v <= upper and lower <= u + v <= upper:\n            return 'MISS'\n\n        else:\n            return 'HIT'\n    else:\n        return 'HIT'\n\ndef correct_solve(p0, p1, A, B, C):\n    from fractions import Fraction\n    def gauss(a):\n        if not a or len(a) == 0: return None\n        n = len(a)\n        for i in range(n):\n            if a[i][i] == 0:\n                for j in range(i + 1, n):\n                    if a[j][i] != 0:\n                        for k in range(i, n + 1): a[i][k] += a[j][k]\n                        break\n                else:\n                    return None\n            for j in range(n):\n                if i != j:\n                    r = Fraction(a[j][i], a[i][i])\n                    for k in range(i, n + 1): a[j][k] = a[j][k] - a[i][k] * r\n        for i in range(n):\n            x = Fraction(a[i][i], 1)\n            for j in range(len(a[i])):\n                a[i][j] /= x\n        return a\n\n\n    uaz = p0\n    enemy = [0] + [-x + y for x, y in zip(p1, uaz)]\n    b0 = [1] + [x - y for x, y in zip(A, uaz)]\n    b1 = [1] + [x - y for x, y in zip(B, uaz)]\n    b2 = [1] + [x - y for x, y in zip(C, uaz)]\n    sol = gauss(list(map(list, zip(b0, b1, b2, enemy, [1, 0, 0, 0]))))\n    if sol and all(0 <= e[-1] <= 1 for e in sol):\n        return 'MISS'\n    else:\n        return 'HIT'\n\ndef rand_v():\n    return (random.randrange(-100, 100), random.randrange(-100, 100), random.randrange(-100, 100))\n\nif __name__ == '__main__':\n    res = solve(p0, p1, A, B, C)\n    print(res)\n\n\n    # while True:\n    #     p0 = rand_v()\n    #     p1 = rand_v()\n    #     A = rand_v()\n    #     B = rand_v()\n    #     C = rand_v()\n    #     result0 = solve(p0, p1, A, B, C)\n    #     result1 = correct_solve(p0, p1, A, B, C)\n    #\n    #     if result0[0] != result1[0]:\n    #         print(p0, p1, A, B, C)\n    #         print(result0)\n    #         print(result1)\n    #     else:\n    #         print('same')"
  },
  {
    "problem_id": "p00116",
    "problem_statement": "Rectangular Search\n\nThere is a W × H grid, consisting of H rows and W columns. Some of the squares have marks on them. Write a program that reads the state of the marks on each square, and outputs the area of the largest rectangle that does not include any marked squares.\n\n\nThe input consists of H rows, each of which contains a string of W characters. For example, you may be given data like the following:\n\n\n..*....**.\n..........\n**....***.\n....*.....\n..*.......\n...**.....\n.*.*......\n..........\n..**......\n.*..*.....\n\n\nEach row of input data represents one row of squares. In the input data, a period (.) represents an unmarked square, and an asterisk (*) represents a marked square. The input data contains no characters other than periods, asterisks, and newlines.\n\n\nIn the example above, the largest rectangle, marked with 0's in the diagram below, has an area of 35.\n\n\n..*....**.\n..........\n**....***.\n....*00000\n..*..00000\n...**00000\n.*.*.00000\n.....00000\n..**.00000\n.*..*00000\n\n\nIf all the squares are marked, output 0.\n\nInput\n\nMultiple data sets are given. Each data set begins with a line containing two integers H and W separated by a space, followed by a rectangular grid of H × W squares. H and W are less than or equal to 500.\n\n\nThe input ends with a line containing two zeros. There are no more than 20 data sets.\n\nOutput\n\nFor each data set, output the area of the largest rectangle in a single line.\n\nSample Input\n\n10 10\n...*....**\n..........\n**....**..\n........*.\n..*.......\n**........\n.*........\n..........\n....*..***\n.*....*...\n10 10\n..*....*..\n.*.*...*..\n*****..*..\n*...*..*..\n*...*..*..\n..........\n****.*...*\n..*..*...*\n.*...*...*\n****..***.\n2 3\n...\n...\n0 0\n\nOutput for the Sample Input\n\n28\n12\n6\n",
    "buggy": "# ref: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=924554#1\nfrom itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = [list(map(int,input().replace(\".\",\"1\").replace(\"*\",\"0\")))+[0] for _ in range(H)]\n    for i,j in product(range(1,H),range(W)):\n        if ma[i][j]: ma[i][j] += ma[i-1][j]\n    ans = 0\n    for i in range(H):\n        stk = []\n        for j in range(W+1):\n            cur = ma[i][j]\n            if (not stk) or stk[-1][1] < cur:\n                stk.append([j,cur])\n            elif stk[-1][1] > cur:\n                idx = j\n                while stk and stk[-1][1] >= cur:\n                    ans = max(ans,stk[-1][1]*(j-stk[-1][0]))\n                    stk.pop()\n    print(ans)\n",
    "fixed": "# ref: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=924554#1\nfrom itertools import product\nwhile(True):\n    H,W = map(int,input().split())\n    if not H: break\n    ma = [list(map(int,input().replace(\".\",\"1\").replace(\"*\",\"0\")))+[0] for _ in range(H)]\n    for i,j in product(range(1,H),range(W)):\n        if ma[i][j]: ma[i][j] += ma[i-1][j]\n    ans = 0\n    for i in range(H):\n        stk = []\n        for j in range(W+1):\n            cur = ma[i][j]\n            if (not stk) or stk[-1][1] < cur:\n                stk.append([j,cur])\n            elif stk[-1][1] > cur:\n                idx = j\n                while stk and stk[-1][1] >= cur:\n                    idx = stk[-1][0]\n                    ans = max(ans,stk[-1][1]*(j-stk[-1][0]))\n                    stk.pop()\n                stk.append([idx,cur])\n    print(ans)\n"
  },
  {
    "problem_id": "p00117",
    "problem_statement": "The Carpenter's Reward\n\nOne day, a lord said to a carpenter, \"Build a large and sturdy building that townspeople can evacuate to during typhoons and earthquakes.\" However, to complete such a sturdy and large building, large thick pillars are necessary. Such large pillars are not available in the town. Therefore, the carpenter went to a distant mountain village to procure large pillars (the carpenter needs to go from the town to the mountain village and return to the town).\n\n\nThe reward for the carpenter is the remainder obtained by subtracting the cost of the pillars and the transportation expenses from the money received from the lord. To obtain the maximum reward for the carpenter, create a program that outputs it. However, if the number of towns is n, each town is identified by an integer from 1 to n. There are no more than two roads connecting two towns directly.\n\n\n\n\n\n※ The numbers on the arrows indicate the transportation expenses to go in that direction.\n\nInput\n\nThe input is given in the following format.\n\n\nn\nm\na1,b1,c1, d1\na2,b2,c2, d2\n:\nam,bm,cm, dm\ns,g,V,P\n\n\nThe first line gives the total number of towns n ( n ≤ 20), and the second line gives the total number of roads m (m ≤ 100). The following m lines provide information about the i-th road: ai, bi, ci, di (1 ≤ ai, bi ≤ n,  0 ≤ ci, di ≤ 1,000). ai and bi represent the numbers of the towns connected by road i, ci represents the transportation cost from ai to bi, and di represents the transportation cost from bi to ai.\n\n\nThe last line provides the number of the town from which the carpenter departs s, the number of the mountain village where the pillars are located g, the amount of money V received from the lord, and the cost of the pillars P.\n\nOutput\n\nOutput the reward for the carpenter (an integer) on a single line.\n\nSample Input\n\n6\n8\n1,2,2,2 \n1,3,4,3 \n1,4,4,2 \n2,5,3,2 \n3,4,4,2 \n3,6,1,2 \n4,6,1,1 \n5,6,1,2 \n2,4,50,30\n\nOutput for the Sample Input\n\n11\n",
    "buggy": "http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117\n\nINF = 1e12\n\n\ndef dijkstra(graph, source):\n    lg = len(graph)\n    unused = list(range(lg))\n    d = [INF] * (lg)\n    d[source] = 0\n\n    while unused:\n        v = min(unused, key=lambda u: d[u])\n        unused.remove(v)\n        for u in range(n + 1):\n            d[u] = min(d[u], d[v] + graph[v][u])\n\n    return d\n\nn = int(input())\nm = int(input())\n\ncost = [[INF] * (n + 1) for i in range(n + 1)]\nfor i in range(m):\n    ai, bi, ci, di = map(int, input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = map(int, input().split(','))\n\nd_go = dijkstra(cost, x1)[x2]\nd_back = dijkstra(cost, x2)[x1]\n\nprint(y1 - y2 - d_go - d_back)",
    "fixed": "INF = 1e12\n\n\ndef dijkstra(graph, source):\n    lg = len(graph)\n    unused = list(range(lg))\n    d = [INF] * (lg)\n    d[source] = 0\n\n    while unused:\n        v = min(unused, key=lambda u: d[u])\n        unused.remove(v)\n        for u in range(n + 1):\n            d[u] = min(d[u], d[v] + graph[v][u])\n\n    return d\n\nn = int(input())\nm = int(input())\n\ncost = [[INF] * (n + 1) for i in range(n + 1)]\nfor i in range(m):\n    ai, bi, ci, di = map(int, input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = map(int, input().split(','))\n\nd_go = dijkstra(cost, x1)[x2]\nd_back = dijkstra(cost, x2)[x1]\n\nprint(y1 - y2 - d_go - d_back)"
  },
  {
    "problem_id": "p00118",
    "problem_statement": "Land Distribution\n\n  Mr. Tanaka has passed away and left a field of HW acres that is divided into HxW squares in the orchard. The orchard has three types of plants: apples, oysters, and oranges, and each square contains one of them. Mr. Tanaka left the inheritance instruction as follows:\n\nDistribute the land as much as possible to the relatives, but if two adjacent trees are the same, the border of the land is not determined, and they are treated as one plot of land.\n\n  For example, a 3x10 orchard ('リ' represents apples, 'カ' represents oysters, and 'ミ' represents oranges) is shown in the following figure.\n\n\n\n\n\nAdjust the boundary by removing the same species of planted trees, resulting in the following figure.\n\n\n\n\n\n  Therefore, it can be divided into 10 plots, corresponding to at most 10 people.\n\n\nThe distribution must be completed before the border between each plot is no longer visible due to snow (i.e., before winter). The objective of completing the distribution task is to determine how many relatives can be assigned land based on the orchard map.\n\n\nWrite a program that reads the orchard map and outputs the number of relatives who will receive land.\n\nInput\n\nMultiple data sets will be provided; the input ends with 0 0. Each data set starts with a line containing H and W. Separate them by a single space. The next H lines contain H × W characters. The string shall only contain the following characters: whitespace, \"@\" representing an apple, \"#\" representing an oyster, \"*\" representing an orange.\n\nNo more than 20 datasets will be provided.\nOutput\nFor each test dataset, output the number of relatives who will receive land in one line.\nSample Input\n\n10 10\n####\n#####@@\n@#\n@@@@@#*#*\n@##***@@@*\n#****#*@**\n##@*#@@*##\n*@@@@*@@@#\n***#@*@##*\n*@@@*@@##@\n*@*#*@##**\n@****#@@#@ \n0 0\n\"\"\"\n\nSample Output\n\n\n33",
    "buggy": "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef search(values,hp,vp,item):\n\tif not (0<=hp<len(values)): return\n\tif not (0<=vp<len(values[hp])): return\n\tif item!=values[hp][vp]: return\n\tvalues[hp][vp]=True\n\tfor dh,dv in list([0,1],[0,-1],[1,0],[-1,0]):\n\t\tsearch(values,hp+dh,vp+dv,item)\n#\tsearch(values,hp-1,vp,item)\n#\tsearch(values,hp+1,vp,item)\n#\tsearch(values,hp,vp-1,item)\n#\tsearch(values,hp,vp+1,item)\n\ndef solve(values):\n\tcount,valid_items=0,set(['@','#','*'])\n\tfor i in range(len(values)):\n\t\tfor j in range(len(values[i])):\n\t\t\tif values[i][j] in valid_items:\n\t\t\t\tsearch(values,i,j,values[i][j])\n\t\t\t\tcount+=1\n\treturn count\n\ndef main():\n\tline = input().strip()\n\twhile line!='0 0':\n\t\tH,W = list(map(int,line.split(' ')))\n\t\tvalues = list()\n\t\tfor _ in range(H):\n\t\t\tvalues.append(list(input().strip()))\n\t\tprint(solve(values))\n\t\tline = input().strip()\n\nif __name__=='__main__':\n\tmain()",
    "fixed": "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef search(values,hp,vp,item):\n\tif not (0<=hp<len(values)): return\n\tif not (0<=vp<len(values[hp])): return\n\tif item!=values[hp][vp]: return\n\tvalues[hp][vp]=True\n\tfor dh,dv in [[0,1],[0,-1],[1,0],[-1,0]]:\n\t\tsearch(values,hp+dh,vp+dv,item)\n#\tsearch(values,hp-1,vp,item)\n#\tsearch(values,hp+1,vp,item)\n#\tsearch(values,hp,vp-1,item)\n#\tsearch(values,hp,vp+1,item)\n\ndef solve(values):\n\tcount,valid_items=0,set(['@','#','*'])\n\tfor i in range(len(values)):\n\t\tfor j in range(len(values[i])):\n\t\t\tif values[i][j] in valid_items:\n\t\t\t\tsearch(values,i,j,values[i][j])\n\t\t\t\tcount+=1\n\treturn count\n\ndef main():\n\tline = input().strip()\n\twhile line!='0 0':\n\t\tH,W = list(map(int,line.split(' ')))\n\t\tvalues = list()\n\t\tfor _ in range(H):\n\t\t\tvalues.append(list(input().strip()))\n\t\tprint(solve(values))\n\t\tline = input().strip()\n\nif __name__=='__main__':\n\tmain()"
  },
  {
    "problem_id": "p00119",
    "problem_statement": "Taro's Persistence\n\nA serious incident occurred at Taro-kun's house, who loves manju. One of the three manju offered at the Buddhist altar in the Japanese-style room was missing. Taro-kun, who had been aiming to eat it as a snack someday, began an investigation to find the culprit. That day, it was found that several people had entered the Japanese-style room. Therefore, in order to investigate the order in which these suspects entered the room, it was decided to have everyone give testimony in the following format.\n\n\nSuspect A's testimony: \"I entered the room before suspect B.\"\n\n\nOne of the suspects (?) is a calico cat named Tama, so he cannot testify, but fortunately Taro-kun saw him enter the room last.\n\n\nFrom these testimonies, Taro-kun decided to deduce the order in which the suspects entered the room to assist in the investigation.\n\n\nFor example, suppose there are six suspects and Tama is number 2. In this case, the following testimonies were obtained:\n\n\nSuspect 5: \"I entered the room before 2.\"\nSuspect 1: \"I entered the room before 4.\"\nSuspect 3: \"I entered the room before 5.\"\nSuspect 4: \"I entered the room before 2.\"\nSuspect 1: \"I entered the room before 6.\"\nSuspect 6: \"I entered the room before 4.\"\nSuspect 3: \"I entered the room before 4.\"\n\n\nBy combining these testimonies, the order in which the suspects entered the room can be narrowed down to one of several possibilities, such as:\n\n\n3 → 5 → 1 → 6 → 4 → 2\n1 → 6 → 3 → 4 → 5 → 2\n3 → 1 → 6 → 5 → 4 → 2\n\n\nCreate a program that deduces the order in which the suspects entered the room from the testimonies of all suspects except Tama (suspect 2) and outputs one of the possible orders. However, there may be suspects who give multiple testimonies, but all testimonies are assumed to be true and not contradictory.\n\n\nInput\n\nThe input is given in the following format:\n\n\nm\nn\nx1 y1\nx2 y2\n:\nxn yn\n\n\nThe first line contains the number of suspects m (m ≤ 20), and the second line contains the number of testimonies n (n ≤ 100). The i-th testimony consists of the values xi and yi, which represent \"Suspect xi (I) entered the room before suspect yi\".\n\nOutput\n\nOutput the order in which the suspects entered the room, starting with the suspect who entered the room first, followed by the second, and so on, up to suspect m, one per line.\n\nSample Input\n\n6\n7\n5 2\n1 4\n3 5\n4 2\n1 6\n6 4\n3 4\n\nOutput for the Sample Input\n\n3\n5\n1\n6\n4\n2\n",
    "buggy": "def solve(a,M):\n\tfor x,y in xy:\n\t\tif x in a and (y not in a or a.index(x) > a.index(y)):\n\t\t\tbreak\n\telse:\n\t\tif len(a) == m: return a\n\t\treturn max([solve([M[i]] + a,M[:i]+M[i+1:]) for i in range(len(M))])\n\nm = eval(input())\nxy = [list(map(int,input().split())) for i in range(eval(input()))]\nM = list(range(m))\nans = solve([],list(range(1,m+1)))\nfor i in ans: print(i)",
    "fixed": "def solve(a,M):\n\tfor x,y in xy:\n\t\tif x in a and (y not in a or a.index(x) > a.index(y)):\n\t\t\tbreak\n\telse:\n\t\tif len(a) == m: return a\n\t\tfor i in range(len(M)):\n\t\t\tr =  solve([M[i]] + a,M[:i]+M[i+1:])\n\t\t\tif r:\n\t\t\t\treturn r\n\nm = eval(input())\nxy = [list(map(int,input().split())) for i in range(eval(input()))]\nM = list(range(m))\nans = solve([],list(range(1,m+1)))\nfor i in ans: print(i)"
  },
  {
    "problem_id": "p00120",
    "problem_statement": "Pastry Chef\n\nA cake shop has made a lot of Swiss rolls of different sizes. You have been assigned a job of arranging these cakes in a box.\n\n\nSwiss rolls are very soft, so if another Swiss roll is placed on top of one, the first one will be crushed. Therefore, all Swiss rolls must be arranged so that they touch the bottom of the box, as shown in Figure (a). If you change the arrangement, the required width will also change.\n\n\n\n\nFigure (a)\n\n\n\nFigure (b)\n\n\n\n\nRead the radius r1, r2, ...,  rn of n Swiss rolls and the length of the box, and for each of them, create a program that determines whether they fit well in the box and outputs \"OK\" if they fit well by designing their order, or \"NA\" if they cannot be fitted no matter how they are arranged.\n\n\nThe cross section of the Swiss roll is a circle, and the height of the box wall is sufficiently high. However, the radius of the Swiss roll is an integer between 3 and 10. In other words, there is no extreme difference in the radius of the cake, and small cakes do not get stuck between large cakes as shown in Figure (b).\n\nInput\n\nThe input consists of multiple datasets. Each dataset is given in the following format.\n\n\nW r1 r2 ... rn\n\n\nFirst, an integer W (1 ≤ W ≤ 1,000) representing the length of the box is given. Then, an integer ri (3 ≤ ri ≤ 10) representing the radius of each Swiss roll is given separated by a space. The number of cakes n is 12 or less.\n\n\nThe number of datasets does not exceed 50.\n\nOutput\n\nFor each dataset, output \"OK\" or \"NA\" on a single line.\n\nSample Input\n\n30 4 5 6\n30 5 5 5\n50 3 3 3 10 10\n49 3 3 3 10 10\n\nOutput for the Sample Input\n\nOK\nOK\nOK\nNA\n",
    "buggy": "from math import sqrt\nen=list(map(int,input().split()))\nw=en[0]\nr=en[1:]\nlr=len(r)\n\ndp=[[float('inf')]*lr for _ in range(1<<lr)]\nfor i in range(lr):\n    dp[1<<i][i]=r[i]\nfor i in range(1<<lr):\n    for j in range(lr):\n        if i>>j&1:\n            for k in range(len(dp[i^(1<<j)])):\n                dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+2*sqrt(r[k]*r[j]))\n\nans=float('inf')\nfor i in range(lr):\n    ans=min(ans,dp[(1<<lr)-1][i]+r[i])\nif ans<=w:\n    print('OK')\nelse:\n    print('NA')",
    "fixed": "from math import sqrt\nwhile True:\n    try:\n        en=list(map(int,input().split()))\n        w=en[0]\n        r=en[1:]\n        lr=len(r)\n\n        dp=[[float('inf')]*lr for _ in range(1<<lr)]\n        for i in range(lr):\n            dp[1<<i][i]=r[i]\n        for i in range(1<<lr):\n            for j in range(lr):\n                if i>>j&1:\n                    for k in range(len(dp[i^(1<<j)])):\n                        dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+2*sqrt(r[k]*r[j]))\n\n        ans=float('inf')\n        for i in range(lr):\n            ans=min(ans,dp[(1<<lr)-1][i]+r[i])\n        if ans<=w:\n            print('OK')\n        else:\n            print('NA')\n    except:break"
  },
  {
    "problem_id": "p00122",
    "problem_statement": "Pyonkichi's Summer\n\nThere is a park covered with lawn at Aizu University, and there are no trees or buildings to shade the sun. On hot summer days, sprinklers installed in the park operate and spray water on the lawn. Pyonkichi, a frog, lives in this park. Pyonkichi is not good with heat, and on hot summer days when the sun is strong, it will dry out and die if it is not hit by the sprinkler water. The sprinklers installed in the park are set to spray only one at a time to save water, so Pyonkichi must move in accordance with the sprinkler's operation.\n\n\n\n\n\n\n\n(a) Map of the park\n\n\n\n\n\n\n(b) Pyonkichi's jump range\n(c) Sprinkler's spray range\n\n\n\n\n\nThe park is shown in (a) above, and the location in the park is represented by a coordinate of 0-9 for each vertical and horizontal direction, with a black circle indicating the sprinkler and the number indicating the order in which it operates. This is an example and the location and operating order of each sprinkler changes daily.\n\n\nPyonkichi is clumsy, so it can only jump a certain distance to move. The range of Pyonkichi's jumps is shown in (b) above, and it cannot move to any other location. In addition, it consumes a considerable amount of energy with each jump, so it must rest in the water for a while.\n\n\nThe range where the sprinkler can spray water is shown in (c) above, including the coordinates of the sprinkler itself. Each sprinkler stops spraying after a certain period of time and immediately starts the next sprinkler. Pyonkichi will jump only once at this time, and will not jump until the water stops spraying again. In addition, since the four sides of the park are surrounded by scorching asphalt, Pyonkichi will not jump in the direction that goes out of the park.\n\n\n This summer has become a scorching heat. Can Pyonkichi survive? Create a program that reads the initial position of Pyonkichi, the position of the sprinkler, and the operating order, and outputs \"OK\" if there is a moving path that Pyonkichi can survive, or \"NA\" if it will inevitably die. However, assume that the number of sprinklers is up to 10, and Pyonkichi will jump from the initial position at the same time as the first sprinkler is activated.\n\nInput\n\nMultiple datasets are given. Each dataset is given in the following format.\n\n\npx py\nn\nx1 y1 x2 y2 ... xn yn\n\n\nThe first line gives the initial horizontal coordinate px and vertical coordinate py of Pyonkichi.\nThe second line gives the number of sprinklers, n.\nThe third line gives the horizontal coordinate xi and vertical coordinate yi of the i-th sprinkler to operate.\n\n\nThe input ends with two zeros. The number of datasets does not exceed 20.\n\nOutput\n\nFor each dataset, output \"OK\" if Pyonkichi can survive by moving, or \"NA\" if it will inevitably die, on one line.\n\nSample Input\n\n6 1\n10\n6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3\n6 1\n10\n6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0\n0 0\n\nOutput for the Sample Input\n\nOK\nNA\n",
    "buggy": "mv=((2,0),(2,1),(2,-1),(-2,0),(-2,1),(-2,-1),\n    (0,2),(1,2),(-1,2),(0,-2),(1,-2),(-1,-2))\n\nwhile True:\n    x,y=list(map(int,input().split()))\n    if x==y==0:break\n    n=eval(input())\n    pos=list(map(int,input().split()))\n    pos=[(pos[2*i],pos[2*i+1]) for i in range(n)]\n\n    que=[(x,y,0)]\n    while que!=[] and que[0][2]<10:\n        X,Y,p=que[0][0],que[0][1],que[0][2]\n        del que[0]\n        S=set()\n        for k in range(-1,2):\n            for l in range(-1,2):\n                S.add((pos[i][0]+k,pos[i][1]+l,p+1))\n        for dx,dy in mv:\n            mx=X+dx\n            my=Y+dy\n            if 0<=mx<10 and 0<=my<10 and (mx,my,p+1) in S:\n                que.append((mx,my,p+1))\n    if que!=[]:\n        print(\"OK\")\n    else:\n        print(\"NG\")",
    "fixed": "mv=((2,0),(2,1),(2,-1),(-2,0),(-2,1),(-2,-1),\n    (0,2),(1,2),(-1,2),(0,-2),(1,-2),(-1,-2))\n\nwhile True:\n    x,y=list(map(int,input().split()))\n    if x==y==0:break\n    n=eval(input())\n    pos=list(map(int,input().split()))\n    pos=[(pos[2*i],pos[2*i+1]) for i in range(n)]\n\n    que=[(x,y,0)]\n    while que!=[]:\n        X,Y,p=que[0][0],que[0][1],que[0][2]\n        del que[0]\n        S=set()\n        if p>=n:\n            print(\"OK\")\n            break\n        for k in range(-1,2):\n            for l in range(-1,2):\n                S.add((pos[p][0]+k,pos[p][1]+l,p+1))\n        for dx,dy in mv:\n            mx=X+dx\n            my=Y+dy\n            if 0<=mx<10 and 0<=my<10 and (mx,my,p+1) in S:\n                que.append((mx,my,p+1))\n    else:\n        print(\"NA\")"
  },
  {
    "problem_id": "p00123",
    "problem_statement": "Speed Skating Badge Test\nIn the speed skating badge test, a grade is certified if the prescribed time is exceeded in two distances. For example, to reach grade A, it is required to run 500 m in less than 40.0 seconds and 1000 m in less than 1 minute 23 seconds.\nCreate a program that inputs the time recorded at a speed skating competition (500 m and 1000 m) and outputs the corresponding grade in the speed skating badge test. The prescribed times for the badge test at 500 m and 1000 m are shown in the table below. If the score is lower than E, output \"NA\".\n\n\n 500 M1000 M\nAAA   35.50 1:11.00\n AA   37.50 1:17.00\n A    40.00 1:23.00\n  B    43.00 1:29.00\n  C    50.00 1:45.00\n  D    55.00 1:56.00\n  E  1:10.00 2:28.00\n\n\nInput\nMultiple datasets are given. For each dataset, two real numbers t1 and t2 (8.0 ≤ t1, t2 ≤ 360.0) representing the time for 500 m and 1000 m, respectively, are given separated by a space. t1 and t2 are given as real numbers including up to 2 decimal places in seconds.\nThe number of datasets is no more than 100.\nOutput\nFor each dataset, output the judgment result AAA to E or NA on one line.\nSample Input\n\n40.0 70.0\n72.5 140.51\n\nOutput for the Sample Input\n\nB\nNA\n",
    "buggy": "# -*- coding:utf-8 -*-\n\nimport sys\n\nt = [\n{\"name\":\"AAA\",\"a\":35.5,\"b\":71.0},\n{\"name\":\"AA\" ,\"a\":37.5,\"b\":77.0},\n{\"name\":\"A\"  ,\"a\":40.0,\"b\":83.0},\n{\"name\":\"B\"  ,\"a\":43.0,\"b\":89.0},\n{\"name\":\"C\"  ,\"a\":50.0,\"b\":105.0},\n{\"name\":\"D\"  ,\"a\":55.0,\"b\":116.0},\n{\"name\":\"E\"  ,\"a\":70.5,\"b\":148.0},\n]\n\nwhile True:\n\ts = sys.stdin.readline()\n\tif not s: break\n\ta, b = [ float(x) for x in s.split() ]\n\tf = [ x for x in t if x[\"a\"] > a and x[\"b\"] > b ]\n\tif len(f) == 0 :\n\t\tprint(\"NA\")\n\telse:\n\t\tprint(f[0][\"name\"])\n\t\n\t",
    "fixed": "# -*- coding:utf-8 -*-\n\nimport sys\n\nt = [\n{\"name\":\"AAA\",\"a\":35.5,\"b\":71.0},\n{\"name\":\"AA\" ,\"a\":37.5,\"b\":77.0},\n{\"name\":\"A\"  ,\"a\":40.0,\"b\":83.0},\n{\"name\":\"B\"  ,\"a\":43.0,\"b\":89.0},\n{\"name\":\"C\"  ,\"a\":50.0,\"b\":105.0},\n{\"name\":\"D\"  ,\"a\":55.0,\"b\":116.0},\n{\"name\":\"E\"  ,\"a\":70.0,\"b\":148.0},\n]\n\nwhile True:\n\ts = sys.stdin.readline()\n\tif not s: break\n\ta, b = [ float(x) for x in s.split() ]\n\tf = [ x for x in t if x[\"a\"] > a and x[\"b\"] > b ]\n\tif len(f) == 0 :\n\t\tprint(\"NA\")\n\telse:\n\t\tprint(f[0][\"name\"])\n\t\n\t"
  },
  {
    "problem_id": "p00124",
    "problem_statement": "League Standings Score Sheet\n\nThere are league and tournament games in sports. In soccer leagues, points are awarded for wins, losses, and draws, and rankings are determined by those points. The points awarded for each are as follows: win (3 points), loss (0 points), and draw (1 point).\n\n\nCreate a program that inputs the number of teams and their league record, sorts them in order of good performance (based on the number of points) and outputs the team name and points. In case of a tie in points, output in the order of input.\n\nInput\n\nMultiple data sets will be given. Each data set will be in the following format:\n\n\nn\nname1 w1 l1 d1\nname2 w2 l2 d2\n:\nnamen wn ln dn\n\n\nThe number of teams, n (n ≤ 10), is given on the first line. On the following n lines, the name namei of team i (up to 20 alphabets), the number of wins wi, the number of losses li, and the number of draws di (0 ≤ wi, li, di ≤ 9) are given, separated by spaces.\n\n\nWhen the number of teams is 0, the input is terminated. The number of data sets will not exceed 50.\n\nOutput\n\nFor each data set, output a list of the sorted teams. On the i-th line, output the name and points of the i-th team separated by a comma.\n\n\nInsert one blank line between data sets.\n\nSample Input\n\n4\nJapan 1 0 2\nEgypt 1 2 0\nCanada 0 2 1\nSpain 2 0 1\n3\nIndia 0 2 0\nPoland 1 0 1\nItaly 1 0 1\n0\n\nOutput for the Sample Input\n\nSpain,7\nJapan,5\nEgypt,3\nCanada,1\n\nPoland,4\nItaly,4\nIndia,0\n",
    "buggy": "N = eval(input())\nwhile True:\n    dic = {}\n    for i in range(N):\n        lis = input().split()\n        dic[lis[0]] = [3*int(lis[1])+int(lis[3]), N-i]\n    \n    for k, v in sorted(list(dic.items()), key=lambda x: (x[0][0], x[0][1]), reverse=True):\n        print('%s,%s' % (k, v[0]))\n\n    N = eval(input())\n    if N == 0: break\n    print()",
    "fixed": "N = eval(input())\nwhile True:\n    dic = {}\n    for i in range(N):\n        lis = input().split()\n        dic[lis[0]] = [3*int(lis[1])+int(lis[3]), N-i]\n    \n    for k, v in sorted(list(dic.items()), key=lambda x: (x[1][0], x[1][1]), reverse=True):\n        print('%s,%s' % (k, v[0]))\n\n    N = eval(input())\n    if N == 0: break\n    print()"
  },
  {
    "problem_id": "p00125",
    "problem_statement": "Number of Days\nWrite a program that takes two dates as input and outputs the number of days between those two dates. Date 1 (y1, m1, d1) is the same as or earlier than date 2 (y2, m2, d2), and date 1 is included in the count, but date 2 is not. Please calculate taking leap years into consideration. The conditions for leap years are as follows:\n\nThe year is divisible by 4.\nHowever, years divisible by 100 are not leap years.\nYears divisible by 400 are leap years.\n\nInput\nMultiple datasets will be given. The format for each dataset is as follows:\n\ny1 m1 d1 y2 m2 d2\n\nIf any of y1, m1, d1, y2, m2, or d2 is a negative number, the input will end.\nThe number of datasets will not exceed 50.\nOutput\nFor each dataset, output the number of days on one line.\nSample Input\n\n2006 9 2 2006 9 3\n2006 9 2 2006 11 11\n2004 1 1 2005 1 1\n2000 1 1 2006 1 1\n2000 1 1 2101 1 1\n-1 -1 -1 -1 -1 -1\n\nOutput for the Sample Input\n\n1\n70\n366\n2192\n36890\n",
    "buggy": "def uru(y):\n    return y % 4 == 0 and y % 100 != 0 or y % 400 == 0\n\ndef y_to_d(y):\n    ret = 0\n    for i in range(y):\n        if uru(i):\n            ret += 366\n        else:\n            ret += 365\n    return ret\n\nmonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\ndef m_to_d(y, m):\n    m -= 1\n    ret = 0\n    for i in range(m-1):\n        ret += month[i]\n    if m >= 2 and uru:\n        ret += 1\n    return ret\n\n\nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, input().split())\n    if min(y1, m1, d1, y2, m2, d2) < 0:\n        quit()\n    ymd1 = y_to_d(y1) + m_to_d(y1, m1) + d1\n    ymd2 = y_to_d(y2) + m_to_d(y2, m2) + d2\n    print(ymd2 - ymd1)\n",
    "fixed": "def uru(y):\n    return y % 4 == 0 and y % 100 != 0 or y % 400 == 0\n\ndef y_to_d(y):\n    ret = 0\n    for i in range(y):\n        if uru(i):\n            ret += 366\n        else:\n            ret += 365\n    return ret\n\nmonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\ndef m_to_d(y, m):\n    m -= 1\n    ret = 0\n    for i in range(m):\n        ret += month[i]\n    if m >= 2 and uru(y):\n        ret += 1\n    return ret\n\n\nwhile True:\n    y1, m1, d1, y2, m2, d2 = map(int, input().split())\n    if min(y1, m1, d1, y2, m2, d2) < 0:\n        quit()\n    ymd1 = y_to_d(y1) + m_to_d(y1, m1) + d1\n    ymd2 = y_to_d(y2) + m_to_d(y2, m2) + d2\n    print(ymd2 - ymd1)\n\n"
  },
  {
    "problem_id": "p00126",
    "problem_statement": "Puzzle\n\nTarou-kun is playing a puzzle game where he has to arrange the numbers 1 to 9 in a 9x9 grid. The rules for arranging the numbers are as follows:\n\n\nEach number can appear only once in each column\nEach number can appear only once in each row\nEach number can appear only once in each 3x3 sub-grid\n\n\nFor example, Figure 1 below shows a valid arrangement of the numbers according to these rules. However, Tarou-kun sometimes makes mistakes and creates arrangements that violate one or more of these rules. Figure 2 below shows an example of such an arrangement, where the number \"2\" appears twice in the leftmost column, the number \"1\" does not appear at all in that column, the number \"1\" appears twice in the second column from the left, and the number \"2\" does not appear at all in that column.\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\n\n\n\n\n\nWrite a program to help Tarou-kun by reading the arrangement of the numbers and checking whether it satisfies the rules. If the arrangement violates any of the rules, your program should output the location of the mistake by marking the erroneous number(s) with an asterisk (*) and correct numbers with a space. If a number appears correctly, output a space before it. \n\nInput\n\nThe input consists of multiple datasets. The first line of the input gives the number of datasets n (n ≤ 20). Each dataset consists of 9 lines with 9 characters each, representing the state of the puzzle.\n\nOutput\n\nFor each dataset, output the arrangement of the numbers with asterisks (*) and spaces. Mark erroneous numbers with an asterisk and correct numbers with a space. Output one blank line between datasets.\n\nSample Input\n\n2\n2 1 3 4 5 6 7 8 9\n4 5 6 7 8 9 1 2 3\n7 8 9 1 2 3 4 5 6\n2 3 4 5 6 7 8 9 1\n5 6 7 8 9 1 2 3 4\n8 9 1 2 3 4 5 6 7\n3 4 5 6 7 8 9 1 2\n6 7 8 9 1 2 3 4 5\n9 1 2 3 4 5 6 7 8\n2 1 3 4 5 6 7 8 9\n4 5 6 7 8 9 1 2 3\n7 8 9 1 2 3 4 5 6\n2 3 4 5 6 7 8 9 1\n5 6 7 8 9 1 2 3 4\n8 9 1 2 3 4 5 6 7\n3 4 5 6 7 8 9 1 2\n6 7 8 9 1 2 3 4 5\n9 1 2 3 4 5 6 7 8\n\nOutput for the Sample Input\n\n*2*1 3 4 5 6 7 8 9\n   4 5 6 7 8 9 1 2 3\n   7 8 9 1 2 3 4 5 6\n*2 3 4 5 6 7 8 9 1\n   5 6 7 8 9 1 2 3 4\n   8 9 1 2 3 4 5 6 7\n   3 4 5 6 7 8 9 1 2\n   6 7 8 9 1 2 3 4 5\n   9*1 2 3 4 5 6 7 8\n\n*2*1 3 4 5 6 7 8 9\n   4 5 6 7 8 9 1 2 3\n   7 8 9 1 2 3 4 5 6\n*2 3 4 5 6 7 8 9 1\n   5 6 7 8 9 1 2 3 4\n   8 9 1 2 3 4 5 6 7\n   3 4 5 6 7 8 9 1 2\n   6 7 8 9 1 2 3 4 5\n   9*1 2 3 4 5 6 7 8\n",
    "buggy": "R=[0,3,6]\nN=list(range(9))\nZ=[0]*9\n\nn=eval(input())\nwhile n:\n  M=[]\n  F=[[\" \" for _ in Z] for _ in Z]\n  M=[list(map(int,input().split())) for _ in Z]\n  M1=[[M[y][x] for y in N] for x in N]\n  M2=[[M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3]] for x in R for y in R]\n  for y in N:\n    A=M[y]\n    for x in N:\n      A1=M2[x/3+y/3*3]\n      a=A[x]\n      if A.count(a)>1 or M1[x].count(a)>1 or A1.count(a)>1: F[y][x]=\"*\"\n  for i in N:\n    s=list(zip(F[i],list(map(str,M[i]))))\n    print(\"\".join([a+b for a,b in s]))\n  if n>1: print()\n  n-=1",
    "fixed": "R=[0,3,6]\nN=list(range(9))\nZ=[0]*9\n\nn=eval(input())\nwhile n:\n  M=[]\n  F=[[\" \" for _ in Z] for _ in Z]\n  M=[list(map(int,input().split())) for _ in Z]\n  M1=[[M[y][x] for y in N] for x in N]\n  M2=[M[y][x:x+3]+M[y+1][x:x+3]+M[y+2][x:x+3] for y in R for x in R]\n  for y in N:\n    A=M[y]\n    for x in N:\n      A1=M2[x/3+y/3*3]\n      a=A[x]\n      if A.count(a)>1 or M1[x].count(a)>1 or A1.count(a)>1: F[y][x]=\"*\"\n  for i in N:\n    s=list(zip(F[i],list(map(str,M[i]))))\n    print(\"\".join([a+b for a,b in s]))\n  if n>1: print()\n  n-=1"
  },
  {
    "problem_id": "p00127",
    "problem_statement": "Pager code\n\nOne day, Taro received a strange message that only contained the numbers \"519345213244\". He called his cousin, who is 10 years older than him and sent the message, and she said, \"Oh, I was in a hurry, so I sent it by pager code. It's convenient, isn't it? Take care!\" and hung up. Taro, who knew his cousin was always busy and a bit forceful, reluctantly researched about \"pager code\" and found out that it was a method of input that was popular about 10 years ago.\n\n\nIn \"pager code\", you input one character with two numbers, following the conversion table shown in Figure 1. For example, to input the string \"naruto\", you would type \"519345\". Therefore, every character can be input with two numbers.\n\n\n\nFigure 1\n\n\nWhen mobile phones were not yet widely used, high school students used this method to send messages to their friends' pagers from public phones. There were also high school girls who could do pager code at an incredible speed. Recently, Taro's cousin, who has become busy with work, has unconsciously started typing emails in pager code.\n\n\nTo help Taro, who has been struggling to decipher the messages, please create a program that converts messages using pager code into strings and outputs them. However, use the conversion table shown in Figure 2 to convert only lowercase letters, \".\", \"?\", \"!\", and spaces. For messages that contain characters that cannot be converted, output \"NA\".\n\n\n\nFigure 2\n\nInput\n\nMultiple messages are given. One message (up to 200 characters) is given per line. The total number of messages is no more than 50.\n\nOutput\n\nFor each message, output the converted message or \"NA\" on one line.\n\nSample Input\n\n341143514535\n314\n143565553551655311343411652235654535651124615163\n551544654451431564\n4\n3411\n6363636363\n153414\n\nOutput for the Sample Input\n\nnaruto\nNA\ndo you wanna go to aizu?\nyes sure!\nNA\nna\n?????\nend\n",
    "buggy": "import sys\n\ns = 'abcdefghijklmnopqrstuvwxyz.?! '\nd = {}\nfor y in range(1, 7):\n    for t in range(1, 6):\n        d[(str(y),str(t))] = s[0]\n        s = s[1:]\n\nfor line in sys.stdin:\n    line = line.rstrip()\n    if len(line) % 2 != 0:\n        print('NA')\n        continue\n    ans = ''\n    for i in range(0, len(line), 2):\n        if d[(line[i],line[i+1])]:\n            ans += d[(line[i],line[i+1])]\n        else:\n            print('NA')\n            break\n    else:\n        print(ans)",
    "fixed": "import sys\n\ns = 'abcdefghijklmnopqrstuvwxyz.?! '\nd = {}\nfor y in range(1, 7):\n    for t in range(1, 6):\n        d[(str(y),str(t))] = s[0]\n        s = s[1:]\n\nfor line in sys.stdin:\n    line = line.rstrip()\n    if len(line) % 2 != 0:\n        print('NA')\n        continue\n    ans = ''\n    for i in range(0, len(line), 2):\n        if (line[i],line[i+1]) in d:\n            ans += d[(line[i],line[i+1])]\n        else:\n            print('NA')\n            break\n    else:\n        print(ans)"
  },
  {
    "problem_id": "p00128",
    "problem_statement": "Soroban\n\n\n\n\n\nAt the request of a friend who has just started learning soroban, you are asked to create a program that displays the arrangement of soroban beads. Create a program that takes a number as input and outputs the arrangement of soroban beads. However, assume that the number of digits to be displayed on the soroban is 5, and that the configuration of the beads for numbers 0 to 9 is represented by '*' (half-width asterisk), ' ' (half-width space), and '=' (half-width equal sign) as follows:\n\n\n\n\n\nInput\n\nMultiple test cases are given. Each test case consists of a single line containing a number (integer) of up to 5 digits.\n\n\nThe number of test cases does not exceed 1024.\n\nOutput\n\nFor each test case, output the arrangement of soroban beads. Put a blank line between the test cases.\n\nSample Input\n\n2006\n1111\n\nOutput for the Sample Input\n\n**** \n    *\n=====\n *  *\n**** \n* ***\n*****\n*****\n\n*****\n\n=====\n ****\n*    \n*****\n*****\n*****\n",
    "buggy": "# AOJ 0128 Abacus\n# Python3 2018.6.19 bal4u\n\nabacus = [\n\t[ '*', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ' ],\n\t[ ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*' ],\n\t[ '=', '=', '=', '=', '=', '=', '=', '=', '=', '=' ],\n\t[ ' ', '*', '*', '*', '*', ' ', '*', '*', '*', '*' ],\n\t[ '*', ' ', '*', '*', '*', '*', ' ', '*', '*', '*' ],\n\t[ '*', '*', ' ', '*', '*', '*', '*', ' ', '*', '*' ],\n\t[ '*', '*', '*', ' ', '*', '*', '*', '*', ' ', '*' ],\n\t[ '*', '*', '*', '*', ' ', '*', '*', '*', '*', ' ' ]]\nans = [[0 for c in range(5)] for r in range(8)]\n\nfirst = True\nwhile True:\n\ttry: n = list(input())\n\texcept: break\n\tfor i in range(5-len(n)):\n\t\tfor r in range(8): ans[r][i] = abacus[r][0]\n\tfor i in range(len(n)):\n\t\tfor r in range(8): ans[r][5-len(n)+i] = abacus[r][int(n[i])]\n\tif first: first = False\n\telse: print()\n\tfor r in range(8): print(*ans[r])\n",
    "fixed": "# AOJ 0128 Abacus\n# Python3 2018.6.19 bal4u\n\nabacus = [\n\t[ '*', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ' ],\n\t[ ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*' ],\n\t[ '=', '=', '=', '=', '=', '=', '=', '=', '=', '=' ],\n\t[ ' ', '*', '*', '*', '*', ' ', '*', '*', '*', '*' ],\n\t[ '*', ' ', '*', '*', '*', '*', ' ', '*', '*', '*' ],\n\t[ '*', '*', ' ', '*', '*', '*', '*', ' ', '*', '*' ],\n\t[ '*', '*', '*', ' ', '*', '*', '*', '*', ' ', '*' ],\n\t[ '*', '*', '*', '*', ' ', '*', '*', '*', '*', ' ' ]]\nans = [['' for c in range(5)] for r in range(8)]\n\nfirst = True\nwhile True:\n\ttry: n = list(input())\n\texcept: break\n\tfor i in range(5-len(n)):\n\t\tfor r in range(8): ans[r][i] = abacus[r][0]\n\tfor i in range(len(n)):\n\t\tfor r in range(8): ans[r][5-len(n)+i] = abacus[r][int(n[i])]\n\tif first: first = False\n\telse: print()\n\tfor r in range(8): print(*ans[r], sep='')\n"
  },
  {
    "problem_id": "p00129",
    "problem_statement": "Hide and Seek\n\nTarou doesn't like hide-and-seek. He is always found immediately when he hides, and he can't find the other children who are hiding. Feeling sorry for him, his father made him a super high-performance location search system. With this system, he can accurately locate his friends' positions, including his own position. When he becomes \"it\", he can easily find the children who are hiding. \n\n\n\nTarou came up with the idea of adding a function to the system that determines whether he can be seen by \"it\". If he can do this, even if \"it\" says \"Are you done?\", he can say \"Not yet\" if he is in a visible position, and \"I'm done\" if he is in an invisible position. There are cylindrical walls of various sizes in the park where they always play. The walls cannot be seen from outside, and the inside cannot be seen from inside. If you go inside with \"it\", you can see it unless there is another wall.\n\n\n\n\n\n\nTarou is not good at making software, even though his idea is good. So, as his best friend, you decided to make a software called \"Confirmation System for Not Being Seen by 'it'\" for him. The information of the walls in the park (the center coordinates (wx, wy) and radius r) and the positions of Tarou and \"it\" (Tarou's position coordinates (tx, ty) and \"it\"'s position coordinates (sx, sy)) are given as input, and your task is to create a program that determines whether Tarou can be seen by \"it\" at that position.\n\n\nNote that if Tarou can be seen by \"it\", output Danger, and if he cannot be seen, output Safe. It is assumed that if there is a wall on the line connecting \"it\" and Tarou's position, it cannot be seen, and neither \"it\" nor Tarou are on the wall.\n\nInput\n\nMultiple datasets are given. Each dataset is given in the following format.\n\n\nn\nwx1 wy1 r1\nwx2 wy2 r2\n:\nwxn wyn rn\nm\ntx1 ty1 sx1 sy1\ntx2 ty2 sx2 sy2\n:\ntxm tym sxm sym\n\n\nThe first line contains the number of cylindrical walls n (0 ≤ n ≤ 100), followed by n lines of the center coordinates of the wall i, integers wxi, wyi (0 ≤ wxi, wyi ≤ 255), and the integer ri (1 ≤ ri ≤ 255) indicating the radius.\n\n\nThe following line contains the number of position information of Tarou and \"it\" m (m ≤ 100), followed by m lines of position information i, integers txi, tyi (0 ≤ txi, tyi ≤ 255), and the position coordinates of \"it\" sxi, syi (0 ≤ sxi, syi ≤ 255).\n\n\nIt is assumed that all walls are cylindrical and are inside the park, and not that only part of the cylindrical walls are in the park.\n\n\nThe end of the input is indicated by n = 0. The number of datasets does not exceed ",
    "buggy": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [list(map(int,input().split())) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1 # 両方壁の中\n    elif F==[1,0] or F==[0,1]: c=0 # 片方が壁の中\n    elif F==[0,0]: #両方壁の外\n      a=M.pi/2-M.acos(r/rsw)\n      tmp=(sw[0]*st[0]+sw[1]*st[1])/rsw/rst\n      if abs(abs(tmp)-1)<1e-6: tmp=1\n      b=0#M.acos(tmp/2)\n      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n      else: c=1\n    x.append(c)\n  return all(x)\n\nwhile True:\n  n=eval(input())\n  if n==0: break\n  WP=I(n)\n  P=I(eval(input()))\n  for e in P: print([\"Safe\",\"Danger\"][f(e)])",
    "fixed": "import math as M\ndef R(A): return (A[0]**2+A[1]**2)**.5\ndef I(i): return [list(map(int,input().split())) for _ in [0]*i]\ndef C(a,b): return a>b or abs(a-b)<1e-6\ndef f(e1):\n  tx,ty,sx,sy=e1\n  x=[]\n  for e2 in WP:\n    wx,wy,r=e2\n    wt=[tx-wx,ty-wy]; rwt=R(wt)\n    sw=[wx-sx,wy-sy]; rsw=R(sw)\n    st=[tx-sx,ty-sy]; rst=R(st)\n    F=[rwt<r,rsw<r]\n    if rst==0: c=1\n    elif F==[1,1]: c=1\n    elif F==[1,0] or F==[0,1]: c=0\n    elif F==[0,0]:\n      a=M.pi/2-M.acos(r/rsw)\n      b=M.acos(round((sw[0]*st[0]+sw[1]*st[1])/rsw/rst,4))\n      if C(a,b) and C(rst**2,rsw**2-r**2): c=0\n      else: c=1\n    if c==0: return 0\n    x.append(c)\n  return all(x)\n\nwhile True:\n  n=eval(input())\n  if n==0: break\n  WP=I(n)\n  P=I(eval(input()))\n  for e in P: print([\"Safe\",\"Danger\"][f(e)])"
  },
  {
    "problem_id": "p00131",
    "problem_statement": "Doctor's Photomultiplier Tube\n\nDoctor: Peter, I did it.\n\n\nPeter: Again? What kind of useless invention is it this time?\n\n\nDoctor: I invented a detector for that elusive axion particle.\n\n\nPeter: You mean that the researchers, including the European Organization for Nuclear Research (CERN), are vying for the potential discovery of this particle, correct? Is it real?\n\n\nDoctor: Of course, it's real. I'll omit the detailed explanation, but my special photomultiplier tube with an exceptionally strong built-in magnetic field detects axions by emitting light.\n\n\nPeter: If we can detect it before anyone else, this could be a Nobel Prize-level research rivaling Dr. Koshiba's neutrino discovery. No longer would the lab be known as the \"useless research lab.\"\n\n\nDoctor: Indeed. Drawing inspiration from Dr. Koshiba's \"Super-Kamiokande,\" I've named this machine \"Tadajaokande\" (Freetalker Reminder).\n\n\nPeter: A somewhat forced play on words, but moving on…\n\n\nDoctor: That aside, this machine has some quirks. When an axion particle passes through one of the photomultiplier tubes, the adjacent tubes—up, down, left, and right—react due to sensitivity.\n\n\n\nFig. 1Fig. 2\n\n\n\n\n\n\n★●●●●\n●●●★●\n●●●●●\n●●●●●\n●●★●●\n\n\n\n\n \n \n &",
    "buggy": "def f(x,y):\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return\nR=list(range(10))\nn=eval(input())\nfor _ in [0]*n:\n  A=[list(map(int,input().split())) for i in R]\n  for p in range(1024):\n    B=A[:]\n    x=[]\n    for j in R:\n      if j==0: a=list(map(int,list(format(p,'010b'))))\n      else: a=B[j-1]\n      for i in R:\n        if a[i]==1:\n          x.append((i,j))\n          f(i,j)\n    if sum(B[9])==0: break\n  for i,j in x: A[j][i]=1\n  for e in A: print(\" \".join(map(str,e)))",
    "fixed": "def f(x,y):\n  global B\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return\nR=list(range(10))\nn=eval(input())\nfor _ in [0]*n:\n  A=[list(map(int,input().split())) for _ in R]\n  for p in range(1024):\n    B=[A[i][:] for i in R]\n    x=[]\n    for j in R:\n      if j==0: a=list(map(int,list(format(p,'010b'))))\n      else: a=B[j-1]\n      for i in R:\n        if a[i]==1:\n          x.append((i,j))\n          f(i,j)\n    if sum(B[9])==0: break\n  for i,j in x: B[j][i]=1\n  for e in B: print(\" \".join(map(str,e)))"
  },
  {
    "problem_id": "p00133",
    "problem_statement": "Rotation of Pattern\n\nCreate a program that rotates an 8x8 pattern right by 90 degrees, 180 degrees, and 270 degrees and outputs it.\n\nInput\n\nAn 8x8 pattern consisting of alphanumeric characters, half-width sharp \"#\" and asterisk \"*\" is given.\n\nOutput\n\nOutput the rotated pattern in the following format.\n\n\n90 (fixed-width numbers)\nPattern rotated by 90 degrees\n180 (fixed-width numbers)\nPattern rotated by 180 degrees\n270 (fixed-width numbers)\nPattern rotated by 270 degrees\n\nSample Input\n\n#*******\n#*******\n#*******\n#*******\n#*******\n#*******\n#*******\n########\n\nOutput for the Sample Input\n\n90\n########\n#*******\n#*******\n#*******\n#*******\n#*******\n#*******\n#*******\n180\n########\n*******#\n*******#\n*******#\n*******#\n*******#\n*******#\n*******#\n270\n*******#\n*******#\n*******#\n*******#\n*******#\n*******#\n*******#\n########\n",
    "buggy": "m=[input() for _ in range(8)]\nfor i in range(3):\n    m=list(zip(*m[::-1]))\n    print(90*i)\n    for x in m:\n        print(''.join(x))",
    "fixed": "m=[input() for _ in range(8)]\nfor i in range(3):\n    m=list(zip(*m[::-1]))\n    print(90*(i+1))\n    for x in m:\n        print(''.join(x))"
  },
  {
    "problem_id": "p00135",
    "problem_statement": "The Short and Long Hands of Clocks\n\nWe have received a prank notice from the primitive slow life organization \"Akaruida\". Akaruida is famous for pranks such as throwing pies in the faces of important people, but recently they have become more radical, using gunpowder to scatter rat fireworks at reception venues, etc. The notice reads as follows:\n\n\n---The computer steals human time. Not good.\nWhen the short and long hands of the clock meet, Akaruida will do justice.\nSlow life is great.\n\n\nIt is difficult to understand because it is awkwardly written, but it seems to mean that they will carry out the prank when the short and long hands of the clock overlap.\n\n\nTo be on guard against this prank, create a program that takes the time as input and outputs \"alert\" if the short and long hands are close, \"safe\" if they are far apart, and \"warning\" for all other cases. Here, \"close\" refers to when the angle between the short and long hands is 0° or more and less than 30°, and \"far apart\" refers to when the angle is between 90° and 180° inclusive. The time will be between 00:00 and 11:59.\n\nInput\n\nThe input is given in the following format:\n\n\nn\nhh1:mm1\nhh2:mm2\n:\nhhn:mmn\n\n\nThe first line contains the number of times to be judged n (1 ≤ n ≤ 10000), and the second and subsequent lines give the time to be judged i in the format hhi:mmi.\n\nOutput\n\nOutput the judgment result of time i as \"safe\", \"warning\", or \"alert\" on separate lines in order.\n\nSample Input\n\n4\n02:15\n06:01\n11:55\n10:40\n\nOutput for the Sample Input\n\nalert\nsafe\nalert\nwarning\n",
    "buggy": "\nn = eval(input())\nfor i in range(n):\n    h,m = list(map(int, input().split(\":\")))\n    sangle = 1.0 * 360 * (h * 60 + m) / 720\n    langle = 1.0 * 360 * m / 60\n    angle = abs(sangle - langle)\n    if angle > 180:\n        angle = 360 - d\n    if (0 <= angle < 30):\n        print(\"alert\")\n    elif (90 <= angle <= 180):\n        print(\"safe\")\n    else:\n        print(\"warning\")",
    "fixed": "\nn = eval(input())\nfor i in range(n):\n    h,m = list(map(int, input().split(\":\")))\n    sangle = 1.0 * 360 * (h * 60 + m) / 720\n    langle = 1.0 * 360 * m / 60\n    angle = abs(sangle - langle)\n    if angle > 180:\n        angle = 360 - angle\n    if (0 <= angle < 30):\n        print(\"alert\")\n    elif (90 <= angle <= 180):\n        print(\"safe\")\n    else:\n        print(\"warning\")"
  },
  {
    "problem_id": "p00136",
    "problem_statement": "Frequency Distribution\n\nCreate a program that inputs the height data of students measured in a health checkup and outputs a frequency distribution. The classification of the frequency distribution should be in 6 classes with a 5 cm increment, and the frequency should be displayed as the number of people with an asterisk (*). However, if the frequency (number of people) for that class is 0, only output the heading for that class.\n\nInput\n\nThe input is given in the following format.\n\n\nn\nh1\nh2\n:\nhn\n\n\nThe first line contains the number of students n (1 ≤ n ≤ 40), and from the second line onwards, each line contains the height hi (150.0 ≤ hi ≤ 190.0, up to the first decimal place) of the i-th student.\n\nOutput\n\nOutput the frequency distribution in the following format.\n\n\n1: number of people with height less than 165.0\n2: number of people with height between 165.0 and below 170.0\n3: number of people with height between 170.0 and below 175.0\n4: number of people with height between 175.0 and below 180.0\n5: number of people with height between 180.0 and below 185.0\n6: number of people with height 185.0 or more\n\nSample Input 1\n\n4\n180.3\n168.2\n165.5\n175.3\n\nSample Output 1\n\n1:\n2:**\n3:\n4:*\n5:*\n6:\n\nSample Input 2\n\n21\n179.4\n171.5\n156.6\n173.0\n169.4\n181.2\n172.4\n170.0\n163.6\n165.9\n173.5\n168.2\n162.5\n172.0\n175.1\n172.3\n167.5\n175.9\n186.2\n168.0\n178.6\n\nSample Output 2\n\n1:*** \n2:***** \n3:*******\n4:**** \n5:* \n6:*\n",
    "buggy": "n = int(input())\n[out1, out2, out3, out4, out5, out6] = [0 for i in range(6)] \nfor i in range(n):\n    k = float(input())\n    if k < 165.0: out1 += 1\n    elif 165.0 <= k < 170.0: out2 += 1\n    elif 170.0 <= k < 175.0: out3 += 1\n    elif 175.0 <= k < 180.0: out4 += 1\n    elif 180.0 <= k < 185.0: out5 += 1\n    elif 185.0 >= k: out6 += 1\n\nfor j,k in zip([i for i in range(1,7)],[out1, out2, out3, out4, out5, out6]):\n    print(str(j) + ':' + '*'*k)",
    "fixed": "n = int(input())\n[out1, out2, out3, out4, out5, out6] = [0 for i in range(6)] \nfor i in range(n):\n    k = float(input())\n    if k < 165.0: out1 += 1\n    elif 165.0 <= k < 170.0: out2 += 1\n    elif 170.0 <= k < 175.0: out3 += 1\n    elif 175.0 <= k < 180.0: out4 += 1\n    elif 180.0 <= k < 185.0: out5 += 1\n    elif 185.0 <= k: out6 += 1\n\nfor j,k in zip([i for i in range(1,7)],[out1, out2, out3, out4, out5, out6]):\n    print(str(j) + ':' + '*'*k)"
  },
  {
    "problem_id": "p00137",
    "problem_statement": " Square Take Center Method \n\nWe will create a program for the classic random number generation method called the Square Take Center Method. The square take center method is a method proposed by von Neumann in the mid-1940s.\n\n\nWhen the number of digits of the generated random number is n, the square of the initial value s is calculated, and that value is regarded as a 2n-digit number (when the number of digits obtained by squaring is insufficient, 0 is added as necessary), and the first n digits in the middle are taken as the initial random number. Next, this random number is squared, and in the same way, the middle n digits are taken as the next random number. For example, when the initial value is 123:\n\n\n1232 = 00015129 → 0151\n1512  = 00022801 → 0228\n2282  = 00051984 → 0519\n5192  = 00269361 → 2693\n26932  = 07252249 → 2522\n\n\nThis method is used to create a program that takes the initial value s (a positive integer less than 10000) as input and generates 10 random numbers for the case where n = 4.\n\nInput\n\nMultiple datasets are given. The number of datasets d (d ≤ 10) is given on the first line. For each dataset, the initial value s (an integer, 1 ≤ s < 10000) is given on one line.\n\nOutput\n\nFor each dataset:\n\n\nCase x: (x is the dataset number starting from 1)\nThe first generated random number (integer)\nThe second generated random number (integer)\n:\n:\nThe 10th generated random number (integer)\n\n\nPlease output.\n\nSample Input\n\n2\n123\n567\n\nOutput for the Sample Input\n\nCase 1:\n151\n228\n519\n2693\n2522\n3604\n9888\n7725\n6756\n6435\nCase 2:\n3214\n3297\n8702\n7248\n5335\n4622\n3628\n1623\n6341\n2082\n",
    "buggy": "k = int(input())\n\nfor j in range(k):\n\tx = int(input())\n\n\tprint((\"Case \" + str(k + 1)))\n\tfor i in range(10):\n\t\tx = \"00000000\" + str(x**2)\n\t\tx = int(x[-6:-2])\n\t\tprint(x)",
    "fixed": "n = int(input())\n\nfor j in range(n):\n\tx = int(input())\n\n\tprint((\"Case \" + str(j + 1) + \":\"))\n\tfor i in range(10):\n\t\tx = \"00000000\" + str(x**2)\n\t\tx = int(x[-6:-2])\n\t\tprint(x)"
  },
  {
    "problem_id": "p00139",
    "problem_statement": "Snake\n\nIn a certain world, there are strange snakes made up of only characters. Currently, two types of snakes, A and B, have been confirmed, but there may be other types as well.\n\n\nType A starts with a \">'\" followed by one or more \"=\" and then a \"#\" character. This is followed by the same number of \"=\" as before and ends with a \"~\" (tilde).\n\n\nType B starts with a \">^\" followed by one or more \"Q=\" and ends with \"~~\".\n\n\nExample of type A: >'====#====~        >'==#==~\n\n\nExample of type B: >^Q=Q=Q=Q=~~        >^Q=Q=~~\n\n\nCreate a program that receives a string representing a snake as input data, identifies its type, and outputs \"A\" if it is type A, \"B\" if it is type B, and \"NA\" if it is another type.\n\nInput\n\nThe input is given in the following format.\n\n\nn\nS1\nS2\n:\nSn\n\n\nThe first line contains the number of snakes to be identified, n (1 ≤ n ≤ 10000). The next n lines contain the string representation of the i-th snake (Si) (a string of up to 200 characters without spaces) on each line.\n\nOutput\n\nOn the i-th line, output \"A\", \"B\", or \"NA\" indicating the type of the i-th snake.\n\nSample Input\n\n3\n>'======#======~\n>^Q=Q=Q=Q=Q=Q=Q=Q=Q=~~\n>'===#====~\n\nOutput for the Sample Input\n\nA\nB\nNA\n",
    "buggy": "for _ in [0]*int(input()):\n    s=input()\n    if s[:2]==\">'\" and s[-1]=='~' and '#' in s:\n        s=s[2:-1].split('#')\n        print(['NA','A'][set(s[0])==set(s[1])=={'='} and len(set(s))==1])\n    elif s[:2]=='>^' and s[-2:]=='~~':\n        s=s[2:-2]\n        print(['NA','B'][len(s)==2*s.count('Q=') and len(s)>0])",
    "fixed": "for _ in [0]*int(input()):\n    s=input()\n    if s[:2]==\">'\" and s[-1]=='~' and '#' in s:\n        s=s[2:-1].split('#')\n        print(['NA','A'][set(s[0])==set(s[1])=={'='} and len(set(s))==1])\n    elif s[:2]=='>^' and s[-2:]=='~~':\n        s=s[2:-2]\n        print(['NA','B'][len(s)==2*s.count('Q=') and len(s)>0])\n    else:print('NA')"
  },
  {
    "problem_id": "p00141",
    "problem_statement": "Spiral Pattern\n\nI decided to create a program that displays a \"spiral pattern\". The \"spiral pattern\" is as follows:\n\n\nIf the length of one side is n, it is displayed as a string of n rows and n columns.\nThe pattern is a vortex that rotates clockwise from the lower left corner.\nThe parts with lines are represented by # (sharp symbol), and the blank parts are represented by \" \"(half-width space).\nSpace is placed between lines.\n\n\nCreate a program that outputs the \"spiral pattern\" with one side of length n as input.\n\nInput\n\nThe input is given in the following format.\n\n\nd\nn1\nn2\n:\nnd\n\n\nThe first line gives the number of data sets d (d ≤ 20), and the i-th line following it gives the length of the spiral pattern ni (1 ≤ ni ≤ 100) for the i-th spiral pattern.\n\nOutput\n\nFor each data set, output the spiral pattern. Please insert one blank line between the data sets.\n\nSample Input\n\n2\n5\n6\n\nOutput for the Sample Input \n\n#####\n#   #\n# # #\n# # #\n# ###\n\n######\n#    #\n# ## #\n# #  #\n# #  #\n# ####\n",
    "buggy": "def f(n):\n    spiral = [list(' ' for i in range(n)) for i in range(n)]\n    for i in range(n):\n        spiral[i][0] = '#'\n    for i in range(n):\n        spiral[0][i] = '#'\n    for i in range(n):\n        spiral[i][-1] = '#'\n        \n    return spiral\n        \ndef draw(n, m):\n    #down\n    for w in range(m, n):\n        spiral[n-1][w] = '#'\n    if n-m == 2:\n        return\n    #left\n    for h in range(m, n):\n        spiral[h][m] = '#'\n    if n-m == 3:\n        return\n    #up\n    for w in range(m, n-2):\n        spiral[m][w] = '#'\n    if n-m == 4:\n        return\n    #right\n    for h in range(m, n-2):\n        spiral[h][n-3] = '#'\n    if n-m == 5:\n        return\n        \n    draw(n-2, m+2)\n\nc = 0\nfor i in range(eval(input())):\n    if c != 0:\n        print()\n    n = eval(input())\n    if n == 1:\n        spiral = [['#']]\n    elif n == 2:\n        spiral = [['#'],['#']]\n    elif 3 <= n:\n        spiral = f(n)\n    if 4 <= n:\n        draw(n, 2)\n    for line in spiral:\n        print(''.join(line))\n    c = 1",
    "fixed": "def f(n):\n    spiral = [list(' ' for i in range(n)) for i in range(n)]\n    for i in range(n):\n        spiral[i][0] = '#'\n    for i in range(n):\n        spiral[0][i] = '#'\n    for i in range(n):\n        spiral[i][-1] = '#'\n        \n    return spiral\n        \ndef draw(n, m):\n    #down\n    for w in range(m, n):\n        spiral[n-1][w] = '#'\n    if n-m == 2:\n        return\n    #left\n    for h in range(m, n):\n        spiral[h][m] = '#'\n    if n-m == 3:\n        return\n    #up\n    for w in range(m, n-2):\n        spiral[m][w] = '#'\n    if n-m == 4:\n        return\n    #right\n    for h in range(m, n-2):\n        spiral[h][n-3] = '#'\n    if n-m == 5:\n        return\n        \n    draw(n-2, m+2)\n\nc = 0\nfor i in range(eval(input())):\n    if c != 0:\n        print()\n    n = eval(input())\n    if n == 1:\n        spiral = [['#']]\n    elif n == 2:\n        spiral = [['##'],['# ']]\n    elif 3 <= n:\n        spiral = f(n)\n    if 4 <= n:\n        draw(n, 2)\n    for line in spiral:\n        print(''.join(line))\n    c = 1"
  },
  {
    "problem_id": "p00143",
    "problem_statement": "The Cowherd and the Weaver Girl\n\nThe weaver girl was a child of the heavenly emperor, but at her father's command, she wove the loom even if she opened it. The heavenly emperor enjoyed wearing clothes made of a splendid fabric called cloud brocade woven by the weaver. Cloud brocade had a short lifespan and quickly deteriorated, but the hardworking weaver wove it every day, so there was no problem. The weaver kept her father's command and continued to weave cloud brocade every day, so she had no boyfriend. Feeling sorry for her, her father introduced her to a hardworking cowherd who lived across the Milky Way and gave her in marriage.\n\n\nThen the weaver became fascinated with the joy of marriage and played with the cowherd, neglecting her work such as weaving the loom. As a result, the heavenly emperor's favorite cloud brocade clothes became tattered and could not be newly tailored.\n\n\nHer father was angry about this and he wanted to bring back the weaver to the palace. However, he could not appear in front of the cowherd, who was a human, in tattered clothes. He thought of obstructing the two people who were playing around by creating a triangular wall that would prevent everything else except himself from passing through. Then he declared that he would see the weaver without being found by the cowherd and that he would either weave the loom seriously or forcibly take her back if not. \n\n\n\n\n\n\nTo carry out this plan, the heavenly emperor decided to develop a triangular wall-generation device. Given the positions of the three vertices (xp1, yp1), (xp2, yp2), (xp3, yp3), the position of the cowherd (xk, yk), and the position of the weaver (xs, ys), determine whether the triangle is blocking the cowherd and the weaver, and output OK if it is blocking them, and NG if it is not blocking them. Blocking means that one of the cowherd or the weaver is inside the triangle and the other is outside. The cowherd and the weaver are not on the vertices or edges of the triangle.\n\n\nBecause the weaver and the cowherd change their locations from time to time, the program must input various positional information and answer questions.\n\n\n<!--\n<p>\nThe heavenly emperor ordered the development department to develop a triangular wall generation device for this operation. He intended to order a specification to make a wall by giving three points, but the development department mistakenly developed a system that randomly generates a triangular wall and reports the three points. As the ordering party, the heavenly emperor wanted to order a remake, but the clothes became more and more tattered, so he decided to make minimal corrections. Since it was not something that would happen if a wall was formed randomly, when the triangular wall to be created was determined, he reported the three points, and if it was satisfactory (that is, if the obstruction was successful), the heavenly emperor pressed the OK button to instruct the creation of the wall. If the obstruction was not successful (if the obstruction was incomplete), he would press the NG button and start over. The weaver and the cowherd change their locations from moment to moment. The wall generation device outputs randomly generated three points one after another.\n\n\nWith the given situation, the heavenly emperor was forced to determine whether to instruct the creation of the wall. Therefore, instead of the heavenly emperor, given the positions of the three vertices of the triangle (xp1, yp1), (xp2, yp2), (xp3, yp3), the position of the cowherd (xk, yk), and the position of the weaver (xs, ys), determine whether the triangle is blocking the cowherd and the weaver, and output OK if it is blocking them, and NG if it is not blocking them. Blocking means that one of the cowherd or the weaver is",
    "buggy": "def isin(x,y):\n    if S(x1,y1,x2,y2,x,y)+S(x1,y1,x3,y3,x,y)+S(x3,y3,x2,y2,x,y)-S(x1,y1,x2,y2,x3,y3) != 0:\n        return False\n    else:\n        return True\n\ndef S(x1,y1,x2,y2,x3,y3):\n    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\n\nfor roop in range(int(input())):\n    x1,y1,x2,y2,x3,y3,xk,yk,xs,ys = list(map(int,input().split()))\n    print(\"OK\" if isin(xk,yk) != isin(xs,ys) else \"NO\")",
    "fixed": "def isin(x,y):\n    if S(x1,y1,x2,y2,x,y)+S(x1,y1,x3,y3,x,y)+S(x3,y3,x2,y2,x,y)-S(x1,y1,x2,y2,x3,y3) != 0:\n        return False\n    else:\n        return True\n\ndef S(x1,y1,x2,y2,x3,y3):\n    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\n\nfor roop in range(int(input())):\n    x1,y1,x2,y2,x3,y3,xk,yk,xs,ys = list(map(int,input().split()))\n    print(\"OK\" if isin(xk,yk) != isin(xs,ys) else \"NG\")"
  },
  {
    "problem_id": "p00144",
    "problem_statement": "Packet Transfer\n\nIn the internet, data is divided into packets and transferred to the destination via intermediate devices called routers. Each router determines the next router to transfer based on the destination described in the packet. In addition, to prevent packets from being transferred between routers indefinitely, a value called TTL (Time To Live) is added to the packet. The router subtracts 1 from the TTL of the received packet, and if the result is 0, the packet is discarded, otherwise it is forwarded to the next router.\n\nTherefore, you are asked to create a program to assist in network design. Given the connection information of the network and the information of the transmitted packet, create a program that displays the minimum value of the number of routers passed through until each packet reaches the destination router.\n\nThe network consists of multiple routers and cables connecting them, as shown in the figure. However, be aware that each connection (cable) is one-way. The array of numbers identifying the routers directly connected to each router is given as the network connection information. Each router is identified by an integer from 1 to n, if there are multiple routes from the source to the destination router, output the value of the fewer routers to be passed through. If the packet cannot reach the destination, output NA.\n\nFor example, consider the case where the source router is 6 and the destination router is 5 in the network shown in the figure below. The shortest route is 6 → 1 → 5, and the number of routers passed through is 3. In this case, TTL is subtracted at routers 6 and 1, so the packet can be reached if the TTL at the time of transmission is 3 or more. There is no packet that will be at the same router as the source and destination.\n\n\n\n\n\nInput\n\nThe input is given in the following format.\n\n\nn\nr1 k1 t11 t12 ... t1k1\nr2 k2 t21 t22 ... t2k2\n:\nrn kn tn1 tn2 ... tnkn\np\ns1 d1 v1\ns2 d2 v2\n:\nsp dp vp\n\n\nThe first line contains the total number of routers n (1 ≤ n ≤ 100), and the following n lines give the connection information for each router. For the connection information, the number ri of the i-th router, the number ki of routers directly connected to the i-th router, and the numbers ti1, ti2, ..., tiki of the routers that can be sent from the i-th router are given.\n\nThe following line gives the number of packets p (1 ≤ p ≤ 1000), and the following p lines give the information of each packet. The information of the packet includes the number of the source router si, the number of the destination router di, and the value of TTL vi (0 ≤ vi ≤ 10000).\n\nOutput\n\nFor each packet, output the number of routers passed through or NA on one line.\n\nSample Input\n\n7\n1 4 2 5 4 3\n2 1 5\n3 1 6\n4 1 7\n5 2 7 6\n6 1 1\n7 0\n6\n1 2 2\n1 5 3\n1 2 1\n5 1 3\n6 3 3\n1 7 4\n\nOutput for the Sample Input\n\n2\n2\nNA\n3\n3\n3\n",
    "buggy": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      print(dist + 1)\n      break\n    if dist < v - 1:\n      for to in rlst[node]:\n        if not visited[to]:\n          que.append((to, dist + 1))\n  else:\n    print(\"NA\")\n",
    "fixed": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.popleft()\n    if node == d:\n      if dist < v:\n        print(dist + 1)\n      else:\n        print(\"NA\")\n      break\n    for to in rlst[node]:\n      if not visited[to]:\n        que.append((to, dist + 1))\n        visited[to] = True\n  else:\n    print(\"NA\")\n"
  },
  {
    "problem_id": "p00145",
    "problem_statement": "Cards\n\nThere is a set of cards with positive integers written on them. Create several stacks of cards and stack them horizontally. From these, select two adjacent stacks of cards and stack the left stack as is on top of the right stack. Repeat this operation until there is only one stack of cards left.\n\n\nWhen stacking two stacks of cards, multiply all the numbers written on the top and bottom cards of the two stacks. This product is called the cost of stacking the cards. The cost of stacking all of the stacks of cards together is the sum of all the costs of stacking.\n\n\nThe cost varies depending on the order in which the stacks of cards are stacked. For example, consider the case where there are three stacks of cards. Assume that the numbers written on the top and bottom cards of these stacks of cards are 3 and 5, 2 and 8, and 5 and 4, respectively, in order from left to right. In this case, the cost of stacking the left and middle stacks of cards together is 3 × 5 × 2 × 8 = 240. By stacking them in this way, a stack of cards is created with the top card being 3 and the bottom card being 8.\n\n\nWhen this stack is stacked on top of the right stack, the cost becomes 3 × 8 × 5 × 4 = 480. Therefore, the cost of stacking the stacks of cards in this order to create one stack of cards is 240 + 480 = 720. (Fig. 1)\n\n\nOn the other hand, if you stack the middle and right stacks of cards first and then the left stack last, the cost is 2 × 8 × 5 × 4 + 3 × 5 × 2 × 4 = 440. Therefore, stacking them in this order results in a lower cost. (Fig. 2)\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes as input the number of stacks of cards and the numbers written on the top and bottom cards of each stack of cards, and outputs the minimum cost required to stack the stacks of cards into one stack. The number of stacks of cards is 100 or less, and the input data will not result in a cost greater than 231-1, regardless of the order in which the cost is calculated.\n\nInput\n\nThe input is given in the following format.\n\n\nn\na1 b1\na2 b2\n:\nan bn\n\n\nThe first line contains the number of stacks of cards n (1 ≤ n ≤ 100), and the following n lines contain the numbers written on the top ai (1 ≤ ai ≤ 200) and bottom bi (1 ≤ bi ≤ 200) cards of the i-th stack of cards from left to right.\n\nOutput\n\nOutput the minimum cost required to stack the stacks of cards into one stack on one line.\n\nSample Input\n\n3\n3 5\n2 8\n5 4\n\nOutput for the Sample Input\n\n440\n",
    "buggy": "def dfs(l, r):\n    if l == r:\n        return 0\n    if (l, r) in cache:\n        return cache[(l, r)]\n    cache[(l, r)] = min(dfs(l, m) + dfs(m + 1, r) + L[l][1] * L[m][0] * L[m + 1][1] * L[r][0] for m in range(l, r))\n    return cache[(l, r)]\n\ncache = {}\nL = [list(map(int, input().split())) for _ in range(eval(input()))]\nprint(dfs(0, len(L) - 1))",
    "fixed": "def dfs(l, r):\n    if l == r:\n        return 0\n    if (l, r) in cache:\n        return cache[(l, r)]\n    cache[(l, r)] = min(dfs(l, m) + dfs(m + 1, r) + L[l][0] * L[m][1] * L[m + 1][0] * L[r][1] for m in range(l, r))\n    return cache[(l, r)]\n\ncache = {}\nL = [list(map(int, input().split())) for _ in range(eval(input()))]\nprint(dfs(0, len(L) - 1))"
  },
  {
    "problem_id": "p00146",
    "problem_statement": "Lupin III\n\nLupin III, a famous thief, hears from a beautiful woman named Fujimineko, who is a descendant of an Aizu clan samurai, that the Aizu clan left behind military funds in Aizu-Wakamatsu City. According to the report of Ishikawa Goemon, Lupin's long-time companion, the military funds are stored in several warehouses in wooden boxes. The warehouses are not guarded, but they are locked securely. However, if Goemon uses the secret technique \"Steel Cutting\" that he learned from his father, he can break open the warehouses in an instant.\n\n\n\n\n\n\nThe remaining problem is the transportation of the wooden boxes. Lupin and Goemon, who lack physical strength, cannot carry even one wooden box. Therefore, they rely on a dependable man named Mugen Daisuke for transportation.\nTo transport all the wooden boxes, Lupin devises the following plan:\n\n\nFirst, Lupin will drive to the first warehouse and drop off Goemon and Daisuke.\n\n\nGoemon breaks open the warehouse.\nDaisuke carries all the wooden boxes.\nLupin heads to the next warehouse with the wooden boxes.\n\n\nThis is repeated until all the warehouses are broken open and the wooden boxes are transported. During this time, Lupin prepares a helicopter and carries Goemon, Daisuke, and the wooden boxes to the last warehouse, then escapes. Daisuke can carry anything, no matter how heavy, but his speed decreases depending on the weight of the luggage. Lupin must determine the order in which to break open the warehouses, taking this into account.\n\n\nOn behalf of Lupin, write a program that outputs the order in which to break open the warehouses so that the time from breaking open the first warehouse to reaching the last warehouse is minimized. However,\n\n\nThe warehouses all face a street that runs straight north from Tsuruga Castle. There are at most 15 warehouses, and they are all within 10,000 meters of the castle.\nEach wooden box weighs 20 kilograms. There are at most 10,000 wooden boxes stored in each warehouse.\nTransportation from warehouse to warehouse is done through an underground passage that runs along the street.\nDaisuke moves at a rate of 2,000 / (70 + w) meters per minute when carrying a load of w kilograms.\n\n\n\nFor each warehouse, the input consists of the warehouse number (an integer up to 100), the distance from the castle in meters (an integer between 1 and 10,000), and the number of wooden boxes stored in the warehouse (an integer between 1 and 10,000).\n\nInput\n\nThe input is given in the following format.\n\n\nn\ns1 d1 v1\ns2 d2 v2\n:\nsn dn vn\n\n\nThe first line contains the number of warehouses, n (n ≤ 15), and the following n lines describe the warehouses. Each line gives the warehouse number si (1 ≤ si ≤ 100), the distance from the castle di (1 ≤ di ≤ 10,000), and the number of wooden boxes stored in the warehouse vi (1 ≤ vi ≤ 10,000).\n\nOutput\n\nOutput the order in which to break open the warehouses on a single line, separated by spaces.\n\nSample Input 1\n\n2\n1 100 1\n2 200 2\n\nOutput for the Sample Input 1\n\n1 2\n\nSample Input 2\n\n3\n11 100 1\n13 200 20\n12 300 3\n\nOutput for the Sample Input 2\n\n11 12 13\n\nSample Input 3\n\n5\n13 199 1\n51 1000 1\n37 350 10\n27 300 2\n99 200 1000\n\nOutput for the Sample Input 3\n\n51 37 27 13 99\n",
    "buggy": "def d_init(n):\n  c = 0\n  A = list(D.items())[:]\n  for i, e in A:\n    c += 1\n    for j, f in A[c:]:\n      tmp = abs(e-f)\n      D[(i, j)] = tmp\n      D[(j, i)] = tmp\n  return\n\ndef solve(idx, visited, weight):\n  if visited == (1<<n)-1: return 0, name[idx]\n  tmp1, tmp2 = dp[idx][visited]\n  if tmp1 != 1e12: return tmp1, tmp2\n\n  x1 = 1e12\n  for i in range(n):\n    i1 = 1<<i\n    if (visited & i1) == 0:\n      tmp1, tmp2 = solve(i, visited|i1, weight + W[i])\n      tmp1 += D[(i, idx)] / (weight+70.0)\n      if x1 > tmp1:\n        x1 = tmp1\n        x2 = tmp2\n  x2 = x2 + name[idx]\n  dp[idx][visited] = [x1, x2]\n  return x1, x2\n\nname = {}\nD = {}\nW = {}\nn = eval(input())\ndp = [[[1e12,[]] for _ in [0]*(1<<n)] for _ in [0]*n]\nfor i in range(n):\n  a, b, c = list(map(int, input().split()))\n  name[i] = [a]\n  D[i] = b/2000.0\n  W[i] = c*20\nd_init(n)\n\nans1 = 1e12\nroute = []\nfor i, e in list(W.items()):\n  tmp1, tmp2 = solve(i, 1<<i, e)\n  if ans1 > tmp1:\n    ans1 = tmp1\n    route = tmp2\n\nfor e in route:\n  print(str(e), end=' ')",
    "fixed": "def d_init(n):\n  c = 0\n  A = list(D.items())[:]\n  for i, e in A:\n    c += 1\n    for j, f in A[c:]:\n      tmp = abs(e-f)\n      D[(i, j)] = tmp\n      D[(j, i)] = tmp\n  return\n\ndef solve(idx, visited, weight):\n  if visited == (1<<n)-1: return 0, name[idx]\n  tmp1, tmp2 = dp[idx][visited]\n  if tmp1 != 1e12: return tmp1, tmp2\n\n  x1 = 1e12\n  for i in range(n):\n    i1 = 1<<i\n    if (visited & i1) == 0:\n      tmp1, tmp2 = solve(i, visited|i1, weight + W[i])\n      tmp1 += D[(i, idx)] /2000.0*(weight+70.0)\n      if x1 > tmp1:\n        x1 = tmp1\n        x2 = tmp2\n  x2 = name[idx] + x2\n  dp[idx][visited] = [x1, x2]\n  return x1, x2\n\nname = {}\nD = {}\nW = {}\nn = eval(input())\ndp = [[[1e12,[]] for _ in [0]*(1<<n)] for _ in [0]*n]\nfor i in range(n):\n  a, b, c = list(map(int, input().split()))\n  name[i] = [a]\n  D[i] = b\n  W[i] = c*20\nd_init(n)\n\nans1 = 1e12\nroute = []\nfor i, e in list(W.items()):\n  tmp1, tmp2 = solve(i, 1<<i, e)\n  if ans1 > tmp1:\n    ans1 = tmp1\n    route = tmp2\n\nfor e in route[:-1]:\n  print(str(e), end=' ')\nprint(str(route[-1]))"
  },
  {
    "problem_id": "p00148",
    "problem_statement": "Candy and Class Flag\n\nIn class 3C, it was decided to use the \"Class Flag\" that will be used in the athletic festival on November 10, 2007 at the future class reunion. Therefore, a game was decided using the large amount of candy that the teacher brought as a treat the other day to decide which student will store the \"Class Flag\".\n\n\nEach student takes one candy in order of student number.\nIf there are still candies left after one round, the students will continue to take candies in order of the student numbers starting from the first student.\nThe person who takes the last candy will be the student who will store the \"Class Flag\".\n\n\nClass 3C has 39 students. Their student numbers are from 3C01 to 3C39. For example, if there are 50 candies, after all the students have taken their first candy, there will be 11 candies left. If the students take the remaining candies in order of their student numbers, the last candy will be taken by the student with the student number 3C11. Therefore, the student with the student number 3C11 will store the \"Class Flag\".\n\n\nWrite a program that takes the number of candies as input and outputs the student number of the student who will store the \"Class Flag\".\n\nInput\n\nMultiple test cases are given. Each test case is given in the following format. An integer a (1 ≤ a ≤ 10000), which represents the number of candies, is given on one line. The input processing continues until the end of the input (EOF).\n\n\nThere are no more than 20 datasets.\n\nOutput\n\nFor each test case, output the student number (alphanumeric characters only) of the student who will store the \"Class Flag\" on one line.\n\nSample Input\n\n50\n5576\n5577\n5578\n\nOutput for the Sample Input\n\n3C11\n3C38\n3C39\n3C01\n",
    "buggy": "while True:\n    try:\n        a = int(input())\n    except:\n        break\n    tmp = a - (a // 39) * 39\n    print(\"3C{:02d}\".format(39 if tmp == 39 else tmp))",
    "fixed": "while True:\n    try:\n        a = int(input())\n    except:\n        break\n    tmp = a - (a // 39) * 39\n    print(\"3C{:02d}\".format(tmp if tmp % 39 else 39))"
  },
  {
    "problem_id": "p00149",
    "problem_statement": "Vision Test\n\nCreate a program that receives as input the results of a vision test and outputs, for each eye separately, the number of people classified into each category according to the following table.\n\n\n\nCategoryVision\nA1.1 or higher\nB0.6 or higher, less than 1.1\nC0.2 or higher, less than 0.6\nDless than 0.2\n\n\n\nInput\n\nThe input is given in the following format:\n\n\nl1 r1\nl2 r2\nl3 r3\n:\n:\n\n\nThe i-th line contains two space-separated real numbers li and ri, which represent the vision of the i-th person's left and right eyes, respectively. The vision is given to the nearest 0.1, and is between 0.1 and 2.0 (inclusive).\n\n\n\nThere will be no more than 40 lines in the input.\n\nOutput\n\nOutput the results in the following format:\n\n\nLine 1: The number of people with category A vision in the left eye, followed by the number of people with category A vision in the right eye.\n\nLine 2: The number of people with category B vision in the left eye, followed by the number of people with category B vision in the right eye.\n\nLine 3: The number of people with category C vision in the left eye, followed by the number of people with category C vision in the right eye.\n\nLine 4: The number of people with category D vision in the left eye, followed by the number of people with category D vision in the right eye.\n\nSample Input\n\n1.0 1.2\n0.8 1.5\n1.2 0.7\n2.0 2.0\n\nOutput for the Sample Input\n\n2 3\n2 1\n0 0\n0 0\n",
    "buggy": "def hantei(l):\n    if l >= 1.1:\n        return 'A'\n    elif 0.6 <= l < 1.1:\n        return 'B'\n    elif 0.2 <= l < 0.6:\n        return 'C'\n    elif 0.2 < l:\n        return 'D'\n\nldic = {'A':0, 'B':0, 'C':0, 'D':0}\nrdic = {'A':0, 'B':0, 'C':0, 'D':0}\nls = []\nwhile True:\n    try:\n        l,r = list(map(float,input().split()))\n        ls.append((l,r))\n    except EOFError:\n        break\n        \nfor i,j in ls:\n    ldic[hantei(i)] += 1\n    rdic[hantei(j)] += 1\n    \nfor L,R in zip(sorted(ldic),sorted(rdic)):\n    print(L,R) ",
    "fixed": "def hantei(l):\n    if l >= 1.1:\n        return 'A'\n    elif 0.6 <= l < 1.1:\n        return 'B'\n    elif 0.2 <= l < 0.6:\n        return 'C'\n    elif l  < 0.2 :\n        return 'D'\n\nldic = {'A':0, 'B':0, 'C':0, 'D':0}\nrdic = {'A':0, 'B':0, 'C':0, 'D':0}\nls = []\nwhile True:\n    try:\n        l,r = list(map(float,input().split()))\n        ls.append((l,r))\n    except EOFError:\n        break\n        \nfor i,j in ls:\n    ldic[hantei(i)] += 1\n    rdic[hantei(j)] += 1\n    \nfor L,R in zip(sorted(ldic),sorted(rdic)):\n    print(ldic[L],rdic[R]) "
  },
  {
    "problem_id": "p00150",
    "problem_statement": "\nTwin Prime\n\nPrime numbers are widely applied for cryptographic and communication technology.\nA twin prime is a prime number that differs from another prime number by 2.\nFor example, (5, 7) and (11, 13) are twin prime pairs.\n\n\nIn this problem, we call the greater number of a twin prime \"size of the twin prime.\"\n\n\nYour task is to create a program which reads an integer n and prints a twin prime which has the maximum size among twin primes less than or equals to n\n\n\nYou may assume that 5 ≤ n ≤ 10000.\n\nInput\n\nThe input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:\n\n\nn (integer)\n\nOutput\n\nFor each dataset, print the twin prime p and q (p < q). p and q should be separated by a single space.\n\nSample Input\n\n12\n100\n200\n300\n0\n\nOutput for the Sample Input\n\n5 7\n71 73\n197 199\n281 283\n",
    "buggy": "# -*- coding: utf-8 -*-\n\"\"\"\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\n\n\ndef create_prime_list(limit):\n    \"\"\" ??¨??????????????????????????§limit?????§????´???°?????????????±???????\n    https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9\n    \"\"\"\n    x = limit**0.5\n    primes = []\n    nums = [x for x in range(2, limit+1)]\n    while nums[0]<=x:\n        primes.append(nums[0])\n        current_prime = nums[0]\n        nums = [x for x in nums if x%current_prime != 0]\n    primes.extend(nums)\n    return primes\n\n\ndef main(args):\n    # ??????????´???°?????????\n    primes = create_prime_list(10000)\n    twin_primes = []\n    prev = primes[0]\n    for p in primes[1:]:\n        if p == prev + 2:\n            twin_primes.append([prev, p])\n        prev = p\n\n    keys = [x[1] for x in twin_primes]\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        r = bisect_left(keys, n)\n        print(*twin_primes[r-1])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ",
    "fixed": "# -*- coding: utf-8 -*-\n\"\"\"\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom bisect import bisect_right\ninput = stdin.readline\n\n\ndef create_prime_list(limit):\n    \"\"\" ??¨??????????????????????????§limit?????§????´???°?????????????±???????\n    https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9\n    \"\"\"\n    x = limit**0.5\n    primes = []\n    nums = [x for x in range(2, limit+1)]\n    while nums[0]<=x:\n        primes.append(nums[0])\n        current_prime = nums[0]\n        nums = [x for x in nums if x%current_prime != 0]\n    primes.extend(nums)\n    return primes\n\n\ndef main(args):\n    # ??????????´???°?????????\n    primes = create_prime_list(10000)\n    twin_primes = []\n    prev = primes[0]\n    for p in primes[1:]:\n        if p == prev + 2:\n            twin_primes.append([prev, p])\n        prev = p\n\n    keys = [x[1] for x in twin_primes]\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        r = bisect_right(keys, n)\n        print(*twin_primes[r-1])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "problem_id": "p00151",
    "problem_statement": "\nGrid\n\nThere is a n × n grid D where each cell contains either 1 or 0.\n\n\nYour task is to create a program that takes the gird data as input and computes the greatest number of consecutive 1s in either vertical, horizontal, or diagonal direction.\n\n\nFor example, the consecutive 1s with greatest number in the figure below is circled by the dashed-line.\n\n\n\n\n\nThe size of the grid n is an integer where 2 ≤ n ≤ 255.\n\nInput\n\nThe input is a sequence of datasets. The end of the input is indicated by a line containing one zero. Each dataset is formatted as follows:\n\n\nn\nD11 D12 ... D1n\nD21 D22 ... D2n\n  .\n  .\nDn1 Dn2 ... Dnn\n\nOutput\n\nFor each dataset, print the greatest number of consecutive 1s.\n\nSample Input\n\n5\n00011\n00101\n01000\n10101\n00010\n8\n11000001\n10110111\n01100111\n01111010\n11111111\n01011010\n10100010\n10000001\n2\n01\n00\n3\n000\n000\n000\n0\n\nOutput for the Sample Input\n\n4\n8\n1\n0\n\n",
    "buggy": "def f():\n    max_c = 0\n    c = 0\n    for h in range(n):\n        for w in range(n):\n            if grid[h][w] == 1:\n                    c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n    \n    for w in range(n):\n        for h in range(n):\n            if grid[h][w] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n    \n    for p in range(n):\n        for a in range(n-p):\n            if grid[p+a][0+a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n        \n    for p in range(1,n):\n        for a in range(n-p):\n            if grid[0+a][p+a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n                \n    for p in range(n):\n        for a in range(n-p):\n            if grid[p+a][n-1-a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n            \n    for p in range(n, -1, -1):\n        for a in range(p):\n            if grid[0+a][p-1-a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n                \n    print(max_c)\n        \nwhile True:\n    n = eval(input())\n    if n == 0: break\n    grid = [list(map(int, input())) for i in range(n)]\n    f()",
    "fixed": "def f():\n    max_c = 0\n    c = 0\n    for h in range(n):\n        for w in range(n):\n            if grid[h][w] == 1:\n                    c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n    \n    for w in range(n):\n        for h in range(n):\n            if grid[h][w] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n    \n    for p in range(n):\n        for a in range(n-p):\n            if grid[p+a][0+a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n        \n    for p in range(1,n):\n        for a in range(n-p):\n            if grid[0+a][p+a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n                \n    for p in range(n):\n        for a in range(n-p):\n            if grid[p+a][n-1-a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n            \n    for p in range(n, -1, -1):\n        for a in range(p):\n            if grid[0+a][p-1-a] == 1:\n                c += 1\n            else:\n                if  max_c < c:\n                    max_c = c\n                c = 0\n        else:\n            if  max_c < c:\n                max_c = c\n            c = 0\n                \n    print(max_c)\n        \nwhile True:\n    n = eval(input())\n    if n == 0: break\n    grid = [list(map(int, input())) for i in range(n)]\n    f()"
  },
  {
    "problem_id": "p00152",
    "problem_statement": "Bowling\n\nWe have decided to go bowling as a class recreation. Create a program that inputs the throwing information for each participant and outputs the performance information in order of highest score. In the case of a tie, output in order of student ID number. However, the number of participants should be between 3 and 40, and each person is assumed to have thrown one game.\n\n\nBowling is a sport in which a player rolls a ball towards ten pins arranged in an equilateral triangle with the top pointing towards them and tries to knock them all down. If all the pins are knocked down on the first throw, it is called a strike, and the player advances to the next frame with only that throw. If it is not a strike, the player leaves the remaining pins and throws a second time. If all the pins are knocked down on the second throw, it is called a spare, and the player advances to the next frame after the second throw.\n\n\nOne game consists of 10 frames. For the first through ninth frames, two throws are allowed per frame. At the beginning of each frame, all 10 pins are standing. In the tenth frame, if a strike or a spare is made, three throws are allowed. Otherwise, two throws are allowed, and the game ends.\n\n\nExample scores 1\n\n\nExample scores 2 (with a perfect score of 300)\n\n\n\nScoring Method\n\n In frames where there is no spare or strike, the score for that frame is the number of pins knocked down in two throws. (e.g., the fourth and eighth frames in Example 1)\n If you get a spare, you add ten points to the number of pins knocked down, and then add the number of pins knocked down on the next throw to the score for that frame. (e.g., the relationship between the first and second frames in Example 1) In the first frame of Example 1, 20 points are scored by adding the 10 pins (points) knocked down in the second frame's first throw to the 10 points for the first throw. The same calculation method applies to the third frame.\n If you get a strike, you add ten points to the number of pins knocked down, and then add the number of pins knocked down in the next two throws to the score for that frame. (e.g., the relationship between the second and third frames in Example 1) Of course, there may be a strike in the two subsequent throws. (e.g., the relationship between the fifth, sixth, and seventh frames in Example 1)\n In the tenth frame only, if you get a spare or strike, the total number of pins knocked down in three throws is added to the score for the tenth frame.\n The total score for each frame is the sum of the scores for each frame, and the highest score is 300 points.\n\nInput\n\nThe input consists of multiple datasets. The end of the input is indicated by a line containing a single zero.\nEach dataset is given in the following format.\n\nm\nscore1\nscore2\n:\nscorem\n\n\nThe first line contains the number of participants m (3 ≤ m ≤ 40), followed by m lines containing the participant information for person i. Each participant information is given in the following format, one line at a time.\n\n\nid s1 s2 ... sn\n\n\nThe student ID number id (0 ≤ id ≤ 9999) is first, followed by the number of pins knocked down in the jth throw, sj (0 ≤ sj ≤ 10). The total number of throws, n, is between 12 and 21, and the number of pins required for scoring is given exactly.\n\nOutput\n\nFor each input dataset, output the student ID number and score in order of highest score. If there is a tie, output in order of student ID number. Output the student ID number and score on one line, separated by a single space.\n\nSample Input\n\n3\n1010 6 3 10 7 1 0 7 9 1 10 6 2 4 3 9 1 9 0\n1200 5 3 9 1 7 1 0 0 8 1 10 10 4 3 9 1 8 2 9\n1101 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n4\n3321 8 2 10 9 1 7 0 10 10 10 0 8 10 10 10 10\n3332 5 0 10 9 1 4 1 9 0 10 10 7 1 5 2 8 1\n3335 10 10 10 10 10 10 10 10 10 10 10 10\n3340 8 2 7 3 6 4 8 2 8 2 9 1 7 3 6 4 8 2 9 1 7\n0\n\nOutput for the Sample Input\n\n1200 127\n1010 123\n1101 60\n3335 300\n3321 200\n3340 175\n3332 122\n",
    "buggy": "def get_point(info):\n  info.reverse()\n  acc = 0\n  NORMAL, SPARE, STRIKE, DOUBLE = 0, 1, 2, 3\n  flag = NORMAL\n  game_num = 0\n  while info:\n    if game_num != 9:\n      down_num1 = info.pop()\n      if down_num1 != 10:\n        down_num2 = info.pop()\n        if flag == SPARE:\n          acc += down_num1 * 2 + down_num2\n        elif flag == STRIKE:\n          acc += down_num1 * 2 + down_num2 * 2\n        elif flag == DOUBLE:\n          acc += down_num1 * 3 + down_num2 * 2\n        else:\n          acc += down_num1 + down_num2\n        \n        if down_num1 + down_num2 == 10:\n          flag = SPARE\n        else:\n          flag = NORMAL\n      \n      else:\n        if flag in (SPARE, STRIKE):\n          acc += down_num1 * 2\n        elif flag == DOUBLE:\n          acc += down_num1 * 3\n        else:\n          acc += down_num1\n        if flag in (STRIKE, DOUBLE):\n          flag = DOUBLE\n        else:\n          flag = STRIKE\n      game_num += 1\n\n    else:\n      down_num1, down_num2 = info.pop(), info.pop()\n      if flag == SPARE:\n        acc += down_num1 * 2 + down_num2\n      elif flag == STRIKE:\n        acc += down_num1 * 2 + down_num2 * 2\n      elif flag == DOUBLE:\n        acc += down_num1 * 3 + down_num2 * 2\n      else:\n        acc += down_num1 + down_num2\n      if info:\n        acc += info.pop()\n  \n  return acc\n\nwhile True:\n  m = int(input())\n  if m == 0:\n    break\n  score = [list(map(int, input().split())) for _ in range(m)]\n  score_mp = [(info[0], get_point(info[1:])) for info in score]\n  score.mpsort()\n  score_mp.sort(key=lambda x:-x[1])\n  for pair in score_mp:\n    print(*pair)\n",
    "fixed": "def get_point(info):\n  info.reverse()\n  acc = 0\n  NORMAL, SPARE, STRIKE, DOUBLE = 0, 1, 2, 3\n  flag = NORMAL\n  game_num = 0\n  while info:\n    if game_num != 9:\n      down_num1 = info.pop()\n      if down_num1 != 10:\n        down_num2 = info.pop()\n        if flag == SPARE:\n          acc += down_num1 * 2 + down_num2\n        elif flag == STRIKE:\n          acc += down_num1 * 2 + down_num2 * 2\n        elif flag == DOUBLE:\n          acc += down_num1 * 3 + down_num2 * 2\n        else:\n          acc += down_num1 + down_num2\n        \n        if down_num1 + down_num2 == 10:\n          flag = SPARE\n        else:\n          flag = NORMAL\n      \n      else:\n        if flag in (SPARE, STRIKE):\n          acc += down_num1 * 2\n        elif flag == DOUBLE:\n          acc += down_num1 * 3\n        else:\n          acc += down_num1\n        if flag in (STRIKE, DOUBLE):\n          flag = DOUBLE\n        else:\n          flag = STRIKE\n      game_num += 1\n\n    else:\n      down_num1, down_num2 = info.pop(), info.pop()\n      if flag == SPARE:\n        acc += down_num1 * 2 + down_num2\n      elif flag == STRIKE:\n        acc += down_num1 * 2 + down_num2 * 2\n      elif flag == DOUBLE:\n        acc += down_num1 * 3 + down_num2 * 2\n      else:\n        acc += down_num1 + down_num2\n      if info:\n        acc += info.pop()\n  \n  return acc\n\nwhile True:\n  m = int(input())\n  if m == 0:\n    break\n  score = [list(map(int, input().split())) for _ in range(m)]\n  score_mp = [(info[0], get_point(info[1:])) for info in score]\n  score_mp.sort()\n  score_mp.sort(key=lambda x:-x[1])\n  for pair in score_mp:\n    print(*pair)\n"
  },
  {
    "problem_id": "p00155",
    "problem_statement": "Spider-Man\n\nThe hero of justice \"Spider-Man\" can jump from building to building by shooting ropes from his arms. However, he can only move to buildings that are 50 or less units away from him because the ropes are short. To move to buildings further away, he must first jump to another building.\n\n\n\n\n\n\n\nCreate a program that takes as input the number of buildings n, information about n buildings, Spider-Man's starting position and destination, and outputs the shortest route for the movement. If it is impossible to move to the target building in any way, output NA. Each building is treated as a point, and there is no way for there to be more than two ways to move through the buildings in the shortest distance.\n\nInput\n\nThe input consists of a sequence of multiple data sets. The end of the input is indicated by a single line containing a zero.\nFor each data set, the input is given in the following format.\n\n\nn\nb1 x1 y1\nb2 x2 y2\n:\nbn xn yn\nm\ns1 g1\ns2 g2\n:\nsm gm\n\n\nThe first line contains the number of buildings n (1 ≤ n ≤ 100), followed by n lines giving the building number bi (1 ≤ bi ≤ n), and its x and y coordinates, xi and yi, as integers (-1000 ≤ xi, yi ≤ 1000), separated by spaces.\n\n\nThe next line contains the number of movements m (1 ≤ m ≤ 100), followed by m lines giving the starting building number si and the destination building number gi, separated by a space.\n\n\nThere are no more than 10 data sets.\n\nOutput\n\nFor each input data set, output the following format.\n\n\nOn the i-th line, output the route for the i-th movement or NA in a single line. Each route is output in the following format.\n\n\nsi bri1 bri2 ... gi\n\n\nbrij represents the number of the building to be passed through in the j-th order in the i-th movement.\n\nSample Input\n\n4\n1 0 0\n2 30 0\n3 60 40\n4 0 60\n2\n1 3\n1 4\n22\n1 0 0\n2 150 40\n3 30 20\n4 180 150\n5 40 80\n6 130 130\n7 72 28\n8 172 118\n9 50 50\n10 160 82\n11 90 105\n12 144 131\n13 130 64\n14 80 140\n15 38 117\n16 190 90\n17 60 100\n18 100 70\n19 130 100\n20 71 69\n21 200 110\n22 120 150\n1\n1 22\n0\n\nOutput for the Sample Input\n\n1 2 3\nNA\n1 3 9 20 11 6 22\n",
    "buggy": "from collections import namedtuple, defaultdict\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\ndef main():\n    while True:\n        n = eval(input())\n        if n == 0:\n            break\n        bldgs = {}\n        for _ in range(n):\n            b, x, y = list(map(int, input().split()))\n            bldgs[b] = Point(x, y)\n        graph = make_graph(bldgs)\n        for _ in range(eval(input())):\n            sb, gb = list(map(int, input().split()))\n            res = dijkstra(graph, sb, gb)\n            if res is None:\n                print(\"NA\")\n            else:\n                print(\" \".join(map(str, reversed(res))))\n        \ndef make_graph(bldgs):\n    graph = defaultdict(list)\n    for b1, p1 in list(bldgs.items()):\n        for b2, p2 in list(bldgs.items()):\n            if b1 == b2:\n                continue\n            weight = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2\n            if weight > 2500:\n                continue\n            graph[b1].append((weight**0.5, b2,))\n    return graph\n\ndef dijkstra(graph, start, goal):\n    import heapq\n    hq = [(w, b, start) for w, b in graph[start]]\n    heapq.heapify(hq)\n    pre = dict((k, None) for k in list(graph.keys()))\n    while len(hq) > 0:\n        w, cb, pb = heapq.heappop(hq)\n        if pre[cb] is not None:\n            continue\n        pre[cb] = pb\n        if cb == goal:\n            break\n        for nw, nb in graph[cb]:\n            heapq.heappush(hq, (nw+w, nb, cb))\n    else:\n        return None\n    ret = [goal]\n    while ret[-1] != start:\n        ret.append(pre[ret[-1]])\n    return list(reversed(ret))\n\nif __name__ == \"__main__\":\n    main()",
    "fixed": "from collections import namedtuple, defaultdict\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\ndef main():\n    while True:\n        n = eval(input())\n        if n == 0:\n            break\n        bldgs = {}\n        for _ in range(n):\n            b, x, y = list(map(int, input().split()))\n            bldgs[b] = Point(x, y)\n        graph = make_graph(bldgs)\n        for _ in range(eval(input())):\n            sb, gb = list(map(int, input().split()))\n            res = dijkstra(graph, sb, gb)\n            if res is None:\n                print(\"NA\")\n            else:\n                print(\" \".join(map(str, res)))\n        \ndef make_graph(bldgs):\n    graph = defaultdict(list)\n    for b1, p1 in list(bldgs.items()):\n        for b2, p2 in list(bldgs.items()):\n            if b1 == b2:\n                continue\n            weight = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2\n            if weight > 2500:\n                continue\n            graph[b1].append((weight**0.5, b2,))\n    return graph\n\ndef dijkstra(graph, start, goal):\n    import heapq\n    hq = [(w, b, start) for w, b in graph[start]]\n    heapq.heapify(hq)\n    pre = dict((k, None) for k in list(graph.keys()))\n    while len(hq) > 0:\n        w, cb, pb = heapq.heappop(hq)\n        if pre[cb] is not None:\n            continue\n        pre[cb] = pb\n        if cb == goal:\n            break\n        for nw, nb in graph[cb]:\n            heapq.heappush(hq, (nw+w, nb, cb))\n    else:\n        return None\n    ret = [goal]\n    while ret[-1] != start:\n        ret.append(pre[ret[-1]])    \n    return list(reversed(ret))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "problem_id": "p00163",
    "problem_statement": "Toll Road Fees\n\nThe Aizu Chuo Road, which consists of 6 sections from Nekoyama-cho, Kitakata City to Minamiaizu-machi with a total distance of 58 km, is scheduled to be completed and opened in 20XX.\n\n\nAfter the opening, for a period of six months, tolls for cars that pass through the departure or arrival IC between 17:30 and 19:30 and travel less than 40 km will be half price. However, the tolls are rounded up to the nearest 50 yen. The following table provides a list of tolls and distances.\n\n\n\n\n\n\nFor example, the toll from Kitakata (2) to Aizuwakamatsu (4) is 450 yen for a distance of 12 km. During the half-price period, it will be 250 yen.\n\n\nCreate a program that inputs the departure IC, departure IC passage time, arrival IC, and arrival IC passage time and calculates the toll. The input time is in 24-hour format. Note that even if the passage time is exactly 17:30 or 19:30, it is included in the half-price period.\n\nInput\n\nThe input consists of multiple datasets. The end of input is indicated by a single zero.\nEach dataset is in the following format.\n\n\nd\nhd md\na\nha ma\n\n\nThe first line contains the number d (1 ≤ d ≤ 7) of the departure IC, and the second line contains the departure IC passage time in hours hd (0 ≤ hd ≤ 23) and minutes md (0 ≤ md ≤ 59).\n\n\nThe third line contains the number a (1 ≤ a ≤ 7) of the arrival IC, and the fourth line contains the arrival IC passage time in hours ha (0 ≤ ha ≤ 23) and minutes ma (0 ≤ ma ≤ 59).\n\nOutput\n\nFor each dataset, output the toll (an integer) on a single line.\n\nSample Input\n\n2\n17 25\n4\n17 45\n4\n17 25\n7\n19 35\n0\n\nOutput for the Sample Input\n\n250\n1300\n",
    "buggy": "# Highway Toll\n\nPRICE_LIST = (\n    (0, 0, 0, 0, 0, 0, 0, 0),\n    (0, 0, 300, 500, 600, 700, 1350, 1650),\n    (0, 6, 0, 350, 450, 600, 1150, 1500),\n    (0, 13, 7, 0, 250, 400, 1000, 1350),\n    (0, 18, 12, 5, 0, 250, 850, 1300),\n    (0, 23, 17, 10, 5, 0, 600, 1150),\n    (0, 43, 37, 30, 25, 20, 0, 500),\n    (0, 58, 52, 45, 40, 35, 15, 0),\n)\n\nwhile True:\n    i = int(input())\n    if i == 0:\n        break\n\n    it = int(input().strip().replace(' ', ''))\n    o = int(input())\n    ot = int(input().strip().replace(' ', ''))\n\n    half = False\n    if 1730 <= it <= 1930 or 1730 <= ot <= 1930:\n        half = True\n\n    if PRICE_LIST[o][i] <= 40:\n        half &= True\n\n    p = PRICE_LIST[i][o]\n    if half:\n        p /= 2\n        if p % 50:\n            p = p - (p % 50) + 50\n\n    print(p)",
    "fixed": "# Highway Toll\n\nPRICE_LIST = (\n    (0, 0, 0, 0, 0, 0, 0, 0),\n    (0, 0, 300, 500, 600, 700, 1350, 1650),\n    (0, 6, 0, 350, 450, 600, 1150, 1500),\n    (0, 13, 7, 0, 250, 400, 1000, 1350),\n    (0, 18, 12, 5, 0, 250, 850, 1300),\n    (0, 23, 17, 10, 5, 0, 600, 1150),\n    (0, 43, 37, 30, 25, 20, 0, 500),\n    (0, 58, 52, 45, 40, 35, 15, 0),\n)\n\nwhile True:\n    i = int(input())\n    if i == 0:\n        break\n\n    it = int(input().strip().replace(' ', ''))\n    o = int(input())\n    ot = int(input().strip().replace(' ', ''))\n\n    half = False\n    if (1730 <= it <= 1930 or 1730 <= ot <= 1930) and PRICE_LIST[o][i] <= 40:\n        half = True\n\n    p = PRICE_LIST[i][o]\n    if half:\n        p /= 2\n        if p % 50:\n            p = p - (p % 50) + 50\n\n    print(p)"
  },
  {
    "problem_id": "p00166",
    "problem_statement": "Area of a Polygon\nWrite a program that receives input on the vertices of two polygons inscribed in a single circle, and outputs the relationship between their respective areas.\nEach vertex of an X-sided polygon is numbered in counterclockwise order from 1 to X (the diagram shows the case where X = 4). The polygons given as input are assumed to contain the center of the circle in their interiors, and the data about the position of vertex i is given as the angle v (an integer between 1 and 180, exclusive) measured counterclockwise from vertex i to vertex i+1. If the area of the first polygon is greater than that of the second, output 1 (a half-width digit). If the area of the second polygon is greater than the first, output 2 (a half-width digit). If the areas are equal, output 0 (a half-width digit).\n\n\n\n\nInput\nThe input consists of a sequence of multiple datasets. The end of the input is indicated by a single line containing a zero.\nEach dataset is formatted as follows:\n\nm\nv1\nv2\n:\nvm −1\nn\nv1\nv2\n:\nvn − 1\n\nThe first line contains the number of vertices m (3 ≤ m ≤ 50) of the first polygon, followed by m − 1 lines containing information about each vertex i of the first polygon, vi (1 ≤ vi < 180).\nThe following line contains the number of vertices n (3 ≤ n ≤ 50) of the second polygon, followed by n − 1 lines containing information about each vertex i of the second polygon, vi (1 ≤ vi < 180).\nThere are no more than 200 datasets.\nOutput\nFor each dataset, output the relationship between the two polygon areas (a half-width digit) on a single line.\nSample Input\n\n4\n30\n125\n75\n4\n30\n125\n75\n5\n30\n125\n75\n65\n4\n30\n125\n75\n4\n30\n125\n75\n6\n30\n50\n50\n25\n75\n0\n\nOutput for the Sample Input\n\n0\n1\n2\n",
    "buggy": "from math import *\n\ndef S(p):\n\treturn sum([sin(a*pi/180)/2 for a in p])+sin((360-sum(p))*pi/180)\n\nwhile True:\n\ttry:\n\t\tp1=[int(input()) for i in range(eval(input())-1)]\n\t\tp2=[int(input()) for i in range(eval(input())-1)]\n\t\ts1,s2=S(p1),S(p2)\n\t\tif    s1-s2>1e-10: print(1)\n\t\telif  s2-s1>1e-10: print(2)\n\t\telse:print(0)\n\texcept:break",
    "fixed": "from math import *\n\ndef S(p):\n\treturn sum([sin(a*pi/180) for a in p])+sin((360-sum(p))*pi/180)\n\nwhile True:\n\ttry:\n\t\tp1=[int(input()) for i in range(eval(input())-1)]\n\t\tp2=[int(input()) for i in range(eval(input())-1)]\n\t\ts1,s2=S(p1),S(p2)\n\t\tif    s1-s2>1e-10: print(1)\n\t\telif  s2-s1>1e-10: print(2)\n\t\telse:print(0)\n\texcept:break"
  },
  {
    "problem_id": "p00167",
    "problem_statement": "Bubble Sort\n\nSorting algorithms are essential basic algorithms in computer science for arranging data. For example, sorting an array of integer values in ascending order is a sorting operation, as shown in the figure below.\n\n\n\n\n\nMany sorting algorithms have been developed, but one of the basic algorithms is bubble sort. For example, let's try to arrange an given array of integers in ascending order using bubble sort.\n\n\n\n\n\n\nIn bubble sort, at each calculation step, the array is divided into a \"sorted part\" and an \"unsorted part\". At the beginning, the entire array becomes the unsorted part.\n\n\nStarting from the beginning of the unsorted part, adjacent elements are compared (green elements in the figure), and they are swapped so that the larger value comes to the right. If the two values are equal, they are not swapped.\n\n\n\n\n\n\nRepeat this process until the end of the unsorted part (white elements in the figure). Finally, add the end to the sorted part (blue elements), and one step is completed.\n\n\nRepeat this step until the length of the unsorted part becomes 1.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen the length of the unsorted part becomes 1, the sorting process is finished.\n\n\nNow, create a program that takes an array of n numbers as input and sorts them in ascending order from the beginning of the array using the above bubble sort procedure, and outputs the number of array element swaps required.\n\nInput\n\nThe input consists of multiple datasets. The end of the input is indicated by a single zero.\nEach dataset is given in the following format.\n\n\nn\na1\na2\n:\nan\n\n\nThe first line contains the number of numbers n (1 ≤ n ≤ 100), and the following n lines contain the i-th number ai (1 ≤ ai ≤ 1000000).\n\n\nThe number of datasets does not exceed 20.\n\nOutput\n\nFor each dataset, output the number of swaps required to sort the data elements in one line.\n\nSample Input\n\n5\n5\n3\n2\n1\n4\n6\n1\n2\n3\n4\n5\n6\n3\n3\n2\n1\n0\n\nOutput for the Sample Input\n\n7\n0\n3\n",
    "buggy": "while True:\n    n = int(input())\n    if n==0: break\n    a = [input() for _ in range(n)]\n    count = 0\n    for i in range(n):\n        for j in range(n)[:0:-1]:\n            if a[j] < a[j-1]:\n                a[j], a[j-1] = a[j-1], a[j]\n                count+=1\n    print(count)",
    "fixed": "while True:\n    n = int(input())\n    if n==0: break\n    a = [int(input()) for _ in range(n)]\n    count = 0\n    for i in range(n):\n        for j in range(n)[:0:-1]:\n            if a[j] < a[j-1]:\n                a[j], a[j-1] = a[j-1], a[j]\n                count+=1\n    print(count)"
  },
  {
    "problem_id": "p00168",
    "problem_statement": "Kannon-Do\n\nThere is a Kannon-Do (a temple dedicated to the goddess of mercy, Kannon) on the mountain behind Ichiro's house. There are 30 steps from the base to the Kannon-Do, and Ichiro goes to the Kannon-Do to play almost every day. Ichiro can climb up to three steps with one step. While playing, Ichiro noticed that there are many ways to climb the steps (various numbers of steps to skip).\n\n\nTherefore, he decided to climb up the steps in 10 different ways every day and try all the ways. However, as a mathematician, you should know that this will take Ichiro's entire life.\n\n\nTo convince Ichiro that his plan is impossible, write a program that takes the number of steps n as input and outputs the number of years it would take for Ichiro to climb all the steps in 10 different ways per day. Assume that a year has 365 days. If at least one day is necessary, it is counted as one year. If there are 365 days, it is one year, and if there are 366 days, it is two years.\n\nInput\n\nThe input is a sequence of multiple datasets. The end of the input is indicated by a single zero line.\nFor each dataset, a single integer n (1 ≤ n ≤ 30) representing the number of steps is given on a line.\n\n\nThere are no more than 30 datasets.\n\nOutput\n\nFor each dataset, output the number of years (an integer) required for Ichiro to climb all the steps in all 10 ways on a single line.\n\nSample Input\n\n1\n10\n20\n25\n0\n\nOutput for the Sample Input\n\n1\n1\n34\n701\n",
    "buggy": "a = [1, 1, 2]\nfor i in range(3, 31):\n    a.append(sum(a[-3:]))\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    print(((a[n] + 9) / 10 + 364) / 365)",
    "fixed": "a = [1]\nfor i in range(1, 31):\n    a.append(sum(a[-3:]))\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    print(((a[n] + 9) // 10 + 364) // 365)"
  },
  {
    "problem_id": "p00170",
    "problem_statement": "Lunch\n\nTo make a bento box for lunch, I bought some food at the store. At the store, I could only get a long, narrow bag to put the food in, so I need to stack all the food vertically and put it in the bag. I want to pack as much weight as possible at the bottom so that the bag does not tip over, but some of the food is soft and will be crushed if I put heavy things on top.\n\n\n\nTherefore, given the information about the food as input, please create a program that outputs a stacking method that prevents all the food from being crushed and has the lowest possible center of gravity. For each piece of food, the name f, weight w, and the weight it can withstand on top, s, are specified. \"All of the food does not collapse\" means that when n pieces of food (f1, f2, ..., fn) are stacked from the bottom, for all f,\n\nsfi ≥ wfi+1 + wfi+2 +  ...  + wfn\n\n\n\nmust hold. In addition, the center of gravity of the entire stack is defined as\n\nG = (1 × wf1 + 2 × wf2 +  ...  + n × wfn) / (wf1 + wf2+ ... +wfn)\n\n\nHowever, assume that there is exactly one solution.\n\nInput\n\nThe input consists of a sequence of multiple data sets. The end of the input is indicated by a single zero on a line. Each data set is given in the following format:\n\n\nn\nf1 w1 s1\nf2 w2 s2\n:\nfn wn sn\n\n\nThe first line contains the number of food items, n (1 ≤ n ≤ 10), and the following n lines contain the name fi (a half-width English string of up to 20 characters), the weight wi (1 ≤ wi ≤ 1000) and the weight it can withstand si (1 ≤ si ≤ 1000), separated by a space.\n\n\nThere are no more than 20 data sets.\n\nOutput\n\nFor each data set, output the names of the food items in the order they are stacked from the bottom in the following format:\n\n\n1st line: Name of the food at the bottom (a half-width English string) \n2nd line: Name of the food second from the bottom\n: \nn-th line: Name of the topmost food\n\nSample Input\n\n4\nsandwich 80 120\napple 50 200\ncheese 20 40\ncake 100 100\n9\nonigiri 80 300\nonigiri 80 300\nanpan 70 280\nmikan 50 80\nkanzume 100 500\nchocolate 50 350\ncookie 30 80\npurin 40 400\ncracker 40 160\n0\n\nOutput for the Sample Input\n\napple\ncake\nsandwich\ncheese\nkanzume\npurin\nchocolate\nonigiri\nonigiri\nanpan\nmikan\ncracker\ncookie\n",
    "buggy": "def solve(G1, G2, w1, w2):\n  global ans\n  n = len(G2)\n  for e in G2:\n    w, lim, s = Food[e]\n    if w2 > lim:\n      return\n    a = w1 + w * n\n    if a > ans[0]:\n      return\n    if n==1:\n      ans = min(ans, [w1, G1+[e]])\n    else:\n      x = G2[:]\n      x.remove(e)\n      solve(G1+[e], x, a, w2 + w)\n  return\n \nwhile True:\n  n = eval(input())\n  if n == 0: break\n  ans = [1e9, []]\n  N = list(range(n))\n  f = lambda x: list(map(int, x[1:3])) + [x[0]]\n  Food = [f(input().split()) for _ in [0] * n]\n  solve([], N, 0, 0)\n  for e in ans[1][::-1]:\n    print(Food[e][2])",
    "fixed": "def solve(G1, G2, w1, w2):\n  global ans\n  n = len(G2)\n  for e in G2:\n    w, lim, s = Food[e]\n    a = w1 + w * n\n    if w2 > lim or a > ans[0]: return\n    b = G1 + [e]\n    if n == 1:\n      ans = min(ans, [a, b])\n    else:\n      x = G2[:]\n      x.remove(e)\n      solve(b, x, a, w2 + w)\n  return\n \nwhile True:\n  n = eval(input())\n  if n==0: break\n  ans = [1e9, []]\n  N = list(range(n))\n  f = lambda x: list(map(int, x[1:3])) + [x[0]]\n  Food = [f(input().split()) for _ in [0]*n]\n  solve([], N, 0, 0)\n  for e in ans[1][::-1]:\n    print(Food[e][2])"
  },
  {
    "problem_id": "p00178",
    "problem_statement": "Tetris\n\nTetris is a game where you arrange falling blocks on a board and clear them. Let's consider a slightly modified version of that game here.\n\n\nThe size of the board in this game is just enough to accommodate the appearing blocks, with 5 squares arranged side by side and sufficient height. The falling blocks are linear, with two types: horizontal and vertical, and there are five types of length ranging from 1 to 5.\n\n\nThe figures from steps (i) to (ho) below represent the process of blocks falling and disappearing. The game progresses from step (i) to step (ha).\n\n\nWhen the block is dropped and collides with the blocks stacked below, as in step (i), it stops at that position. Also, if a horizontal square on the board is completely filled with blocks after the block falls, the row of blocks is erased (see step (ni)). Then, the blocks above the erased row sink down one position to their original shape (step (ho)).\n\n\n\n\n\n\nAssuming that up to 1000 blocks fall in a single game, if the lengths of the falling blocks are 4 squares horizontally, 3 squares horizontally, 2 squares vertically, and 3 squares vertically, and they fall in the first, first, fourth, and fifth positions from the left, respectively, they fall as shown in steps (i) to (to) below. The remaining blocks become 2 squares.\n\n\n\n\n\n\nCreate a program that accepts the order in which the blocks fall as input and outputs the number of squares occupied when all the blocks have fallen.\n\nInput\n\nThe input is a sequence of multiple datasets. The end of the input is indicated by a line containing 0. Each dataset is provided in the following format.\n\n\nn\nd1 p1 q1\nd2 p2 q2\n:\ndn pn qn\n\n\nThe first line gives the number of blocks n (1 ≤ n ≤ 1000). The i-th line that follows gives the direction di (1 or 2) of the i-th block, the length pi of the block (1 ≤ pi ≤ 5), and the position qi of the block. The direction of the block di can be 1 or 2.",
    "buggy": "while True:\n\tn=eval(input())\n\tif n==0:break\n\thmax=10000\n\tblock=[list(map(int,input().split())) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+q)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile True:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint(sum([sum(field[li]) for li in range(len(field))]))",
    "fixed": "while True:\n\tn=eval(input())\n\tif n==0:break\n\thmax=10000\n\tblock=[list(map(int,input().split())) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+p)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile True:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint(sum([sum(field[li]) for li in range(len(field))]))"
  },
  {
    "problem_id": "p00179",
    "problem_statement": "Mysterious Insect\n\nDr. A of Aizu Laboratory of Biological Science discovered a mysterious insect on a certain southern island. The shape is slender like a caterpillar, but because one body segment is shaped like a ball, it looks like a beaded ball connected by a thread. The strange thing was that there were various variations in the color of the body, and there were insects whose body color changed as time passed. Although the color of any insect body segment seems to be limited to either red, green or blue, the color of the body segment changes every second, and sometimes all body segments become the same color and settle down, while other times the color continues to change forever, no matter how long you wait.\n\n\n\n\n\n\nAs we investigated, we found that normally all body segments have the same color, but after being excited by something, we found that the color of the body segments changes on its own. Once the color of the body segment changes, it was found that the color will continue to change until all body segments become the same color again.\n\n\nDr. A caught many of these insects and excited them to observe the changing colors with interest, but eventually he noticed a rule in the way the color changes during the color change. The following is the rule he noticed:\n\n\nThe color changes only one pair of adjacent differently colored body segments, and the colors of other body segments do not change. However, if there are multiple such pairs, it is impossible to predict which pair will change color.\nSuch a pair changes color to a color that is not either of the two colors of the two body segments (for example, when a green and red body segment are adjacent, they change to blue at the same time).\n\n\n\n\n\n\nThe above figure shows the changes in the color of the insect up to 2 seconds. Let's assume that there is an insect with the color shown in the upper row of the figure. At this time, there are three pairs of adjacent differently colored body segments, so after 1 second, it will change to one of the three colors arranged in the middle row. When it changes like the left two in the middle row after 1 second, it can be changed to all the body segments being green after 2 seconds (the second from the left in the bottom row of the figure). On the other hand, when it changes like the rightmost one in the middle row after 1 second, all body segments will not change to the same color after 2 seconds.\n\n\nDr. A decided to predict whether it is possible for all body segments of the insect in front of him to become the same color, and if so, to create a program that outputs the shortest time it will take to do so in seconds. However, if it is impossible to become the same color, please output \"NA\" (capital letters only). The arrangement of the colors of the body segments of the insect is represented by a string consisting of 2 to 10 characters of r (red), g (green), and b (blue).\n\nInput\n\nThe input is a sequence of multiple data sets. The end of the input is indicated by a single zero line. For each dataset, one string representing the body segments of the insect is given on one line.\n\n\nThe number of data sets does not exceed 100.\n\nOutput\n\nFor each dataset, output the minimum time (in seconds) required for all body segments to become the same color or \"NA\" on one line.\n\nSample Input\n\nrbgrg\nrbbgbbr\nbgr\nbgrbrgbr\nbggrgbgrr\ngbrggrbggr\nrrrrr\nbgbr\n0\n\nOutput for the Sample Input\n\n5\n7\n1\n6\nNA\n8\n0\n4\n",
    "buggy": "rgb = set([\"r\",\"g\",\"b\"])\nwhile True:\n\tworm = input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\twhile True:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 10: break\n\tprint(cnt if flag else \"NA\")",
    "fixed": "rgb = set([\"r\",\"g\",\"b\"])\nwhile True:\n\tworm = input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\twhile True:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = list(rgb-set(Worm[i:i+2]))[0]\n\t\t\t\t\tworm = Worm[:i] + 2*nextclr + Worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 15: break\n\tprint(cnt if flag else \"NA\")"
  },
  {
    "problem_id": "p00180",
    "problem_statement": "Demolition of Bridges\n\nThere are n cities in the Waterdebun country. Each city is surrounded by water and is like an island. There are m bridges in Waterdebun, and all cities can be visited by using these bridges for transportation between the cities.\n\n\nRecently, due to a review of road-specific financial resources, a reduction in the maintenance costs of bridges was decided. It became impossible to maintain all bridges, and some of them were demolished. Therefore, the task of Waterdebun is to minimize the maintenance cost of the bridges while ensuring that all cities can be visited using the bridges that remain.\n\n\nCreate a program that takes as input the number of cities, the number of bridges, and the maintenance cost of each bridge, and outputs the minimum maintenance cost when some bridges are demolished while ensuring that all cities can be visited using the bridges. It is assumed that there is no cost to demolish the bridges. However, each city is numbered from 0 to n - 1 in order.\n\nInput\n\nA sequence of multiple data sets is given as input. The end of the input is indicated by two lines of zero. Each dataset is given in the following format.\n\n\nn m\na1 b1 cost1\na2 b2 cost2\n:\nam bm costm\n\n\nThe first line contains the number of cities n (2 ≤ n ≤ 100) and the number of bridges m (1 ≤ m ≤ 500). The following m lines provide information on the i-th bridge. ai, bi are the numbers of the cities connected by the bridge, and costi (1 ≤ costi ≤ 1000) is the maintenance cost of the bridge.\n\nOutput\n\nFor each dataset, output the total maintenance cost of the bridges on a single line.\n\nSample Input\n\n5 6\n0 2 1\n2 1 3\n2 3 8\n1 3 2\n3 4 5\n1 4 4\n3 3\n1 2 3\n2 0 3\n0 1 3\n0 0\n\nOutput for the Sample Input\n\n10\n6\n",
    "buggy": "def f(n, ans):\n    for k, c in list(dic.items()):\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n        elif b == n:\n            if not a in cost or c < cost[a]:\n                cost[a] = c\n    for k, c in sorted(list(cost.items()), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans += c\n            del dic[k]\n            return f(k, ans)\n    return ans\n            \nwhile True:\n    n, m = list(map(int, input().split()))\n    if n == m == 0: break\n    dic = {}\n    s, b, c = list(map(int, input().split()))\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = list(map(int, input().split()))\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    print(f(s, 0))",
    "fixed": "def f(n, ans):\n    for k, c in list(dic.items()):\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n        elif b == n:\n            if not a in cost or c < cost[a]:\n                cost[a] = c\n    for k, c in sorted(list(cost.items()), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans += c\n            del cost[k]\n            return f(k, ans)\n    return ans\n            \nwhile True:\n    n, m = list(map(int, input().split()))\n    if n == m == 0: break\n    dic = {}\n    s, b, c = list(map(int, input().split()))\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = list(map(int, input().split()))\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    print(f(s, 0))"
  },
  {
    "problem_id": "p00181",
    "problem_statement": "Bookshelf\n\nTaro-kun is addicted to a certain novel. The novel has a total of n volumes, and the thickness of each volume is different. Taro-kun likes this novel very much, so he is thinking of buying a bookshelf dedicated to this novel. However, if a large bookshelf is placed in the room, it will become quite narrow, so it is necessary to devise a way to make the width of the bookshelf as small as possible. It was found that a bookshelf of m stages can be placed when measuring the height from the floor to the ceiling. So, how can we divide the n volumes of the novel to make the width of the m stage bookshelf as small as possible?\nTaro-kun has a particular preference, and the novels stored in each stage must be arranged in order of volume number.\n\n\nWrite a program that takes the number of stages of the bookshelf, the number of volumes of the novel, and the thickness of each book as input, and outputs the width of the smallest bookshelf that can hold all volumes from 1 to n. However, the size of the bookshelf frame is not included in the width.\n\n\n\n\n\nInput\n\nThe input consists of a sequence of multiple datasets. The end of the input is indicated by two consecutive zeros. Each dataset is given in the following format.\n\n\nm n\nw1\nw2\n:\nwn\n\n\nThe first line contains the number of stages of the bookshelf that can be placed in the room m (1 ≤ m ≤ 20) and the number of volumes of the novel n (1 ≤ n ≤ 100). The following n lines give the thickness of the i-th volume as an integer wi (1 ≤ wi ≤ 1,000,000).\n\n\nHowever, the width of the bookshelf should not exceed 1,500,000.\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each dataset, output the minimum width of the bookshelf in a single line.\n\nSample Input\n\n3 9\n500\n300\n800\n200\n100\n600\n900\n700\n400\n4 3\n1000\n1000\n1000\n0 0\n\nOutput for the Sample Input\n\n1800\n1000\n",
    "buggy": "\nclass Solve:\n    def __init__(self):\n        self.M, self.N = map(int, input().split())\n        self.bs = [int(input()) for i in range(self.N)]\n\n        self.S = min(sum(self.bs), 1500000)\n        self.l, self.r = 0, self.S\n\n    def check(self, W):\n        w = W\n        i = 1\n        for b in self.bs:\n            if(w >= b):\n                w -= b\n            elif(W >= b):\n                if(i >= self.M):\n                    return False\n                i += 1\n                w = W - b\n            else:\n                return False\n        return True\n\n    def solve(self):\n        while self.r - self.l > 1:\n            m = (self.l + self.r) // 2\n            if self.check(m):\n                self.r = m\n            else:\n                self.l = m\n        return self.r\n\nwhile True:\n    print(Solve().solve())",
    "fixed": "\nclass Solve:\n    def __init__(self):\n        self.M, self.N = map(int, input().split())\n        self.bs = [int(input()) for i in range(self.N)]\n\n        self.S = min(sum(self.bs), 1500000)\n        self.l, self.r = 0, self.S        \n\n    def check(self, W):\n        w = W\n        i = 1\n        for b in self.bs:\n            if(w >= b):\n                w -= b\n            elif(W >= b):\n                if(i >= self.M):\n                    return False\n                i += 1\n                w = W - b\n            else:\n                return False\n        return True\n\n    def solve(self):\n        while self.r - self.l > 1:\n            m = (self.l + self.r) // 2\n            if self.check(m):\n                self.r = m\n            else:\n                self.l = m\n        return self.r\n\nwhile True:\n    s = Solve()\n    if s.M == 0 and s.N == 0:\n        break\n    print(s.solve())"
  },
  {
    "problem_id": "p00183",
    "problem_statement": "Tic Tac Toe\n\nLet's consider Tic Tac Toe on a 3x3 board. Tic Tac Toe is a game played by two people. The players decide who goes first, and one player places black stones while the other places white stones. The players take turns placing one stone at a time on the board, and the first player to line up three of their own stones in a row (horizontally, vertically, or diagonally) wins the game.\n\n\nWrite a program that takes as input the state of the board and determines the winner. If black wins, output \"b\"; if white wins, output \"w\"; if neither player has won, output \"NA\". The state of the board is represented as a 3x3 string. \"b\" represents a black stone, \"w\" represents a white stone, and \"+\" represents an empty space. Note that there will never be a situation where both black and white have three stones in a row.\n\n\nInput\n\nThe input consists of multiple datasets. The input ends with a single line containing a single zero.\nEach dataset is given in the following format.\n\n\nboard1\nboard2\nboard3\n\n\nThe i-th line of the dataset represents the i-th row of the board, and consists of a string boardi.\n\n\nThere will be no more than 50 datasets.\n\nOutput\n\nFor each dataset, output a single line containing \"b\", \"w\", or \"NA\".\n\nSample Input\n\nbbw\nwbw\n+b+\nbwb\nwbw\nwbw\n0\n\nOutput for the Sample Input\n\nb\nNA\n",
    "buggy": "while True:\n    try:\n        f = [list(input()) for _ in range(3)]\n    except EOFError:\n        break\n    g = [\"\".join(x) for x in f+list(zip(*f))+[f[0][0],f[1][1],f[2][2]]+[f[2][0]+f[1][1]+f[0][2]]]\n    print(\"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\")",
    "fixed": "while True:\n    try:\n        f = [list(input()) for _ in range(3)]\n    except EOFError:\n        break\n    g = [\"\".join(x) for x in f+list(zip(*f))+[(f[0][0],f[1][1],f[2][2])]+[(f[2][0],f[1][1],f[0][2])]]\n    print(\"b\" if \"b\"*3 in g else \"w\" if \"w\"*3 in g else \"NA\")"
  },
  {
    "problem_id": "p00184",
    "problem_statement": "Tsuruga Castle\n\nTsuruga Castle, which is a symbol of Aizuwakamatsu City, was built by Ujisato Gamou with a fully-fledged castle tower and named it \"Tsuruga Castle\". From the castle tower, you can enjoy a panoramic view of the Aizu Basin. On a clear day, you can also see Tsuruga Castle from the summit of Iimoriyama, famous for the Byakkotai.\n\n\n\n\n\n\nIn order to use it as a reference for future public relations activities in Aizuwakamatsu City, we decided to conduct an age survey of visitors to Tsuruga Castle. Create a program that outputs the number of people in each age group below based on the visitor's age input.\n\n\n\n  Age GroupAge Range\nUnder 10  0  ~ 9\n 10's  10  ~ 19\n 20's  20  ~ 29\n 30's  30  ~ 39\n 40's  40  ~ 49\n 50's  50  ~ 59\nOver 60 60  ~\n\n\nInput\n\nThe input consists of a sequence of multiple datasets. The end of input is indicated by a line containing a single zero.\nEach dataset is given in the following format.\n\n\nn\na1\na2\n:\nan\n\n\nThe first line contains the number of visitors n (1 ≤ n ≤ 1000000), followed by n lines describing the age ai (0 ≤ ai ≤ 120) of the i-th visitor.\n\nOutput\n\nFor each dataset, output the number of people in each age group in the following format:\n\n1st line: Number of people under 10\n2nd line: Number of people in their 10's\n3rd line: Number of people in their 20's\n4th line: Number of people in their 30's\n5th line: Number of people in their 40's\n6th line: Number of people in their 50's\n7th line: Number of people over 60\n\nSample Input\n\n8\n71\n34\n65\n11\n41\n39\n6\n5\n4\n67\n81\n78\n65\n0\n\nOutput for the Sample Input\n\n2\n1\n0\n2\n1\n0\n2\n0\n0\n0\n0\n0\n0\n4\n",
    "buggy": "while True:\n    n = eval(input())\n    if n == 0: break\n    ans = [0,0,0,0,0,0,0]\n    for i in range(n):\n        age = eval(input())\n        if age <= 9:\n            ans[0] += 1\n        elif age <= 19:\n            ans[1] += 1\n        elif age <= 29:\n            ans[2] += 1\n        elif age <= 39:\n            ans[3] += 1\n        elif age <= 49:\n            ans[4] += 1\n        elif age <= 59:\n            ans[5] += 1\n        else:\n            ans[6] += 1\n    for c in ans:\n        print(c)",
    "fixed": "while True:\n    n = int(input())\n    if n == 0: break\n    ans = [0]*7\n    for i in range(n):\n        age = int(input())\n        if age <= 9:\n            ans[0] += 1\n        elif age <= 19:\n            ans[1] += 1\n        elif age <= 29:\n            ans[2] += 1\n        elif age <= 39:\n            ans[3] += 1\n        elif age <= 49:\n            ans[4] += 1\n        elif age <= 59:\n            ans[5] += 1\n        else:\n            ans[6] += 1\n    for c in ans:\n        print(c)"
  },
  {
    "problem_id": "p00185",
    "problem_statement": "Goldbach's Conjecture\n\nGoldbach's conjecture states that \"Every even integer greater than 6 can be expressed as the sum of two prime numbers (*1).\"\n\n\nFor example, the even number 12 can be expressed as 12 = 5 + 7, and 18 can be expressed as 18 = 5 + 13 = 7 + 11, etc.\n\n\nIf we list all the pairs of prime numbers whose sum is 134, we get the following:\n\n134 = 3+131 = 7+127 = 31+103 = 37+97 = 61+73 = 67+67 \n       = 131+3 = 127+7 = 103+31 = 97+37 = 73+61\n\n\nIt seems that as the given number becomes larger, we can find more and more pairs of prime numbers that add up to it. However, even modern mathematics cannot prove or disprove this conjecture (*2). It feels a bit strange, doesn't it?\n\n\nTherefore, to appreciate Goldbach's conjecture, please create a program that takes an even integer n as input and outputs the number of pairs of prime numbers whose sum is n.\n\n\nThe number of pairs of prime numbers whose sum is n and whose values are less than or equal to n is the number of combinations of positive prime numbers p and q such that n = p + q and p ≤ q. As we can see from the example above, there are 6 pairs of prime numbers whose sum is 134.\n\n\n(*1) A prime number is an integer that has no divisors other than 1 and itself. Note that 1 is not a prime number.\n(*2) As of February 2007, it has been verified for all even numbers up to 5×1017. (Wikipedia)\n\nInput\n\nThe input consists of multiple datasets. The end of the input is indicated by a single line containing a zero. For each dataset, a single even integer n (6 ≤ n ≤ 1000000) is given on a line.\n\n\nThere will be no more than 500 datasets.\n\nOutput\n\nFor each dataset, output the number of pairs of prime numbers on a single line.\n\nSample Input\n\n134\n4330\n34808\n98792\n0\n\nOutput for the Sample Input\n\n6\n72\n274\n607\n",
    "buggy": "# AOJ 0185 Goldbach's Conjecture II\n# Python3 2018.6.20 bal4u\n\nMAX = 1000000\nSQRT = 1000     # sqrt(MAX)\n\nprime = [True for i in range(MAX)]\nprime[1] = False\n\ndef sieve():\n\tfor i in range(3, SQRT, 2):\n\t\tif prime[i] is True:\n\t\t\tfor j in range(i*i, MAX, i):\n\t\t\t\tprime[j] = False\nsieve()\n\nprint(prime[1:20:2])\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\ti = j = n >> 1\n\tif (i & 1) == 0:\n\t\ti -= 1\n\t\tj += 1\n\tans = 0\n\twhile i > 0:\n\t\tif prime[i] and prime[j]: ans += 1\n\t\ti -= 2\n\t\tj += 2\n\tprint(ans)\n\n",
    "fixed": "# AOJ 0185 Goldbach's Conjecture II\n# Python3 2018.6.20 bal4u\n\nMAX = 1000000\nSQRT = 1000     # sqrt(MAX)\n\nprime = [True for i in range(MAX)]\nprime[1] = False\n\ndef sieve():\n\tfor i in range(3, SQRT, 2):\n\t\tif prime[i] is True:\n\t\t\tfor j in range(i*i, MAX, i):\n\t\t\t\tprime[j] = False\nsieve()\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\ti = j = n >> 1\n\tif (i & 1) == 0:\n\t\ti -= 1\n\t\tj += 1\n\tans = 0\n\twhile i > 0:\n\t\tif prime[i] and prime[j]: ans += 1\n\t\ti -= 2\n\t\tj += 2\n\tprint(ans)\n\n"
  },
  {
    "problem_id": "p00186",
    "problem_statement": "Aizuwakamatsu Jitokko\n\nIn April 2008, Aizuwakamatsu City succeeded in making a 20.85-meter-long yakitori. The chicken used at that time is Aizuwakamatsu's specialty, Aizuwakamatsu Jitokko. Aizuwakamatsu Jitokko is very delicious, but difficult to breed, so the production volume is small and the price is high.\n\n\n\n\n\n\nToday, relatives from far away are visiting Ichiro's house. His mother decided to make chicken hot pot and entertain her relatives. A nearby butcher shop sells two types of chicken: Aizuwakamatsu Jitokko and regular chicken. Ichiro's mother gave him the following instructions to buy chicken at the butcher shop:\n\n\nBuy more than the specified amount of chicken so that you don't run out of it.\nBuy as much Aizuwakamatsu Jitokko as possible within the budget (always buy Aizuwakamatsu Jitokko).\nBuy as much regular chicken as possible with the remaining Aizuwakamatsu Jitokko (don't buy if the budget is not enough).\n\n\nWhen Ichiro went to the butcher shop, they had limited the amount of Aizuwakamatsu Jitokko that one person could buy due to its shortage. What are the amounts of Aizuwakamatsu Jitokko and regular chicken that Ichiro should buy, respectively, to follow his mother's instructions?\n\n\nThe input consists of multiple datasets. The end of the input is indicated by a single zero. Each dataset is given in the following format.\n\n\nq1 b c1 c2 q2\n\n\nThe data q1 and q2 indicating the amount of chicken are in units of 100 grams. b, c1, c2, q1, and q2 are integers between 1 and 1,000,000.\n\n\nThe number of datasets does not exceed 50.\n\n\nFor each dataset, output the amounts of Aizuwakamatsu Jitokko and regular chicken that Ichiro should buy, respectively, in units of 100 grams, on one line. If you cannot purchase the chicken as instructed by Ichiro's mother, output \"NA\" instead.\n\nSample Input\n\n48 9297 240 126 32\n20 3010 157 141 7\n30 117002 5680 962 15\n8 1673 1712 190 22\n64 8478 87 54 307\n23 5477 117 92 12\n50 7558 1396 187 17\n279 88677 4522 514 14\n0\n\nOutput for the Sample Input\n\n28 20\n7 13\n15 33\nNA\n97 0\n12 44\nNA\nNA\n",
    "buggy": "# Aizu Problem 0186: Aizu Chicken\n#\nimport sys, math, os, bisect\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef aizu_chicken(q1, b, c1, c2, q2):\n    for i in range(q2, 0, -1):\n        cj = i * c1\n        normal = int((b - cj) / c2)\n        if i + normal < q1:\n            continue\n        elif normal >= 0:\n            print(i, normal)\n            break\n    else:\n        print(\"NA\")\n\n\nwhile True:\n    inp = [int(_) for _ in input().split()]\n    if len(inp) == 1:\n        break\n    q1, b, c1, c2, q2 = inp[:]\n    aizu_chicken(q1, b, c1, c2, q2)",
    "fixed": "# Aizu Problem 0186: Aizu Chicken\n#\nimport sys, math, os, bisect\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef aizu_chicken(q1, b, c1, c2, q2):\n    for i in range(q2, 0, -1):\n        cj = i * c1\n        normal = int((b - cj) // c2)\n        if i + normal < q1:\n            continue\n        elif normal >= 0:\n            print(i, normal)\n            break\n    else:\n        print(\"NA\")\n\n\nwhile True:\n    inp = [int(_) for _ in input().split()]\n    if len(inp) == 1:\n        break\n    q1, b, c1, c2, q2 = inp[:]\n    aizu_chicken(q1, b, c1, c2, q2)"
  },
  {
    "problem_id": "p00188",
    "problem_statement": "Search\n\n\"Search\" is the process of obtaining desired information from a lot of information. Familiar examples include \"finding your own test number from a lot of test numbers when the exam results are announced\" and \"finding Mr. Aizu's phone number from the telephone directory\". This operation of search is widely used in the field of computers as well.\n\n\n\n\n\n\nThere are many ways to search. Let's consider the search method that can be used when the data to be searched is arranged in order from small to large (or from large to small).\n\n\nBy using the relationship between the value in the middle of the data sequence arranged in order from small to large (or from large to small) and the target value, it is possible to determine whether to set the first half or the second half as the search range and narrow down the search range. There is a method of searching. The procedure is as follows.\n\n\nSet the entire data sequence as the search range.\nExamine the value in the middle of the search range.\nIf the target value and the value in the middle match, the search is terminated.\nIf the target value is smaller than the value in the middle, set the first half as the search range. If the target value is larger, set the second half as the search range and return to 2.\n\n\nThe following is an example of the above search method. The target value in this example is 51. Each data has a number (index) attached to it, and this number starts from 0.\n\n\n\n\n\n\n\nStep 1: Initially, set the entire range of numbers 0-6 as the search range.\n\n\nStep 2: Examine the value in the middle of the search range. However, \"the value in the middle\" is the value at the position of the number obtained by dividing the sum of the left and right numbers by 2. In other words, in this case, calculate (0 + 6) ÷ 2, and the value at number 3 (36) is the value in the middle.\n\n\nStep 3: Compare the target value (51) with the value in the middle (36).\n\n\nStep 4: Based on the result of Step 3, since the target value is greater than the value in the middle, set the range starting from number 4 (next to the value in the middle) as the search range for the second half. Similarly, by examining the value in the middle of the search range and setting the first half as the search range if the target value is smaller than the value in the middle or setting the second half as the search range if the target value is larger, the search range is narrowed down. Repeat steps 2 to 4 until the target value is found or the search range is exhausted. The search ends.\n\n\n\n\n\n\n\n\n\n\nCreate a program that takes an array of n numerical values as input and outputs the number of times the target value was compared to the value in the middle. However, when calculating the number of the value in the middle, if it cannot be divided exactly, the value obtained by truncating the decimal part is used as the number.\nIt is assumed that the given data sequence is sorted in ascending order.\n\nInput\n\nThe input consists of a sequence of multiple data sets. The end of the input is indicated by a single line containing a single zero. Each data set is given in the following format.\n\n\nn\na1\na2\n:\nan\nk\n\n\nThe first line contains the number of numerical values n (1 ≤ n ≤ 100), and the following n lines contain the ith numerical value ai (1 ≤ ai ≤ 100000, integers).\n\n\nThe next line contains the value k (1 ≤ k ≤ 100000) to be searched.\n\nOutput\n\nFor each data set, output the number of comparisons until the search is completed on one line.\n\nSample Input\n\n7\n11\n15\n23\n36\n51\n61\n86\n51\n4\n1\n2\n3\n5\n4\n0\n\n\nOutput for the Sample Input\n\n3\n3\n",
    "buggy": "def nibutan(f_id,e_id,f_num,count):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_num = n_lis[m_id]\n\n    count += 1\n    if (f_id > e_id):\n        return count\n    else:\n\n        if m_num > f_num:\n            return(nibutan(f_id,m_id -1,f_num,count))\n        elif m_num < f_num:\n            return(nibutan(m_id + 1,e_id,f_num,count))\n        else:\n            return count\n                \nwhile True:\n    global n_lis\n\n    n = int(input())\n    if n == 0:\n        break\n    n_lis = []\n    for i in range(n):\n        n_lis.append(int(input()))\n    f_n = int(input())\n    ans = nibutan(0,n,f_n,0)\n    print(ans)",
    "fixed": "def nibutan(f_id,e_id,f_num,count):\n    \n    \n    m_id = int((f_id + e_id) / 2)\n    m_num = n_lis[m_id]\n\n   \n    if (f_id > e_id):\n        return count\n    else:\n        count += 1\n\n        if m_num > f_num:\n            return(nibutan(f_id,m_id -1,f_num,count))\n        elif m_num < f_num:\n            return(nibutan(m_id + 1,e_id,f_num,count))\n        else:\n            return count\n                \nwhile True:\n    global n_lis\n\n    n = int(input())\n    if n == 0:\n        break\n    n_lis = []\n    for i in range(n):\n        n_lis.append(int(input()))\n    f_n = int(input())\n    ans = nibutan(0,n - 1,f_n,0)\n    print(ans)"
  },
  {
    "problem_id": "p00189",
    "problem_statement": "Convenient Town\n\nA who is going to graduate next spring decided to move when she got a job. The company she is going to work for has offices in several towns, and the office she goes to work at changes depending on the day. So, A decided to live in a town with a short commute to any office.\n\n\nYou are going to help A find the most convenient town to live in.\n\n\n\n\n\n\nTowns are numbered starting from 0, and there are roads between towns. The commute time is set for each road. When A is living in a certain town, the commute time to her own office is 0. In this case, consider the sum of the commute times to all towns. For example, if the arrangement of towns and roads is as shown in the figure above and A lives in town 1, the commute time to each town is as follows:\n\n\n\n   To town 0: 80\n   To town 1:  0\n   To town 2: 20\n   To town 3: 70\n   To town 4: 90\n\nand the total is 260.\n\n\nWrite a program that takes the number of roads and information about all roads as input, calculates the sum of the commute times for each town, and outputs the town number and the total commute time when it is the smallest. However, if there are multiple towns with the minimum total commute time, output the number of the smallest town and the total commute time at that time. Assume that there are 10 or fewer towns and 45 or fewer roads, and that all roads can be moved in both directions and the commute time does not change depending on the direction. Also, assume that there is a route from any town to all other towns.\n\nInput\n\nThe input consists of a sequence of multiple datasets. The end of the input is indicated by a single line with a single zero. Each dataset is given in the following format.\n\n\nn\na1 b1 c1\na2 b2 c2\n:\nan bn cn\n\n\nThe number of roads n (1 ≤ n ≤ 45) is given on the first line. The i-th line gives information about the i-th road.\nai, bi (0 ≤ ai, bi ≤ 9) are the numbers of the towns connected by the i-th road, and ci (0 ≤ ci ≤ 100) is the commute time for that road.\n\nOutput\n\nFor each dataset, output the town number and the total commute time when the total commute time is minimized, separated by a space, on one line.\n\nSample Input\n\n6     \n0 1 80\n1 2 20\n0 2 60\n2 3 50\n3 4 60\n1 4 90\n2\n0 1 1\n1 2 1\n0\n\nOutput for the Sample Input\n\n2 240\n1 2\n",
    "buggy": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0189\nAC\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef warshallFloyd(V, dp):\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dp_ik = dp[i][k]\n                dp_kj = dp[k][j]\n                if dp[i][j] < dp_ik + dp_kj:\n                    dp[i][j] = dp_ik + dp_kj\n\n\ndef main(args):\n    while True:\n        n_max = 9+1\n        n = int(input())\n        if n == 0:\n            break\n        dp = [[float('inf')] * n_max for _ in range(n_max)]\n        for i in range(n_max):\n            dp[i][i] = 0\n\n        max_town = 0\n        for _ in range(n):\n            a, b, c = map(int, input().split())\n            dp[a][b] = c\n            dp[b][a] = c\n            max_town = max(max_town, a, b)\n\n        warshallFloyd(max_town + 1, dp)\n\n\n        min_dist = float('inf')\n        town_live = -1\n        for i, d in enumerate(dp[:max_town+1]):\n            sum_dist = 0\n            for ele in d[:max_town+1]:\n                sum_dist += ele\n            if sum_dist < min_dist:\n                min_dist = sum_dist\n                town_live = i\n\n        print('{} {}'.format(town_live, min_dist))\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    ",
    "fixed": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0189\nAC\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef warshallFloyd(V, dp):\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dp_ik = dp[i][k]\n                dp_kj = dp[k][j]\n                if dp[i][j] > dp_ik + dp_kj:\n                    dp[i][j] = dp_ik + dp_kj\n\n\ndef main(args):\n    while True:\n        n_max = 9+1\n        n = int(input())\n        if n == 0:\n            break\n        dp = [[float('inf')] * n_max for _ in range(n_max)]\n        for i in range(n_max):\n            dp[i][i] = 0\n\n        max_town = 0\n        for _ in range(n):\n            a, b, c = map(int, input().split())\n            dp[a][b] = c\n            dp[b][a] = c\n            max_town = max(max_town, a, b)\n\n        warshallFloyd(max_town + 1, dp)\n\n\n        min_dist = float('inf')\n        town_live = -1\n        for i, d in enumerate(dp[:max_town+1]):\n            sum_dist = 0\n            for ele in d[:max_town+1]:\n                sum_dist += ele\n            if sum_dist < min_dist:\n                min_dist = sum_dist\n                town_live = i\n\n        print('{} {}'.format(town_live, min_dist))\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "problem_id": "p00191",
    "problem_statement": "Saplings\n\n Dr. Sato, a botanist, has invented several special fertilizers for saplings. When given to saplings, their size changes in an instant.\n However, it turned out that the fertilizer has the following side effects:\n\n\n Giving fertilizer only once does not change the size of the sapling.\n Starting with the second time, the sapling is affected by the combination of the fertilizer given at that time and the fertilizer given just before it. If it has a good effect, the sapling grows, and if it has a bad effect, the sapling may shrink.\n\n\n To see what happens, Dr. Sato examined the growth of saplings based on the combination of the fertilizer he gave at a certain point and the fertilizer he gave just before it for 3 types of fertilizers (fertilizers 1, 2, and 3) and created the following \"Growth Table\".\n\n\n\n\n\n The first row of the table on the right shows the fertilizer number given at that time, and the first column shows the number of the fertilizer given just before that. The other numbers indicate the growth of the sapling due to the combination of the fertilizer given just before and the fertilizer given at that time (the ratio of the size after growth to the size before growth). If the growth is greater than 1.0, the sapling grows, and if it is less than 1.0, the sapling shrinks. For example, if fertilizer 2 is given after fertilizer 1, the size of the sapling will triple, but if fertilizer 3 is given after fertilizer 1, the size of the sapling will shrink by half.\n\n\n\n\n\n\n\n\n\n If the number of times fertilizer is given to the saplings is limited, which fertilizer should be given in what order to make the saplings grow as large as possible? The \"Growth Table\" provides the answer. For example, if the fertilizers in the above table are given only 3 times, the saplings will grow the most if they are given in the order of fertilizer 3, fertilizer 1, and fertilizer 2 as shown below.\n\n\n\n\n\n\n The size of the sapling does not change with the first fertilizer (fertilizer 3) \n For the second fertilizer (fertilizer 1), the growth rate with fertilizer 1 after fertilizer 3 is 3.0 according to the table, so the size of the sapling will triple from the previous time.\n For the third fertilizer (fertilizer 2), the growth rate with fertilizer 2 after fertilizer 1 according to the table is 3.0, so the size of the sapling will triple again from the previous time and become 9.0 times the original size of 3.0x3.0.\n\n\n This time, Dr. Sato has examined all n types of fertilizers he has invented and created a \"Growth Table\" like the one above. However, the table has become very large, and he is having a hard time determining the order in which the fertilizers should be given.\n\n\n Instead of Dr. Sato, create a program that takes the growth rate value of the sapling due to the combination of the n types of fertilizers and the number of times the fertilizer is given as input, and finds the maximum size of the sapling after giving the fertilizer m times. The size of the first sapling is 1, and the growth rate of the fertilizer given the first time is 1.0 for any fertilizer. Fertilizers are numbered from 1 to n.\n\n\nInput\n\n The input consists of multiple datasets. The end of the input is indicated by two zeros in a row. Each dataset is given in the following format:\n\n\nn m\ng11 g12 ... g1n\ng21 g22 ... g2n\n:\ngn1 gn2 ... gnn\n\n\n The number of types of fertilizers n (2 ≤ n ≤ 100) and the number of times the fertilizers are given m (1 ≤ m ≤ 100) are given on the first line.\n\n\n The growth rate gij (0.0 ≤ gij ≤ 10.0, real number) of the sapling when fertilizer i is given followed by fertilizer j is given for the next n lines.\n\n\n The number of datasets is no more than 20.\n\nOutput\n\n For each dataset, output the maximum size of the sapling in one line. The size of the sapling to be output should be rounded to two decimal places by rounding to the nearest third decimal place.\n\nSample Input\n\n3 3          \n1.3 3.0 0.5 \n2.4 2.1 1.0\n3.0 0.8 1.2\n2 2\n1.0 1.0\n1.0 1.0\n0 0\n\nOutput for the Sample Input</H2",
    "buggy": "# AOJ 0191: Baby Tree\n# Python3 2018.6.20 bal4u\n\nwhile True:\n\tn, m = list(map(int, input().split()))\n\tif n == 0: break\n\td =  [[0.0 for j in range(n)] for i in range(n)]\n\tfor i in range(n): d[i] = list(map(float, input().split()))\n\tdp =  [[0.0 for j in range(n)] for i in range(n)]\n\tfor i in range(n): dp[0][i] = 1\n\tfor k in range(1, m):\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tdp[k][j] = max(dp[k][j], dp[k-1][i]*d[i][j])\n\tans = 0\n\tfor i in range(n):\n\t\tif dp[m-1][i] > ans: ans = dp[m-1][i]\n\tprint(format(ans, \".2f\"))\n\n",
    "fixed": "# AOJ 0191: Baby Tree\n# Python3 2018.6.20 bal4u\n\nwhile True:\n\tn, m = list(map(int, input().split()))\n\tif n == 0: break\n\td =  [[0.0 for j in range(n)] for i in range(n)]\n\tfor i in range(n): d[i] = list(map(float, input().split()))\n\tdp =  [[0.0 for j in range(n)] for k in range(m)]\n\tfor i in range(n): dp[0][i] = 1\n\tfor k in range(1, m):\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tdp[k][j] = max(dp[k][j], dp[k-1][i]*d[i][j])\n\tans = 0\n\tfor i in range(n):\n\t\tif dp[m-1][i] > ans: ans = dp[m-1][i]\n\tprint(format(ans, \".2f\"))\n\n"
  },
  {
    "problem_id": "p00192",
    "problem_statement": "Multi-Story Parking Lot\n\n\n\n\nIn cities, there are various parking lots such as multi-story and tower types to improve the efficiency of parking lot use. Among them, there are also parking lots that have \"two-tiered parking devices\" like the one in the figure installed in one parking space, securing parking spaces for two cars. This two-tiered parking device can park one car on a lifting pallet (a flat iron plate on which a car is placed) and park the other car on the lower tier.\n\n\nIn a parking lot that uses this type of two-tiered parking device, whenever a car on the upper tier is taken out or parked, it is necessary to take out and move the car parked on the lower tier each time. Therefore, the manager always keeps the key of the parked car and performs the entry and exit of the car as needed.\n\n\n\n\n\n\n\n\nTsuruga Parking Lot is one of the parking lots that has this type of two-tiered parking device, but due to the shortage of personnel, a person who cannot drive a car has become the manager. As a result, once a car is parked, it cannot be moved until the customer returns, and the car parked on the upper tier cannot be released until the owner of the car parked on the lower tier returns.\n\n\nTo assist the manager who needs to efficiently handle the cars that come to park one after another, create a program that meets the rules of the Tsuruga Parking Lot.\n\nEquipment at Tsuruga Parking Lot\n\nThere is one or more parking spaces, and all of them have two-tiered parking devices installed.\nEach parking space is assigned a number in order from 1.\nAt first, it is assumed that no car is parked in the parking lot.\n\nThe Tsuruga Parking Lot adopts the following rules.\nWhen parking a car\n\nThe parking time of the car to be parked is notified to the manager.\nPark in the parking space without any car parked first.\nIf there is no parking space where no car is parked, park in the available parking space. However, when there are multiple such parking spaces, park as follows:\n\nIf there is a car that has a remaining parking time that exceeds the parking time of the car to be parked, park in the parking space with the smallest difference.\nIf none of the remaining parking times of the parked cars is less than the parking time of the car to be parked, park in the parking space with the smallest difference.\n\nIf the parking lot is full (there are no empty parking spaces), the car trying to park waits in order until a parking space becomes available. As soon as a parking space becomes available, park in order from the first car that was waiting.\n\n\n※In each condition, it is assumed that the car parks in the smallest parking space number. In addition, if there are cars leaving at the same time, all the cars leave before parking, and as long as there are waiting cars, as many cars as possible can park at the same time.\n\nWhen a car leaves\n\nA car that has exceeded the parking time notified to the manager will leave.\nIf there are multiple cars that have exceeded the parking time at multiple parking spaces, the car with the smaller parking space number will leave first.\nIf the parking time of a car parked on the upper tier has expired, it must wait until the car parked on the lower tier leaves. The car on the upper tier will leave at the same time as the car on the lower tier.\n\n\nThe figure below shows an example of the parking method of Tsuruga Parking Lot. In this example, there are three parking spaces, and cars B to E are already parked. Consider that a car A with a parking time of 70 minutes has arrived. Since two spaces are already occupied in parking space 3, it cannot be parked there, so it will be parked in either parking space 1 or parking space 2, both of which are available. The remaining parking time of car B parked in parking space 1 is 50 minutes, and the remaining parking time of car C parked in parking space 2 is 22 minutes, both of which are less than the parking time of car A, so car A will be parked in parking space 1, where the difference between the parking times and the remaining parking time of car B is smaller. As a result, the previously parked car B is now on",
    "buggy": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs1 = []\n  outs2 = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs1.append(c2[1])\n        outs2.append(c1[1])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs1.append(c2[1])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs1.append(c1[1])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append(c2[1])\n        parking[i][1] = None\n  outs1.sort()\n  outs2.sort()\n  return outs1 + outs2\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      break\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      break\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n",
    "fixed": "from collections import deque\n\ndef out(time, parking):\n  x = len(parking)\n  outs = []\n  for i in range(x):\n    for j in range(2):\n      if parking[i][j] != None:\n        parking[i][j][0] -= time\n  \n  for i in range(x):\n    c1 = parking[i][0]\n    c2 = parking[i][1]\n    if c1 != None and c2 != None:\n      if c1[0] <= 0 and c2[0] <= 0:\n        outs.append([c2[1], c1[1]])\n        parking[i][0] = None\n        parking[i][1] = None\n      elif c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n    elif c1 != None:\n      if c1[0] <= 0:\n        outs.append([c1[1]])\n        parking[i][0] = None\n    elif c2 != None:\n      if c2[0] <= 0:\n        outs.append([c2[1]])\n        parking[i][1] = None\n  lst = []\n  for l in outs:\n    lst += l\n  return lst\n\ndef into(num, time, parking):\n  x = len(parking)\n  times = []\n  for i in range(x):\n    if parking[i] == [None, None]:\n      parking[i][0] = [time, num]\n      return\n    if parking[i][0] == None:\n      times.append((parking[i][1][0], i))\n    elif parking[i][1] == None:\n      times.append((parking[i][0][0], i))\n  times.sort()\n  \n  for t, ind in times:\n    if t >= time:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n  else:\n    max_t = t\n\n  for t, ind in times:\n    if t == max_t:\n      if parking[ind][0] == None:\n        parking[ind][0] = [time, num]\n      else:\n        parking[ind][1] = [time, num]\n      return\n \nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n  \n  parking = [[None] * 2 for _ in range(m)]\n  wait = deque()\n  space = m * 2\n  ans = []\n  \n  for t in range(120 * n):\n    o = out(1, parking)\n    if o:\n      space += len(o)\n      ans += o\n\n    if t % 10 == 0 and t <= 10 * (n - 1):\n      time = int(input())\n      wait.append((t // 10 + 1, time))\n\n    for i in range(min(space, len(wait))):\n      num, time = wait.popleft()\n      into(num, time, parking)\n      space -= 1\n  print(*ans)\n"
  },
  {
    "problem_id": "p00193",
    "problem_statement": "Convenience Store\n\n\n\n\nTo expand its business, the convenience store Seven-Eleven is considering opening its first store in Wakamatsu City. Since there are already many other convenience stores in Wakamatsu City, the location of the new store is likely to be the key to success. Under the premise of \"customers will use the convenience store closest to their home area,\" Seven-Eleven plans to open a store at a location where \"many customers are likely to use it.\"\n\n\n\n\n\n\n\n\nSeven-Eleven divided the map of Wakamatsu City into congruent regular hexagons (\"blocks\") to understand the range covered by each existing convenience store. At this time, the city was divided into blocks so that at most one existing convenience store could be included in each block. Based on the number of blocks that need to be traversed to reach a convenience store from each block, the distance between the convenience store and each block is determined. Each block is considered to be covered by the convenience store that covers it with the shortest distance. The problem is to find the \"blocks for which there are no existing convenience stores that cover as many blocks as possible\" based on this map.\n\n\nYou are a programmer at Seven-Eleven, and you have been tasked with developing a program to calculate the maximum number of blocks that can be covered from all candidate locations based on the map divided into blocks and information about the candidate location of the new store.\n\n\nThe map divided into blocks of m × n is represented as shown in Figure 1. Blocks of hexagons are arranged horizontally in m rows and vertically in n columns, each represented by a coordinate (x, y). The left edge of odd-numbered rows is located just below the left edge of the row above it, and the left edge of even-numbered rows is located just below the left edge of the row above it. For example, coordinate (1, 1) represents the top-left block in Figure 1. Coordinate (1, 2) is located just below coordinate (1, 1), and coordinate (1, 3) is located just below coordinate (1, 2).\n\n\n\n\n\n\nFigure 2 shows an example where there are six existing convenience stores, divided into a 6 × 6 map. Each convenience store is numbered in order from 1. When the blocks covered by each convenience store are colored by number, they are divided as shown in Figure 3. Blocks that are not colored, such as block (1, 4) and (2, 5), have two or more convenience stores that are closest, and cannot be determined which convenience store covers the block. For example, in the case of block (1, 4), the distance to convenience stores 4 and 5 is equal, and it is assumed that there is no convenience store that covers this block. The number of blocks covered by convenience store 4 is 5.\n\n\n\n\n\n\nSuppose Seven-Eleven is considering locations (1, 3) and (5, 3) as candidate locations for the new store. If a store is located at (1, 3), it can cover three blocks (Figure 4). On the other hand, if a store is located at (5, 3), it can cover four blocks (Figure 5). Therefore, the maximum number of blocks that can be covered is 4.\n\n\n\n\n\n\nThe input consists of multiple datasets. The end of the input is indicated by",
    "buggy": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in range(n)]\n    return cover\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in range(m)] for y in range(n)]\n    def count(cover):\n        ret = 0\n        return ret\n        for y in range(n):\n            for x in range(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = input()\n    if data == \"0\":\n        break\n    m, n = list(map(int, data.split()))\n    s = eval(input())\n    spos = [list(map(int, input().split())) for _ in range(s)]\n    t = eval(input())\n    tpos = [list(map(int, input().split())) for _ in range(t)]\n    print(solve())",
    "fixed": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in range(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in range(m)] for y in range(n)]\n    def count(cover):\n        ret = 0\n        for y in range(n):\n            for x in range(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    try:\n        data = input()\n        if data == \"0\":\n            break\n        m, n = list(map(int, data.split()))\n        s = eval(input())\n        spos = [list(map(int, input().split())) for _ in range(s)]\n        t = eval(input())\n        tpos = [list(map(int, input().split())) for _ in range(t)]\n        print(solve())\n    except:\n        break"
  },
  {
    "problem_id": "p00195",
    "problem_statement": "What are the popular stalls?\n\n\n\n\nIn Aizu-Wakamatsu City, there is a first market called \"Tokaichi\" on January 10th every year. This Tokaichi has a history of about 600 years and is the largest first market in the Aizu region. It is also well known that \"Okiai Ko-boshi\", a familiar good luck item in the Aizu region, is sold. Okiai Ko-boshi is a doll with a center of gravity at the bottom that is about 3 cm in size, and its name comes from the fact that it stands up immediately even if it falls. In each household, one more than the family must be purchased and offered to the household shrine. This one has the meaning of \"increasing the family\" or \"carrying the burden of misfortune\".\n\n\n\n\n\n\n\n\n\nThe Tokaichi Executive Committee has decided to investigate the store with the highest sales of Okiai Ko-boshi for the next Tokaichi. The number of stores this year is five (A, B, C, D, E: lowercase letters), and the number of items sold has been reported to the Tokaichi Executive Committee separately for the morning and afternoon sessions.\n\n\nCreate a program that takes information for each store as input and outputs the name and number of the store with the highest sales for the day.\n\nInput\n\nThe input consists of a sequence of multiple data sets. The end of the input is indicated by two zeros on a line.\nEach dataset is given in the following format.\n\n\ns1A s2A\ns1B s2B\ns1C s2C\ns1D s2D\ns1E s2E\n\n\nFor the i-th line, the morning sales s1i and the afternoon sales s2i (1 ≤ s1i, s2i ≤ 10000) for stores A, B, C, D, and E are given. It is assumed that there are no stores that sell the same number of items for the day.\n\n\nThe number of datasets is no more than 100.\n\nOutput\n\nFor each dataset, output the name and number of the store with the highest sales for the day on one line.\n\nSample Input\n\n1593 4311\n4321 2155\n1256 6421\n5310 1455\n2152 5421\n1549 3386\n4528 3719\n1234 4321\n3330 3109\n2739 2199\n0 0\n\nOutput for the Sample Input\n\nC 7677\nB 8247\n",
    "buggy": "l=[]\nwhile True:\n    n,k=list(map(int,input().split()))\n    cnt+=1\n    if n==k==0:\n        break\n    l.append(n+k)\n    if cnt%5==0:\n        print(chr(l.index(max(l))+65),max(l))\n        l=[]",
    "fixed": "cnt=0\nl=[]\nwhile True:\n    n,k=list(map(int,input().split()))\n    cnt+=1\n    if n==k==0:\n        break\n    l.append(n+k)\n    if cnt%5==0:\n        print(chr(l.index(max(l))+65),max(l))\n        l=[]"
  },
  {
    "problem_id": "p00196",
    "problem_statement": "Baseball Tournament\n\nJapan achieved two consecutive victories in the World Baseball Classic (WBC) in a time when baseball popularity is on the rise. A baseball tournament was held at Aizu Gakuho High School. In this tournament, a round-robin league was held, and the ranking was determined by the following methods:\n\n\n Teams with more wins are ranked higher\n If the number of wins is the same, the team with fewer losses is ranked higher\n\n\nPlease create a program that inputs the results of each team and outputs the team names in order from the top teams. If there are teams with the same rank, please output them in the order in which they were input. The number of teams n is an integer between 2 and 10, the team name t is a single half-width English alphabet, and the results of each game r are represented by n-1 digits, with 0 representing a win, 1 representing a loss, and 2 representing a tie. It is also assumed that there are no duplicate team names.\n\nInput\n\nA sequence of multiple data sets is given as input. The end of the input is indicated by a single zero line.\nEach dataset is given in the following format.\n\n\nn\nscore1\nscore2\n:\nscoren\n\n\nThe first line contains the number of teams n (2 ≤ n ≤ 10), and the following n lines give the scores of each team. Each score is given in the following format.\n\n\nt r1 r2 ... rn−1\n\n\nThe team name t (a single half-width English alphabet) and the results of each game ri (0, 1, or 2) for t are given separated by a space.\n\n\nThe number of datasets does not exceed 50.\n\nOutput\n\nFor each dataset, output the team names from the top teams in order.\n\nSample Input\n\n6\nA 1 0 0 2 0\nB 0 0 1 1 0\nC 1 1 1 1 1\nD 1 0 0 1 2\nE 2 0 0 0 0\nF 1 1 0 2 1\n4\ng 1 1 1\nh 0 1 2\nw 0 0 0\nb 0 2 1\n0\n\nOutput for the Sample Input\n\nE\nA\nB\nD\nF\nC\nw\nh\nb\ng\n",
    "buggy": "import sys\nf = sys.stdin\n\nwhile True:\n    n = int(f.readline())\n    if n == 0:\n        break\n    teams = [f.readline().split() for i in range(n)]\n    \n    teams = [(t[0], -t.count('0'), t.count('1'), i) for i, t in enumerate(teams)]\n    \n    teams.sort(key=operator.itemgetter(1,2,3))\n    \n    print('\\n'.join([t[0] for t in teams]))",
    "fixed": "import sys\nimport operator\nf = sys.stdin\n\nwhile True:\n    n = int(f.readline())\n    if n == 0:\n        break\n    teams = [f.readline().split() for i in range(n)]\n    \n    teams = [(t[0], -t.count('0'), t.count('1'), i) for i, t in enumerate(teams)]\n    \n    teams.sort(key=operator.itemgetter(1,2,3))\n    \n    print('\\n'.join([t[0] for t in teams]))"
  },
  {
    "problem_id": "p00197",
    "problem_statement": "Greatest Common Divisor - Euclidean Algorithm\n\nThe greatest common divisor is an essential element in mathematics that is necessary to handle on computers. Using the greatest common divisor can significantly affect the efficiency of calculations. One of the algorithms used to find the greatest common divisor is the \"Euclidean algorithm\". The process is shown below.\n\n\n\n\n\n\nFor example, if we have 1071 and 1029, we assign 1071 to X, and 1029 to Y. Then, we take the remainder of 1071 divided by 1029, which is 42. We assign 42 to X, and swap X and Y (1 step).\n\nThen, we take the remainder of 1029 divided by 42, which is 21. We assign 21 to X, and swap X and Y (2 steps).\n                                                  \nFinally, we take the remainder of 42 divided by 21, which is 0. We assign 0 to X, and swap X and Y (3 steps).\nSince Y is now 0, the value of X at this point is the greatest common divisor. Therefore, the greatest common divisor of 1071 and 1029 is 21.\n\n\nAs shown above, we can find the greatest common divisor of 1071 and 1029 by performing only three steps. The Euclidean algorithm can provide results much faster than the method of finding all divisors and comparing them.\n\n\nWrite a program that takes two integers as input and uses the Euclidean algorithm to find their greatest common divisor. Output the greatest common divisor and the number of steps it took to calculate it.\n\nInput\n\nThe input consists of multiple datasets. The end of the input is indicated by two consecutive zeros on separate lines.\nFor each dataset, two integers a, b (2 ≤ a, b ≤ 231-1) are given on one line.\n\n\nThere are no more than 1000 datasets.\n\nOutput\n\nFor each dataset, output the greatest common divisor of the two integers entered and the number of steps required for the Euclidean algorithm, separated by a space, on one line.\n\n\nSample Input\n\n1071 1029\n5 5\n0 0\n\nOutput for the Sample Input\n\n21 3\n5 1\n",
    "buggy": "def gcd(a,b):\n    c=0\n    while b:(a,b),c=(b,a%b),c+1\n    print(a,c)\nwhile 1:\n    n,m=map(int,input().split())\n    if n==0:break\n    gcd(n,m)",
    "fixed": "def gcd(a,b):\n    c=0\n    while b:(a,b),c=(b,a%b),c+1\n    print(a,c)\n \nwhile 1:\n    n,m=map(int,input().split())\n    if n==0:break\n    gcd(n,m) if n>m else gcd(m,n)"
  },
  {
    "problem_id": "p00200",
    "problem_statement": "One-way Ticket to Youth\n\nTaro-kun is planning a long trip by train during the summer vacation. However, as a high school student, Taro-kun only has a one-month summer vacation, so in order to travel as far away as possible, he needs to find the cheapest and fastest way to travel. Let's create a program to help Taro-kun plan his trip so he can enjoy a wonderful journey.\n\n\n\n\n\n\n\nGiven information about the railway and the number of stations, create a program that will output the minimum cost or shortest time in response to a query.\n\nInput\n\nThe input is a sequence of multiple datasets. The end of the input is indicated by two consecutive zeros. Each dataset is given in the following format.\n\n\nn m\na1 b1 cost1 time1\na2 b2 cost2 time2\n:\nan bn costn timen\nk\np1 q1 r1\np2 q2 r2\n:\npk qk rk\n\n\nThe first line contains the number of railway information n (1 ≤ n ≤ 3000) and the number of stations m (1 ≤ m ≤ 100).\n\n\nFor each of the following n lines, information about the i-th line is given. For each line, the numbers of the two stations connected by the line, ai and bi (1 ≤ ai, bi ≤ m), and the cost costi (1 ≤ costi ≤ 1000) and travel time timei (1 ≤ timei ≤ 1000) are given. If ai and bi are connected by a line, both movements from ai to bi and from bi to ai are possible at the same cost and travel time.\n\n\nThe next line contains the number of queries k (1 ≤ k ≤ 200). For the following k lines, the i-th query is given. For each query, the departure station pi, arrival station qi, and type of value to output ri (0 or 1) are given. Note that there is always a route for each query.\n\n\nThe number of datasets does not exceed 50.\n\nOutput\n\nFor each dataset, output the minimum cost or shortest time on one line. If ri is 0, output the minimum cost; if ri is 1, output the shortest time.\n\nSample Input\n\n6 5\n1 2 200 10\n1 4 400 15\n1 3 250 25\n2 4 100 10\n4 5 150 20\n3 5 300 20\n2\n1 5 0\n1 5 1\n0 0\n\nOutput for the Sample Input\n\n450\n35\n",
    "buggy": "\ninf = 0x10101010\n\ndef solve(A, strt):\n\tcost = [inf]*m  \n\tvisited = [False]*m\n\tcost[strt] = 0\n\t\n\twhile True:\n\t\tmin = inf \n\t\tnext = -1   \n\t\tvisited[strt] = True \n\t\tfor i in range(m):\n\t\t\tif visited[i]:\n\t\t\t\tcontinue\n\t\t\tif A[strt][i]:\n\t\t\t\td = cost[strt] + A[strt][i]\n\t\t\t\tif d < cost[i]:\n\t\t\t\t\tcost[i] = d\n\t\t\t\tif cost[i] < min:\n\t\t\t\t\tmin = cost[i]\n\t\t\t\t\tnext = i\n\t\tstrt = next \n\t\tif next == -1: break\n\treturn cost\n\t\t\t\t\t\t\n\n\n\nwhile True:\n\t#  経路の情報の数n,駅の数m\n\tn, m = list(map(int, input().split()))\n\tif n == 0:\n\t\tbreak\n\tT = [[0]*m for i in range(m)]\n\tC = [[0]*m for i in range(m)]\n\n\tfor i in range(n):\n\t\ta, b, c, t = list(map(int, input().split())) # 駅 駅 time cost\n\t\tT[a-1][b-1] = T[b-1][a-1] = t \n\t\tC[a-1][b-1] = C[b-1][a-1] = c\n\tTS = [solve(T, i) for i in range(m)]\n\tCS = [solve(C, i) for i in range(m)]\n\tfor i in range(eval(input())):\n\t\ta, b, q = list(map(int, input().split()))\n\t\tif q == 0:\n\t\t\tprint(CS[a-1][b-1])\n\t\telse:\n\t\t\tprint(TS[a-1][b-1])",
    "fixed": "inf = 0x10101010\ndef solve(A, strt):\n\tcost = [inf]*m  \n\tvisited = [False]*m\n\tcost[strt] = 0\n\twhile True:\n\t\tmin = inf \n\t\tnext = -1   \n\t\tvisited[strt] = True \n\t\tfor i in range(m):\n\t\t\tif visited[i]: continue\n\t\t\tif A[strt][i]:\n\t\t\t\td = cost[strt] + A[strt][i]\n\t\t\t\tif d < cost[i]:\n\t\t\t\t\tcost[i] = d\n\t\t\tif min > cost[i]:\t\n\t\t\t\tmin = cost[i]\n\t\t\t\tnext = i\n\t\tstrt = next \n\t\tif next == -1: break\n\treturn cost\n\t\t\t\t\t\t\nwhile True:\n\tn,m = list(map(int, input().split()))\n\tif n == 0:break\n\tT = [[0]*m for i in range(m)]\n\tC = [[0]*m for i in range(m)]\n\tfor i in range(n):\n\t\ta,b,c,t = list(map(int, input().split())) \n\t\tT[a-1][b-1] = T[b-1][a-1] = t \n\t\tC[a-1][b-1] = C[b-1][a-1] = c\n\tTS = [solve(T,i) for i in range(m)]\n\tCS = [solve(C,i) for i in range(m)]\n\tfor i in range(eval(input())):\n\t\ta, b, q = list(map(int,input().split()))\n\t\tif q == 0:\n\t\t\tprint(CS[a-1][b-1])\n\t\telse:\n\t\t\tprint(TS[a-1][b-1])"
  },
  {
    "problem_id": "p00201",
    "problem_statement": "Alchemy Master\n\nYou have finally obtained the magic cauldron, the alchemy cauldron. When you put multiple items in the alchemy cauldron, you can create a new item. The newly created item can also be put into the alchemy cauldron to create other items. We will call the list of items required to create an item the alchemy recipe. The following are three examples of alchemy recipes.\n\n\n A racket can be made from wood and string. \n Onigiri can be made from rice and water. \n A guitar can be made from a racket, a microphone, and onigiri. \n\n\nItems can also be obtained by purchasing them with money, but it may be cheaper to create them using the alchemy cauldron. For example, suppose the purchase price of each item is given as follows.\n\n\n\nItem Name Purchase Price (yen)\n   Wood            3,000\n   String                800\n   Rice                36\n   Water                  0\n   Racket           5,000\n   Microphone ",
    "buggy": "q,w,e=range,(lambda: eval(input())),input\nwhile True:\n  n=w()\n  if n==0:break\n  d={}\n  for i in q(n):\n    o=e().split()\n    d[o[0]]=int(o[1])\n  for j in q(w()):\n    t=e().split()\n    a=sum([d[i] for i in t[2:]])\n    d[t[0]]=a if a<d[t[0]] else d[t[0]]\n  print(d[e()])\n",
    "fixed": "q,w,e=range,(lambda: eval(input())),input\nwhile True:\n  n=w()\n  if n==0:break\n  d={}\n  for i in q(n):\n    o=e().split()\n    d[o[0]]=int(o[1])\n  for j in q(w()):\n    t=e().split()\n    a=sum([d[i] if i in d else 0 for i in t[2:]])\n    d[t[0]]=a if a<d[t[0]] else d[t[0]]\n  print(d[e()])\n"
  },
  {
    "problem_id": "p00203",
    "problem_statement": "New Plan for Aizu-yama Ski Resort\nAizu-yama Ski Resort, owned by Mr. Aburagi, has prepared a course with obstacles and jumps for advanced skiers. There are various ways to slide on the course, and those who can slide in all patterns during the season will receive a gift.\nLet's create a program that outputs the number of sliding patterns based on the course map for Mr. Aburagi.\n\n\n\nThe course is represented by a grid of X × Y squares, like the one shown above. The origin is the upper left corner, and the x-coordinate increases to the right and the y-coordinate increases downward. \nEach sliding pattern starts from the highest point (y = 1, where there are no obstacles) and progresses towards the goal (y = Y). The skier on the square (x, y) can move to (x − 1, y + 1), (x, y + 1), or (x + 1, y + 1). There are obstacles and jump platforms on some squares; you cannot enter a square with an obstacle, and entering a square with a jump platform will move you to (x, y + 2). However, there are no jump platforms on the highest square (y = 1), and you can only enter a square with a jump platform from a square with the same x-coordinate. If you start from the top of the course (y = 1) and cross the bottom of the course without leaving it (y ≥ Y), it is considered one sliding pattern, and the slide is complete.\nGiven the course map as input, create a program that outputs the total number of sliding patterns.\nInput\nThe input consists of multiple datasets. The end of the input is indicated by two consecutive zeros. Each dataset is provided in the following format.\n\nX Y\nc11 c21 ... cX1\nc12 c22 ... cX2\n:\nc1Y c2Y ... cXY\t\n\nThe first line contains the size of the course X, Y (1 ≤ X, Y ≤ 15). The following Y lines contain the course information. The integer cij (0, 1, or 2) represents the information of the square (x = i, y = j) and represents the following:\n\n0: A square you can move to\n1: A square with an obstacle\n2: A square with a jump platform\n\nThere will be no more than 50 datasets.\nOutput\nFor each dataset, output the total number of sliding patterns of the course in a line.\nSample Input\n\n5 5\n0 0 0 0 1\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n5 5\n0 0 1 0 0\n2 1 0 2 0\n1 0 0 1 1\n0 2 1 2 0\n0 1 0 0 0\n15 15\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0\n0 0\n\nSample Output\n\n8\n6\n52694573\n",
    "buggy": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n    if y_limit < 2:\n        return len(Q)\n\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] != OBSTACLE:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])",
    "fixed": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque, defaultdict\ninput = stdin.readline\n\n\ndef solve(field):\n    BLANK, OBSTACLE, JUMP = 0, 1, 2\n    ans = 0                     #  ??????????????°???????????°\n\n    dy = [1, 1, 1]  # ?????????????????????????????????????§???????\n    dx = [0, -1, 1]\n    x_limit = len(field[0])\n    y_limit = len(field)\n\n    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????\n    Q = deque()\n    for x, m in enumerate(field[0]):\n        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????\n            t = '{}_{}'.format(x, 0)\n            Q.append((x, 0))\n            path[t] = 1\n\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        t = '{}_{}'.format(cx, cy)\n        num = path.pop(t)\n\n        if field[cy][cx] == OBSTACLE:\n            continue\n        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°\n            if cy+2 > y_limit-1:\n                ans += num\n            else:\n                t = '{}_{}'.format(cx, cy+2)\n                if not path[t]:\n                    Q.append((cx, cy+2))\n                path[t] += num\n            continue\n        elif cy == y_limit -1:\n            ans += num\n            continue\n\n        for i in range(len(dx)):\n            nx = cx + dx[i]     #  ?????°????????§?¨?\n            ny = cy + dy[i]\n\n            if 0<= nx < x_limit:\n                if (ny >= y_limit - 1) and field[ny][nx] == BLANK:\n                    ans += num\n                else:\n                    if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\\????????´???\n                        if ny+2 > y_limit - 1:\n                            ans += num\n                        else:\n                            t = '{}_{}'.format(nx, ny+2)\n                            if not path[t]:\n                                Q.append((nx, ny+2))\n                            path[t] += num\n                    elif field[ny][nx] == BLANK:\n                        t = '{}_{}'.format(nx, ny)\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans\n\n\ndef main(args):\n    while True:\n        X, Y = map(int, input().strip().split())\n        if X == 0 and Y == 0:\n            break\n        field = []\n        for _ in range(Y):\n            temp = [int(x) for x in input().strip().split()]\n            field.append(temp)\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "problem_id": "p00204",
    "problem_statement": "UFO Shooting Operation\n\nIn the year 40XX, Earth was under attack by aliens! Most of the Earth has already been conquered by aliens, and the only remaining defense stronghold is Tsuruga Castle Fortress. Even Tsuruga Castle Fortress is being approached by the conquering forces one after another. \n\n\n\n\n\n\nHowever, there is still hope. The final weapon of the defense army, the ultra-long-range penetrating laser cannon, has been completed. The only drawback is that a certain distance is required before the power is displayed, and if the enemy is too close, it will simply pass through. The defense staff must know the number of invading UFOs, but there are too many enemies to count accurately. So the staff ordered you to prepare a program that outputs the number of UFOs that were not shot down by the laser. Create a program before the start of the battle and become a force to defend Tsuruga Castle Fortress.\n\n\nThe enemy UFOs simply rush straight towards the position of the laser cannon (UFOs are processed to pass through each other, so there is no collision). The laser cannon starts targeting the center of the nearest UFO one minute after the initial state, and continues to fire the laser under the same conditions every minute thereafter. The laser can penetrate, and can shoot down UFOs that are only grazed by the laser beam. However, this laser has a range where its power cannot be displayed, and UFOs that have entered this range cannot be targeted and are therefore designed not to be targeted. The staff of the defense army ordered you to create a program that outputs the number of UFOs that have entered this range for dealing with the invading UFOs. If you can shoot down as many UFOs as possible, how many UFOs have entered the range where the laser's power cannot be displayed?\n\n\nCreate a program that takes as input the radius R of the range where the laser's power cannot be displayed and information about the invading UFOs, and outputs the number of UFOs that have invaded without being shot down. The information about the invading UFOs consists of the number of UFOs N, the initial coordinates (x0, y0), the radius r, and the speed v of each UFO.\n\n\nThe coordinate origin (0, 0) is the position of the laser cannon. The distance between the laser cannon and the UFO is given as the distance from the origin to the center of the UFO, and UFOs that are within R of this distance are considered to have entered the range where the laser's power cannot be displayed. It is assumed that there are no cases where there are multiple targets to be aimed at simultaneously. All calculations are performed on a two-dimensional plane, and all input values are integers.\n\nInput\n\nThe input includes multiple datasets. The input is terminated by two zeros.\nEach dataset is given in the following format.\n\n\nR N\nx01 y01 r1 v1\nx02 y02 r2 v2\n:\nx0N y0N rN vN\n\n\nThe radius R (1 ≤ R ≤ 500) of the range where the laser's power cannot be displayed and the number of UFOs N (1 ≤ N ≤ 100) are given on the first line. The subsequent N lines give the information for each of the i-th UFO: the initial coordinates x0i, y0i (-100 ≤ x0i, y0i ≤ 1000), the radius ri, and the speed vi (1 ≤ ri, vi ≤ 500).\n\n\nThere are no more than 50 datasets.\n\nOutput\n\nFor each input dataset, output the number of UFOs that have invaded the range where the laser's power cannot be displayed on a single line.\n\nSample Input\n\n100 5\n101 101 5 5\n110 110 2 3\n-112 -100 9 11\n-208 160 82 90\n-110 108 10 2\n10 11\n15 0 5 1\n25 0 5 1\n35 0 5 1\n45 0 5 1\n55 0 5 1\n65 0 5 1\n75 0 5 1\n85 0 5 1\n95 0 5 1\n-20 0 5 20\n-30 0 500 5\n0 0\n\nOutput for the Sample Input\n\n1\n1\n",
    "buggy": "import math\nans = []\nwhile True:\n    ufo = []\n    n = input().split()\n    if n == [\"0\", \"0\"]:\n        for an in ans:\n            print(an)\n        break\n    else:\n        R = int(n[0])\n        for i in range(int(n[1])):\n            m = [int(f) for f in input().split()]\n            ufo.append([math.sqrt(m[0] ** 2 + m[1] ** 2), math.sqrt(m[0] ** 2 + m[1] ** 2), (m[0], m[1]), m[2], m[3]])\n        a = 0\n        while len(ufo) > 0:\n            flag = True\n            for xs in ufo: xs[0] -= xs[4]\n            ufo.sort()\n            for xs in ufo[:]:\n                if xs[0] + xs[3] <= R:\n                    a += 1\n                    ufo.remove(xs)\n                    continue\n                elif flag:\n                    r = xs[1]\n                    pos = xs[2]\n                    ufo.remove(xs)\n                    flag = False\n                    continue\n                else:\n                    d = xs[0] / xs[1] * abs(pos[0] * xs[2][1] - pos[1] * xs[2][0]) / r\n                    if d <= xs[3]:\n                        if xs[0] * math.cos(math.atan2(xs[2][1], xs[2][0]) - math.atan2(pos[1], pos[0])) + math.sqrt(xs[3] ** 2 + d ** 2) > R:\n                            ufo.remove(xs)\n        else:\n            ans.append(a)",
    "fixed": "import math\nans = []\nwhile True:\n    ufo = []\n    n = input().split()\n    if n == [\"0\", \"0\"]:\n        for an in ans:\n            print(an)\n        break\n    else:\n        R = int(n[0])\n        for i in range(int(n[1])):\n            m = [int(f) for f in input().split()]\n            ufo.append([math.sqrt(m[0] ** 2 + m[1] ** 2), math.sqrt(m[0] ** 2 + m[1] ** 2), (m[0], m[1]), m[2], m[3]])\n        a = 0\n        while len(ufo) > 0:\n            flag = True\n            for xs in ufo: xs[0] -= xs[4]\n            ufo.sort()\n            for xs in ufo[:]:\n                if xs[0] <= R:\n                    a += 1\n                    ufo.remove(xs)\n                    continue\n                elif flag:\n                    r = xs[1]\n                    pos = xs[2]\n                    ufo.remove(xs)\n                    flag = False\n                    continue\n                else:\n                    d = xs[0] / xs[1] * abs(pos[0] * xs[2][1] - pos[1] * xs[2][0]) / r\n                    if d <= xs[3]:\n                        if xs[0] * math.cos(math.atan2(xs[2][1], xs[2][0]) - math.atan2(pos[1], pos[0])) + math.sqrt(xs[3] ** 2 - d ** 2) > R:\n                            ufo.remove(xs)\n        else:\n            ans.append(a)"
  },
  {
    "problem_id": "p00205",
    "problem_statement": "Rock-Paper-Scissors\n\nFive friends decided to play rock-paper-scissors. In this game, there are three possible moves: rock, paper, and scissors. Rock beats scissors, scissors beats paper, and paper beats rock. If two players make the same move, the game is a tie. \n\n\nWrite a program that takes as input the five moves of each player and outputs the result of each player's game. Rock is represented by the number 1, scissors by the number 2, and paper by the number 3. A win is represented by the number 1, a loss by the number 2, and a tie by the number 3. The program should output the results in the order in which the input was given.\n\nInput\n\nThe input consists of multiple datasets. The input ends with a line containing a single zero.\nEach dataset is given in the following format:\n\n\nh1\nh2\nh3\nh4\nh5\n\n\nThe i-th line contains the move of the i-th player, which is an integer hi (1, 2, or 3).\n\n\nThere will be at most 200 datasets.\n\nOutput\n\nFor each dataset, output the results of the five players' games. The i-th line should contain the result of the i-th player's game (1, 2, or 3).\n\nSample Input\n\n1\n2\n3\n2\n1\n1\n2\n2\n2\n1\n0\n\nOutput for the Sample Input\n\n3\n3\n3\n3\n3\n1\n2\n2\n2\n1\n",
    "buggy": "while True:\n    h = int(input())\n    if h == 0:\n        break\n    dataset = [h] + [int(input()) for _ in range(4)]\n    if len(set(dataset)) == 3 or len(set(dataset)) == 1:\n        print(*[3]*5, sep=\"\\n\")\n    for data in dataset:\n        if data == 1:\n            print(2 if 3 in dataset else 1)\n        elif data == 2:\n            print(2 if 1 in dataset else 1)\n        else:\n            print(2 if 2 in dataset else 1)",
    "fixed": "while True:\n    h = int(input())\n    if h == 0:\n        break\n    dataset = [h] + [int(input()) for _ in range(4)]\n    if len(set(dataset)) == 3 or len(set(dataset)) == 1:\n        print(*[3]*5, sep=\"\\n\")\n        continue\n    \n    for data in dataset:\n        if data == 1:\n            print(2 if 3 in dataset else 1)\n        elif data == 2:\n            print(2 if 1 in dataset else 1)\n        else:\n            print(2 if 2 in dataset else 1)"
  },
  {
    "problem_id": "p00206",
    "problem_statement": "When to travel?\n\nYou are considering traveling with your friend. However, your friend has a tendency to spend money and can't save enough for the trip. You don't know when you will be able to travel if your friend continues to live as he is now. Therefore, you decided to create a program to help your friend save money systematically.\n\n\nIf your friend's allowance for a certain month is M yen and the amount of money to be spent that month is N yen, the amount saved for that month is (M - N) yen. Create a program that takes the income and expenses for each month and outputs the number of months it will take to save up to the travel cost L. However, if the amount saved does not reach the travel cost even after 12 months, output NA.\n\nInput\n\nA sequence of multiple datasets is given as input. The end of input is indicated by a single zero line.\nEach dataset is given in the following format.\n\n\nL\nM1 N1\nM2 N2\n:\nM12 N12\n\n\nThe first line contains the travel cost L (1 ≤ L ≤ 1000000, an integer). The next 12 lines give the income and expenses for the i-th month, Mi and Ni (0 ≤ Mi, Ni ≤ 100000, Ni ≤ Mi, integers).\n\n\nThere will not be more than 1000 datasets.\n\nOutput\n\nFor each dataset, output the number of months it will take to save up to the travel cost in one line.\n\nSample Input\n\n10000\n5000 3150\n5000 5000\n0 0\n5000 1050\n5000 3980\n5000 210\n5000 5000\n5000 5000\n0 0\n5000 2100\n5000 2100\n5000 2100\n29170\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 100000\n100000 70831\n0\n\nOutput for the Sample Input\n\n6\nNA\n",
    "buggy": "while True:\n    l = eval(input())\n    if l==0: break\n    c = []; m = 0;\n    for i in range(12):\n        c += list(map(int, input().split()))\n    for i in range(0,12,2):\n        m += c[i]-c[i+1]\n        if m>=l:\n            print(i/2+1); break;\n    if m<l:\n        print(\"NA\")",
    "fixed": "while True:\n    l = eval(input())\n    if l==0: break\n    c = []; m = 0;\n    for i in range(12):\n        c += list(map(int, input().split()))\n    for i in range(0,24,2):\n        m += c[i]-c[i+1]\n        if m>=l:\n            print(i/2+1); break;\n    if m<l:\n        print(\"NA\")"
  },
  {
    "problem_id": "p00207",
    "problem_statement": "Blocks\nA relative of person A, B, who loves blocks, visited A's house. He is 3 years old and the blocks he has are shaped like the one in Figure 1. \n\n\nFigure 1\n\nB is laying out blocks on the board. When asked \"What are you making?\" He cheerfully replied, \"A maze!!\". His maze is a block configuration that can be traversed only by blocks of the same color that are adjacent to each other from start to finish. Figure 2 shows that a maze has been created from the upper left (start) to the lower right (goal) due to the yellow blocks. \n\n\nFigure 2\n\nWhile watching B play innocently, you, a programmer, decided to check if the order of the blocks forms a maze. \nCreate a program that inputs the block information and the coordinates of the start and goal, and outputs \"OK\" if the blocks form a maze and \"NG\" if not. The board has a size of w in the horizontal direction and h in the vertical direction, and the upper left and lower right coordinates of the board are (1, 1) and (w, h), respectively. The block is a rectangle of 2 x 4 size and all blocks are the same size. The color c of the block is either 1 (white), 2 (yellow), 3 (green), 4 (blue), or 5 (red). The orientation d of the block on the board is 0 if it is longer horizontally and 1 if it is longer vertically. The position of the block is represented by the coordinates of the upper left of the block (x, y). Note that the position of a block does not overlap with other blocks and does not protrude from the board. \nInput\nA sequence of multiple datasets is given as input. The end of the input is indicated by two consecutive zeros.\nEach dataset is given in the following format:\n\nw h\nxs ys\nxg yg\nn\nc1 d1 x1 y1\nc2 d2 x2 y2\n:\ncn dn xn yn\n\nThe first line gives the size of the board w, h (4 ≤ w, h ≤ 100). The second line gives the coordinates of the start xs, ys, and the third line gives the coordinates of the goal xg, yg.\nThe fourth line gives the number of blocks n. The following n lines give the color ci, orientation di, and position xi, yi of the i-th block.\nThe number of datasets is no more than 30.\nOutput\nFor each input dataset, output the judgment result on one line.\nSample Input\n\n20 20 \n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0\n\nOutput for the Sample Input\n\nOK\nNG\n",
    "buggy": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nBlock = namedtuple('Block', ['color', 'direction', 'x', 'y'])\n\n\ndef occupation_point(block):\n    x, y = block.x, block.y\n    d = [(0, 0), (1, 0), (0, 1), (1, 1)]\n    for dx, dy in d:\n        yield x + dx, y + dy\n    if block.direction:\n        y += 2\n    else:\n        x += 2\n    for dx, dy in d:\n        yield x + dx, y + dy\n\ndef paintout(board, start, value):\n    color = board[start.y][start.x]\n    if color == 0:\n        return\n    que =[(start.x, start.y)]\n    print('cv',color, value)\n    while que:\n        x,y = que.pop()\n        if board[y][x] == color:\n            board[y][x] = value\n            que.extend([(x + dx, y + dy) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]])\n\n\ndef is_reachable(size, start, goal, blocks):\n    board = [[0] * (size.x + 2) for _ in range(size.y + 2)]\n    for bi in blocks:\n        for x, y in occupation_point(bi):\n            board[y][x] = bi.color\n    paintout(board, start, -1)\n    for bi in board:\n        print(bi)\n    return board[goal.y][goal.x] == -1\n\n\nwhile True:\n    size = Point(*map(int, readline().split()))\n    if size.x == 0:\n        break\n    start = Point(*map(int, readline().split()))\n    goal = Point(*map(int, readline().split()))\n    blocks = []\n    for _ in range(int(readline())):\n        blocks.append(Block(*map(int, readline().split())))\n    print('OK' if is_reachable(size, start, goal, blocks) else 'NG')",
    "fixed": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nBlock = namedtuple('Block', ['color', 'direction', 'x', 'y'])\n\n\ndef occupation_point(block):\n    x, y = block.x, block.y\n    d = [(0, 0), (1, 0), (0, 1), (1, 1)]\n    for dx, dy in d:\n        yield x + dx, y + dy\n    if block.direction:\n        y += 2\n    else:\n        x += 2\n    for dx, dy in d:\n        yield x + dx, y + dy\n\ndef paintout(board, start, value):\n    color = board[start.y][start.x]\n    if color == 0:\n        return\n    que =[(start.x, start.y)]\n    while que:\n        x,y = que.pop()\n        if board[y][x] == color:\n            board[y][x] = value\n            que.extend([(x + dx, y + dy) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]])\n\n\ndef is_reachable(size, start, goal, blocks):\n    board = [[0] * (size.x + 2) for _ in range(size.y + 2)]\n    for bi in blocks:\n        for x, y in occupation_point(bi):\n            board[y][x] = bi.color\n    paintout(board, start, -1)\n    return board[goal.y][goal.x] == -1\n\n\nwhile True:\n    size = Point(*map(int, readline().split()))\n    if size.x == 0:\n        break\n    start = Point(*map(int, readline().split()))\n    goal = Point(*map(int, readline().split()))\n    blocks = []\n    for _ in range(int(readline())):\n        blocks.append(Block(*map(int, readline().split())))\n    print('OK' if is_reachable(size, start, goal, blocks) else 'NG')"
  }
]
