"""Training logger for saving metrics to file for analysis and graphing."""

import json
import os
from datetime import datetime
from typing import Dict, Any, List


class TrainingLogger:
    """Logs training metrics to JSON file incrementally."""
    
    def __init__(self, log_file: str = "training_log.json"):
        """Initialize logger.
        
        Args:
            log_file: Path to JSON log file
        """
        self.log_file = log_file
        self.session_start = datetime.now().isoformat()
        
        # Initialize or load existing log
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                self.data = json.load(f)
        else:
            self.data = {
                "sessions": []
            }
        
        # Start new session
        self.current_session = {
            "start_time": self.session_start,
            "steps": []
        }
        self.data["sessions"].append(self.current_session)
        self._save()
    
    def log_step(
        self,
        step: int,
        stage_id: int,
        model_type: str,  # "discriminator" or "generator"
        problem_id: str,
        
        # Reward metrics
        disc_reward: float,
        gen_reward: float,
        
        # Test execution metrics (discriminator-generated tests)
        num_tests_generated: int,
        num_tests_valid: int,
        num_tests_passed_gen: int,
        num_tests_total_gen: int,
        num_tests_passed_val: int,
        num_tests_total_val: int,
        
        # Baseline test metrics
        num_baseline_tests: int = 0,
        num_baseline_passed: int = 0,
        
        # Combined metrics (discriminator + baseline)
        num_tests_combined: int = 0,
        num_tests_passed_combined: int = 0,
        
        # Loss
        loss: float = None,
        
        # Code quality metrics
        code_length: int = 0,
        has_syntax_error: bool = False,
        
        # Test quality samples
        test_samples: List[str] = None
    ):
        """Log a training step.
        
        Args:
            step: Global step number
            stage_id: Reasoning stage (1-5)
            model_type: Which model is being trained
            problem_id: Problem identifier
            disc_reward: Discriminator reward
            gen_reward: Generator reward
            num_tests_generated: Number of tests generated by discriminator
            num_tests_valid: Number of discriminator tests that passed validation
            num_tests_passed_gen: Discriminator tests passed by generator code
            num_tests_total_gen: Total discriminator tests run on generator
            num_tests_passed_val: Tests passed by validation (ground truth)
            num_tests_total_val: Total tests run on validation
            num_baseline_tests: Number of baseline tests
            num_baseline_passed: Baseline tests passed by generator
            num_tests_combined: Total tests including baseline
            num_tests_passed_combined: Tests passed including baseline
            loss: Training loss (if available)
            code_length: Length of generated code
            has_syntax_error: Whether code has syntax errors
            test_samples: Sample test cases for inspection
        """
        step_data = {
            "step": step,
            "timestamp": datetime.now().isoformat(),
            "stage_id": stage_id,
            "model_type": model_type,
            "problem_id": problem_id,
            
            # Rewards
            "disc_reward": disc_reward,
            "gen_reward": gen_reward,
            
            # Discriminator test metrics
            "num_tests_generated": num_tests_generated,
            "num_tests_valid": num_tests_valid,
            "num_tests_passed_gen": num_tests_passed_gen,
            "num_tests_total_gen": num_tests_total_gen,
            "num_tests_passed_val": num_tests_passed_val,
            "num_tests_total_val": num_tests_total_val,
            
            # Baseline test metrics
            "num_baseline_tests": num_baseline_tests,
            "num_baseline_passed": num_baseline_passed,
            
            # Combined metrics
            "num_tests_combined": num_tests_combined,
            "num_tests_passed_combined": num_tests_passed_combined,
            
            # Derived metrics
            "gen_pass_rate": num_tests_passed_gen / num_tests_total_gen if num_tests_total_gen > 0 else 0.0,
            "val_pass_rate": num_tests_passed_val / num_tests_total_val if num_tests_total_val > 0 else 0.0,
            "baseline_pass_rate": num_baseline_passed / num_baseline_tests if num_baseline_tests > 0 else 0.0,
            "combined_pass_rate": num_tests_passed_combined / num_tests_combined if num_tests_combined > 0 else 0.0,
            "test_validity_rate": num_tests_valid / num_tests_generated if num_tests_generated > 0 else 0.0,
            
            # Code quality
            "code_length": code_length,
            "has_syntax_error": has_syntax_error,
            
            # Loss
            "loss": loss
        }
        
        # Add test samples if provided (for debugging/inspection)
        if test_samples:
            step_data["test_samples"] = test_samples[:5]  # Keep first 5
        
        self.current_session["steps"].append(step_data)
        self._save()
    
    def log_epoch_summary(
        self,
        epoch: int,
        stage_id: int,
        model_type: str,
        metrics: Dict[str, Any]
    ):
        """Log summary metrics for an epoch.
        
        Args:
            epoch: Epoch number
            stage_id: Reasoning stage
            model_type: Which model
            metrics: Dictionary of summary metrics
        """
        if "epoch_summaries" not in self.current_session:
            self.current_session["epoch_summaries"] = []
        
        summary = {
            "epoch": epoch,
            "stage_id": stage_id,
            "model_type": model_type,
            "timestamp": datetime.now().isoformat(),
            **metrics
        }
        
        self.current_session["epoch_summaries"].append(summary)
        self._save()
    
    def log_problem_summary(
        self,
        problem_id: str,
        stage_id: int,
        model_type: str,
        disc_reward: float,
        gen_reward: float,
        num_tests_generated: int,
        num_tests_valid: int,
        num_tests_passed: int,
        num_tests_total: int,
        test_validity_rate: float,
        test_pass_rate: float,
        has_syntax_error: bool
    ):
        """Log summary after processing one problem.
        
        Args:
            problem_id: Problem identifier
            stage_id: Reasoning stage
            model_type: discriminator or generator
            disc_reward: Discriminator reward
            gen_reward: Generator reward
            num_tests_generated: Total tests generated
            num_tests_valid: Valid tests only
            num_tests_passed: Tests passed
            num_tests_total: Tests evaluated (valid only)
            test_validity_rate: Fraction of generated tests that are valid
            test_pass_rate: Fraction of valid tests that passed
            has_syntax_error: Whether code has syntax errors
        """
        if "problem_summaries" not in self.current_session:
            self.current_session["problem_summaries"] = []
        
        summary = {
            "problem_id": problem_id,
            "stage_id": stage_id,
            "model_type": model_type,
            "timestamp": datetime.now().isoformat(),
            "disc_reward": disc_reward,
            "gen_reward": gen_reward,
            "num_tests_generated": num_tests_generated,
            "num_tests_valid": num_tests_valid,
            "num_tests_passed": num_tests_passed,
            "num_tests_total": num_tests_total,
            "test_validity_rate": test_validity_rate,
            "test_pass_rate": test_pass_rate,
            "has_syntax_error": has_syntax_error
        }
        
        self.current_session["problem_summaries"].append(summary)
        self._save()
    
    def log_stage_summary(
        self,
        stage_id: int,
        model_type: str,
        num_problems: int,
        avg_disc_reward: float,
        avg_gen_reward: float,
        avg_test_validity_rate: float,
        avg_test_pass_rate: float,
        avg_loss: float,
        syntax_error_rate: float
    ):
        """Log summary after completing a stage.
        
        Args:
            stage_id: Reasoning stage
            model_type: discriminator or generator
            num_problems: Number of problems processed
            avg_disc_reward: Average discriminator reward
            avg_gen_reward: Average generator reward
            avg_test_validity_rate: Average test validity rate
            avg_test_pass_rate: Average pass rate on valid tests
            avg_loss: Average training loss
            syntax_error_rate: Fraction with syntax errors
        """
        if "stage_summaries" not in self.current_session:
            self.current_session["stage_summaries"] = []
        
        summary = {
            "stage_id": stage_id,
            "model_type": model_type,
            "timestamp": datetime.now().isoformat(),
            "num_problems": num_problems,
            "avg_disc_reward": avg_disc_reward,
            "avg_gen_reward": avg_gen_reward,
            "avg_test_validity_rate": avg_test_validity_rate,
            "avg_test_pass_rate": avg_test_pass_rate,
            "avg_loss": avg_loss,
            "syntax_error_rate": syntax_error_rate
        }
        
        self.current_session["stage_summaries"].append(summary)
        self._save()
    
    def end_session(self):
        """Mark session as complete."""
        self.current_session["end_time"] = datetime.now().isoformat()
        self._save()
    
    def _save(self):
        """Save current data to file."""
        with open(self.log_file, 'w') as f:
            json.dump(self.data, f, indent=2)
    
    def get_summary_stats(self) -> Dict[str, Any]:
        """Get summary statistics for current session.
        
        Returns:
            Dictionary with summary stats
        """
        steps = self.current_session["steps"]
        if not steps:
            return {}
        
        # Compute averages
        disc_steps = [s for s in steps if s["model_type"] == "discriminator"]
        gen_steps = [s for s in steps if s["model_type"] == "generator"]
        
        return {
            "total_steps": len(steps),
            "disc_steps": len(disc_steps),
            "gen_steps": len(gen_steps),
            "avg_disc_reward": sum(s["disc_reward"] for s in disc_steps) / len(disc_steps) if disc_steps else 0,
            "avg_gen_reward": sum(s["gen_reward"] for s in gen_steps) / len(gen_steps) if gen_steps else 0,
            "avg_gen_pass_rate": sum(s["gen_pass_rate"] for s in steps) / len(steps),
            "avg_val_pass_rate": sum(s["val_pass_rate"] for s in steps) / len(steps),
            "avg_test_validity": sum(s["test_validity_rate"] for s in steps) / len(steps),
            "syntax_error_rate": sum(1 for s in steps if s["has_syntax_error"]) / len(steps)
        }
